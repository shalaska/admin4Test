Section: ### I have multiple web applications that my users access via a browser. I would like to authenticate them using mobile authentication. Is the Nevis Access App the right approach for that?
Yes. The Nevis Access App is an excellent fit for this scenario. When a user attempts to log in to the application, an authentication request is triggered and sent to the authenticating user's Access App.
The Nevis Access App supports handling multiple accounts or identities, so, if your web applications require to authenticate with different identities, a single Access App will be enough.
--------------------------------------------------------------------------------
Section: ### number-matching.md
---
sidebar_position: 15
---

# Number Matching

The number matching feature serves to prevent MFA (multi factor authentication) fatiuge attacks.

:::info Multi Factor Authentication Fatigue Attack

MFA push fatigue attack, also known as MFA Bombing or MFA Spamming, is a type of social engineering cyberattack. In this strategy, attackers repeatedly send second-factor authentication requests to the target victim registered devices. The attack relies on users approving simple push notifications without knowing the context of the session they are authenticating.

:::

## Overview

If _number matching_ is used when triggering out-of-band authentication via push message in the server, the application asks the end-user to provide some digits. The operation will only continue if the user enters the correct digits displayed on the screen into the Access App.

It is important to present the end-user enough information in both the web application (where the out-of-band authentication is started) and the Access App about the necessary digits. In the Access App, the label `number_matching_screen_description` in the [localizations file](../ordering-an-access-app.md#localizations-file) contains context information that helps to define the required digits.

If the user provides invalid digits, the authentication will fail.

<img className="boxed" src={require('../assets/number-matching-app-feature.drawio.png').default} alt="Number Matching with Push Messages"/>

1. The user performs a login or transaction confirmation, a push message is sent to the Access App.
2. The browser shows a random, two digit code.
3. The user enters the code displayed in the browser in the Access App and confirms the entry.
4. If the code matches, the user can continue with the operation.
5. The user completes the operation.

:::info Related documentation

For additional _conceptual_ information, refer to the following chapters in the concept guide:

* [Channel Linking](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication#channel-linking) contains information regarding the number matching concept from the backends point of view. Number matching is a _specific subset_ of channel linking.

For additional _technical_ information, visit the following chapters in the reference guide:

* [Out of Band FIDO UAF Auth State](/nevisfido/reference-guide/config-nevis-components/nevisauth-fido-authstates/fido-uaf/outofbandfidouafauthstate) contains information of how to configure the nevisAuth auth state.

:::
--------------------------------------------------------------------------------
Section: ### qr_code.md
---
sidebar_position: 30
---

# QR Code

A QR code is a convenient alternative to push messages if the end user has access to two different devices during operations. This is a prerequisite for using QR codes, because the code needs to be scanned by the mobile application.

## Prerequisites

The end user has access to a web application that displays the QR code generated by the Nevis backend or by a third-party system.

## How it Works

<img className="boxed" src={require('../../assets/oob-qr-code-dispatch.png').default} alt="Out-of-Band Operations with QR Codes"/>

The example use case in the above figure shows how QR codes work. The numbers in the figure correspond with the numbers of the description below.

1. The end user opens the web page on a desktop browser and initiates an out-of-band operation. As the end user does not have push notifications available (for any of the above-mentioned reasons), the web application offers an alternative possibility in the form of a QR code.
2. The end user opens the app and scans the displayed QR code.
3. The desired operation starts.

:::info Related documentation

For additional _conceptual_ information, refer to the following chapters in the concept guide:

* [Out-of-Band Message Transmission](/configurationguide/mobile-auth-concept-and-integration-guide/concept-description/out-of-band-message-transmission) contains information regarding the message transmission concept.
* [Out-of-Band Registration](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-registration) contains information regarding the registration scenario.
* [Out-of-Band Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication) contains information regarding the authentication scenario.
* [Out-of-Band Transaction Confirmation](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-transaction-confirmation) contains information regarding the transaction confirmation scenario.

For additional _technical_ information, visit the following chapters in the reference guide:

* [QR Code Dispatcher](/nevisfido/reference-guide/dispatchers/qr-code-dispatcher) contains information of how to configure and use the QR code dispatcher.
* [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service) contains information regarding the HTTP API dispatch service.

:::
--------------------------------------------------------------------------------
Section: ### push_message.md
---
sidebar_position: 10
---

# Push message

Push notifications are the most convenient way of delivering information from the backend system to the mobile client application. The backend uses the [Google Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging) service to send push messages to the client.

## Prerequisites

* The end user **accepted** to receive push notifications.
* The end user registered his Access App on the Nevis Mobile Authentication backend.
* On Android devices, the Google Play Services need to be available. The Google Play Services are preinstalled on most Android devices but may be missing on some vendor models like for example Huawei.

:::info

Push notifications cannot be used for the _registration_ operation. This is because the push identifier is not known to the backend before the registration process is completed.
:::

## How it Works

<img className="boxed" src={require('../../assets/oob-push-messages.png').default} alt="Out-of-Band Operations with Push Messages"/>

The example use case in the above figure shows how push notifications work during an authentication operation. Other operations behave very similar, apart from who or what initiates the operation. The numbers in the figure correspond with the numbers of the description below.

1. The end user starts a login.
2. The Nevis Mobile Authentication Backend initiates an authentication, and sends a push message payload to a push provider.
3. The push provider sends an encrypted push notification to the mobile device. The mobile application has to deal with the notification.
4. The mobile application triggers the out-of-band authentication process with the SDK by providing the encrypted push notification.
5. Once the mobile application has completed the out-of-band authentication process, the user is granted access to the protected endpoint, for example, a web application in a desktop browser.

## Preventing push-fatigue attacks

If you want to prevent push fatigue attacks, we recommend using push messages in combination with the [number matching](../number-matching) feature.

:::info Related documentation

For additional _conceptual_ information, refer to the following chapters in the concept guide:

* [Out-of-Band Message Transmission](/configurationguide/mobile-auth-concept-and-integration-guide/concept-description/out-of-band-message-transmission) contains information regarding the message transmission concept.
* [Out-of-Band Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication) contains information regarding the authentication scenario.
* [Out-of-Band Transaction Confirmation](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-transaction-confirmation) contains information regarding the transaction confirmation scenario.

For additional _technical_ information, visit the following chapters in the reference guide:

* [FCM Dispatcher](/nevisfido/reference-guide/dispatchers/fcm-dispatcher) contains information of how to configure and use the push message dispatcher.
* [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service) contains information regarding the HTTP API dispatch service.

:::
--------------------------------------------------------------------------------
Section: ### link.md
---
sidebar_position: 20
---

# Link

This section focuses on end-user interactions when there is only _one_ mobile device (and no desktop) available or in use. This method is referred to as the "mobile-only solution". It makes use of links to transfer information from the backend to the Access App.

:::tip

* For **additional information** regarding the **Apple App Association file** as well as the **Google App-Site association** file refer to [app link best practices](/nevisaccessapp/appendixes/app-link-best-practices) in the appendix.
* If the application is not yet installed, the browser is able to **initiate the installation of the mobile application** in a convenient way in case [app links](#app-links---starting-with-the-https-scheme) are used.
* We recommend **hosting a page on the app link path** which offers the end user a direct link to the Google Play Store or Apple App Store.

:::

## Prerequisites

App links require certain prerequisites to work:

* (iOS) The link has to refer to an HTTP domain endpoint that hosts an [Apple App Association File](https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html) in a well-known location.
* (iOS) The page with the link has to contain an HTML meta tag that allows the Safari browser on iOS to display a [smart banner](https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/PromotingAppswithAppBanners/PromotingAppswithAppBanners.html) for the application.
* (Android) The link refers to an HTTP domain endpoint that hosts an App-Site association/link [verification file](https://github.com/google/digitalassetlinks/blob/master/well-known/details.md) in a well-known location.

## How it Works

<img className="boxed" src={require('../../assets/oob-mobile-only.png').default} alt="Out-of-Band Operations with app links"/>

The example use case in the above figure shows how linking works. The numbers in the figure correspond with the numbers of the description below.

1. The end user opens the web page on his/her mobile phone and initiates an out-of-band operation. Because the end user has only one device at hand, and no push notifications are available, the web application offers an alternative possibility in the form of a link.
2. The user clicks the link. This opens the mobile application and forwards the out-of-band payload.
3. The user is authenticated.
4. The desired operation starts.
--------------------------------------------------------------------------------
Section: ### Fixes
* The Access App relies on the system CA certificates to validate the server certificate and is strict doing hostname validation (NEVISACCESSAPP-5210).

## Nevis Access App Android 2.7.2 - 12.09.2023
--------------------------------------------------------------------------------
Section: ### Highlights
We are pleased to present the **Nevis Cluster 2.201911.427 LTS** release. This is the first Nevis release covered by an extensive long-term-support plan, as detailed in the Nevis Product Lifetime and Platform Support Matrix. The LTS (long-term-support) releases focus on stability and will fix defects and security issues while avoiding major, potentially breaking changes.

This release ships, among many bug fixes and product improvements, with the following highlights:

* Performance improvements and faster recovery in the nevisProxy MariaDB session store, leading to a better user experience during infrastructure failovers.
* Support of TLS 1.3, the new and most secure version of the TLS protocol in nevisProxy (requires at least nevisAppliance, RHEL 7 and SLES12 only).
* Full support for OAuth 2.0 token introspection endpoints (RFC 7662).
* Protect your services with terms and conditions, using the new feature available in nevisIDM.
* Starting with this release, nevisIDM fully supports the latest long-term release of Oracle: Oracle 19c.
* Performance and stability improvements in nevisAdmin 4 when working with large deployments.
* PREVIEW Experimental support of highly automated Kubernetes deployments in nevisAdmin 4.
* … and much much more.
--------------------------------------------------------------------------------
Section: ### Concept-Description-and-Technical-Architecture.md
---
sidebar_position: 3
---

# Concept Description and Technical Architecture

The nevisAppliance is the recommended Linux platform for Nevis software. The nevisAppliance provides an opinionated and fixed set of pre-installed packages and configuration, it is not meant as general purpose Linux.

It uses the CentOS/64bit operating system configured for optimal performance, and features adequate security settings to be used within DMZ and secure network zones.

The nevisAppliance can be used in two different configurations. When used as a hardware appliance, the software is directly installed on the server's disk. As a software appliance, it is delivered as a CDROM (ISO) image which has to be installed in a virtual server (VMware ESX).

## File system

The nevisAppliance uses an overlay file system which consists of multiple layers.

* The lowest level contains the operating system (OS). It is a single squashfs image file mounted to the "/" mount point. This image contains all operating system files (/bin, /usr, …) as well as third party software components, such as the MySQL database or the ClamAV virus scanning engine. The scope of available software within this layer depends on the image type you have chosen, see the chapter "Image types". This layer is going to be replaced whenever you install a new `neviscd2_<version>os<type>.img` file.
* The operating system image is transparently overlaid by a writable file system storing all persistent data, such as all your configuration and log files. Every file, symbolic link and empty directory not listed within the */etc/rwdisk.conf* file is going to be deleted when rebooting the server. Thus, do not install any additional software packages (rpm), or they will get lost once you reboot the server.
* The third layer includes the Nevis products and component images. Each Nevis product or component is packed into a single read-only file system and all those image files are mounted to the `/opt/nevis*` directories. This layer is updated by installing a new `neviscd2_<cluster_version>nevis<type>.img` file.

<img className="boxed" src={require('./attachments/6651585/7635447.png').default} alt="File system layers"/>

## Reference architecture

A nevisAppliance is able to host different Nevis software. You choose which product or component to use by creating an instance of the required product or component. Figure below Sample network diagram shows two appliances. One is located within the DMZ hosting nevisProxy instances, while the second one is located within the secure server network called "Application Zone" hosting a nevisAuth instance.

<img className="boxed" src={require('./attachments/6651585/7635448.png').default} alt="Sample network diagram"/>

The nevisAppliance within the DMZ uses two Ethernet interfaces:

* The intranet Ethernet interface (eth0) is connected to the internal firewall. It is used for the communication from the nevisAppliance to the application servers as well as for the administrative network traffic from the management server to the nevisAppliance. You can add routes to the intranet servers using the nevis-appliance command.
* The internet Ethernet interface (eth1) is connected to the external firewall. It is used for connections from clients using the web applications to the nevisAppliance. The default route is normally configured using the router attached to this interface.

The nevisAppliance within the "Application Zone" uses one Ethernet interface:

* The internal Ethernet interface is used for application and administrative network traffic.
--------------------------------------------------------------------------------
Section: ### Communication ports
Figure below Default ports shows the default ports Nevis product or components commonly use for communicating with each other.

<img className="boxed" src={require('./attachments/6651585/7635451.png').default} alt="Default ports"/>

| Port | Protocol | Usage |
| --- | --- | --- |
| TCP 80/443 | HTTP and HTTPS | The standard ports for HTTP(S) traffic. |
| TCP 8991 | SOAP over HTTPS | The communication between nevisProxy and nevisAuth. |
| TCP 8988 | HTTP | The communication between nevisProxy and nevisLogRend (usually, nevisLogRend is located on the same server as nevisProxy and is listening on the local loopback interface (localhost)). |
| TCP 8989 | SOAP over HTTPS | The communication between nevisAuth and nevisIDM. Can also be used to access the web front end of nevisIDM via nevisProxy. |
| UDP 694 | Failover heartbeat | Heartbeat messages exchanged between the nevisAgent instances. |
| TCP 9094 | HTTPS | Communication between nevisAdmin and nevisAgent (to every host). |
| UDP 123UDP 53 | NTP and DNS | NTP and DNS packages are sent to the central NTP and DNS servers. |
| UDP 514TCP 10514 | Syslog over UDP or TLS | Every server may forward log messages to the nevisAdmin server. |
| TCP 1186 | MySQL Cluster | The NDB nodes on nevisProxy and/or nevisAuth need to connect to the server hosting the management node. |
| TCP 22 | SSH | You may want to enable SSH access from the intranet or dedicated administration workstations to any server hosting Nevis products or components. |
| TCP 8037 | HTTPS | Web access to nevisAdmin (by the administrator). |
--------------------------------------------------------------------------------
Section: #### /etc/snmp/snmpd.conf
The SNMP daemon can be initialized using the  `nevisappliance` script and the command `m`.

<img className="boxed" src={require('../attachments/6651476/7635486.png').default} alt="Use the nevisappliance command to enable the SNMP daemon"/>

It creates an `snmpd.conf` file and sets the community string for read-only access. You can adapt the file according to your requirements. The `/usr/share/snmp/mibs/NEVIS-MIB.txt` management information base file describes the Nevis-specific parameters that can be supervised via SNMP.

See also Monitoring ClamAV and Database monitoring for information on additional components that you can configure on your nevisAppliance.

The following section shows a small selection of these parameters:

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyStatus.<instance index>`

 Alternatively, if you are using a failover cluster, the  `instanceProxyFOStatus` attribute can be checked: `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyFOStatus.<instance index>`

 Indicates whether the nevisProxy instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxySessions.<instance index>`

 Number of open user sessions.

 You should ensure that you have enough free sessions (at least 80% of the configured maximum).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyMemory.<instance index>`

 Virtual memory (in kilobytes) allocated by the working proxy process.

 During operation the memory consumption increases and an increase of several gigabytes is not uncommon. Usually, this value does not exceed its initial size by more than 2GB.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyResponseTime.<instance index>`

 Average request time (in seconds) of the HTTP requests.

 Can be an indication of slow application response times but sometimes you may also measure slow request times due to long-polling ajax requests or the download of huge files. This value is mainly used for statistical purposes and you don't need to configure a threshold.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyConnections.<instance index>`

 Number of TCP connections to the nevisProxy instance.

 In normal operation, this value shall not exceed 50% of the configured maximum.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.authTable.authEntry.instanceAuthStatus.<instance index>`

 Indicates if the nevisAuth instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.authTable.authEntry.instanceAuthJVMKBHeapUsage.<instance index>`

 Heap usage (in kbytes) of the nevisAuth instance's virtual machine.

 The value must not exceed (80%) of the configured limitation (Xmx).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.logrendTable.logrendEntry.instanceLogrendStatus.<instance index>`

 Indicates if the nevisLogRend instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.idmTable.idmEntry.instanceIdmStatus.<instance index>`

 Indicates if the nevisIDM instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.idmTable. instanceIdmJVMKBHeapUsage.<instance index>`

 Heap usage (in kbytes) of the nevisIDM instance's virtual machine.

 The value must not exceed (80%) of the configured limitation (Xmx).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.credTable.credEntry.instanceCredStatus.<instance index>`

 Indicates whether the nevisCred instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceDiskDeviceOnline.1`

 Number of disk devices which are online (to monitor the raid controller).Value must not change (a lower value indicates a device outage).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceFreeMemory.1`

 Available memory (in kilobytes) of the server.

 A server should always have enough free memory to handle peak-loads. A minimum of 256Mbytes is recommended.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceFreeSwap.1`

 Free swap space (in kilobytes) of the server.

 The server must not use the whole swap space during normal operation. We expect that at least 1GB of swap space will be left unused.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceLoad.1`

 Load of the server.

 The load of a server shall not exceed the number of available CPU cores heavily.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceFreeDiskSpace.1`

 Free disk space (in kilobytes) of the server.

Disk space is required to write log or persistent data. Always ensure that there is enough disk space available. A minimum of 10Gbytes is recommended (free disk space can fall below this value during a nevisAppliance update due to the transfer of the new image to the server).

Parameters are accessed on a per instance basis (instance index). You should verify/monitor the instance name as well to make sure that you are monitoring the correct instance.

## Extended service statistics
--------------------------------------------------------------------------------
Section: ### Start replication, slave database on node1
Now, you set up the same configuration the other way round for node1 to be slave of node2. Determine the status of node2 and start the replication on node1.

Example:

```script title="Record the log position on node2"
2> SHOW MASTER STATUS;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000002 | 37888579 |              |                  |
+------------------+----------+--------------+------------------+
```

Example:

```script title="Start replication from node2 to node1"
1> CHANGE
MASTER TO master_host='node2', master_port=3306, master_user='replication',
master_password='<admin password>', master_log_file='mysql-bin.000002',
master_log_pos=37888579;
1> START SLAVE;
1> SHOW SLAVE STATUS\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: node2
                  Master_User: replication
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000002
          Read_Master_Log_Pos: 37888579
               Relay_Log_File: mysql-relay-bin.000002
                Relay_Log_Pos: 529
        Relay_Master_Log_File: mysql-bin.000002
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
...
               Last_IO_Errno: 0
               Last_IO_Error:
              Last_SQL_Errno: 0
              Last_SQL_Error:
 Replicate_Ignore_Server_Ids:
            Master_Server_Id: 2
```

## Configure nevisIDM

The nevisIDM instance is created as documented in the nevisIDM reference guide.

*Use the same user names and passwords for which you granted remote access*.

The IP addresses of node1 and node2 are used in this example for illustration purposes. You can use these servers' host names instead, of course.:

```script title="Create the nevisIDM instance"
# nevisidm inst create nevisidm \
 IDMDB_CONNECTION=jdbc:mysql://node1:3306,node2:3306/nevisidm \
 IDMDB_USERNAME=UIDM02 \
 IDMDB_PASSWORD=password \
 IDM_APPL_URL=https://`hostname`:8989 \
 IDM_SERVER_1_URL=https://`hostname`:8989/nevisidm/services/v1/LoginService \
 IDM_SERVER_DB=mysql \
 RTGROUP=nvbgroup \
 RTOWNER=nvauser \
 SERVER_URL=https://`hostname`:8989 \
 NINJA_CERT=/var/opt/neviskeybox/default/<auth signer>/truststore.jks
```

After the instance creation, you need to edit the nevisIDM properties (using the *nevisidm config idm* command). Add the *failOverReadOnly=false* parameter to the *database.connection.url*.

Example:

```script title="Sample db.connection.url within the nevisidm-prod.properties file"
database.connection.url=jdbc:mysql://node1:3306,node2:3306/nevisidm?failOverReadOnly=false
```

You can start the nevisIDM instance now.

## Upgrading a nevisIDM version

For upgrading nevisIDM and migrating the nevisIDM database, refer to the nevisIDM release notes.

## Database monitoring

Monitoring of the database can be implemented by SNMP, see also the chapter Monitoring using SNMP. To enable enhanced database monitoring, you need to specify a user and password for the monitoring script. This user name and password have to be stored in the `/var/opt/nevisagent/mysql.conf` file.

Example:

```script title="Sample mysql.conf file"
db_connection_username=root
db_connection_password=password
```

We recommend monitoring the OIDs listed in the table below:

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceMySqlNodes.1`

 Indicates whether the MySQL daemons are running (= "1") or not (= "0").

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceMySqlSlaveStatus.1`

 Indicates whether the replication of this database works (= "1") or not (= "0").

## Database backup and recovery

The *mysqldump* program can make backups of your database. The backup shall be executed regularly.

You can use the backup script `/tools/dbbackup.sh` to execute the `mysqldump` command. This script reads its configuration from the `/var/opt/nevisagent/mysql.conf` file.

Example:

```script title="Sample mysql.conf file for backup purpose"
db_connection_username=root
db_connection_password=password
db_backup="mysql nevisidm"
```

On success, the script returns the name of the archive containing all database backup files on stdout.
To restore a database, extract the corresponding database file from the backup archive and import it into the primary node similar to the procedure shown in Import the databases.

```script title="Import example"
# mysql -u root -p < ~/db_mysql.sql
# mysql -p --execute='FLUSH PRIVILEGES;'
# mysql -u root -p < ~/db_nevisidm.sql
```

## Restore a node

If one of the database server nodes needs to be restored, proceed similar to an initial setup:

* Create the database configuration file and start the instance.
* Set the administration password and grant the necessary privileges.
* Skip the step where you create the initial database using the *nevisidmdb* command.
* See the chapter Synchronize the databases on how to export the database from the running node and on how to import it to the re-created server.
--------------------------------------------------------------------------------
Section: ### Virus-protection-using-ClamAV.md
---
sidebar_position: 27
---

# Virus protection using ClamAV

The nevisAppliance includes the Clam antivirus scanning engine which can be used by nevisProxy to detect and block HTTP requests/responses containing a virus.

For virus protection with ClamAV to work on the nevisAppliance, first manually download and then constantly update the virus signature database. See Update the virus signature database for instructions.

<img className="boxed" src={require('../attachments/ClamAV.png').default} alt="Pass HTTP requests/responses to ClamAV"/>

## Configure and start c-icap daemon

nevisProxy forwards HTTP requests/responses via the ICAP protocol to the ClamAV daemon. The c-icap daemon is used to implement this interface.

The following tasks are necessary to start the c-icap server:

1. Copy the configuration template:

 ```
 cp /usr/local/c-icap/etc/c-icap.conf.tmpl \
  /usr/local/c-icap/etc/c-icap.conf
 ```

2. *Optional:* You may now want to adapt the files `/usr/local/c-icap/etc/c-icap.conf` and `/usr/local/c-icap/etc/virus_scan.conf` to your needs. See the [c-icap website](http://c-icap.sourceforge.net/) for further information.

3. Start the c-icap daemon:

 ```
 /etc/init.d/c-icap start
 ```

 From now on, the daemon will automatically start every server reboot.

When using nevisAdmin v3, you can use the "Create" button within the operation view of the c-icap instance. This creates both, the configuration file for the c-icap daemon as well as the cron job entry shown in the chapter Update the virus signature database.

## Configure nevisProxy

nevisProxy uses the ICAPFilter to forward HTTP requests and/or responses to the c-icap server to be validated by ClamAV. Example for request validation (content type application/.*):

```
<filter>
    <filter-name>ICAPUploadFilter</filter-name>
    <filter-class>ch::nevis::isiweb4::filter::icap::ICAPFilter</filter-class>
    <init-param>
        <param-name>ErrorCode</param-name>
        <param-value>403</param-value>
    </init-param>
    <init-param>
        <param-name>BufferRequest</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>RequestBufferSize</param-name>
        <param-value>100000000</param-value>
    </init-param>
    <init-param>
        <param-name>AllowRequestModification</param-name>
        <param-value>false</param-value>
    </init-param>
    <init-param>
        <param-name>ScanRequestHeaderCondition</param-name>
        <param-value>Content-Type:application/.{*}</param-value>
    </init-param>
    <init-param>
        <param-name>SplittMultipartBody</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>ScanRequest</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>InetAddress</param-name>
        <param-value>localhost:1344</param-value>
    </init-param>
    <init-param>
        <param-name>TargetURI</param-name>
        <param-value>
        /srv_clamav?allow204=on&sizelimit=off&mode=simple
        </param-value>
    </init-param>
</filter>
```

See the nevisProxy reference guide for more information about the ICAPFilter options.

## Update the virus signature database

The virus database files (.cvd/.cld) of ClamAV are stored in the `/var/lib/clamav/` directory. You can use the *freshclam* utility to update these database files.

1. Configure the file `/etc/freshclam.conf`. For example, by setting the right *DatabaseMirror* to use or the *HTTPProxyServer* required to connect to the internet. For additional documentation and limitations with the public mirrors, see [the official ClamAV documentation](https://www.clamav.net/documents/configuration#freshclamconf).

 ```script title="/etc/freshclam.conf"
 # ...skipped...
 DNSDatabaseInfo current.cvd.clamav.net
 # ...skipped...
 DatabaseMirror db.XY.clamav.net
 DatabaseMirror database.clamav.net
 ```

 Replace *XY* in *DatabaseMirror* with your country code, for example: *CH*.

2. Run *freshclam* once manually to initially load the definitions. Observe possible errors. It is expected that this call runs successfully without errors.

 ```
 freshclam
 ```

3. Configure a nightly *cronjob* to update the virus database files regularly.

 ```
 echo "0 5 * * * sudo /usr/bin/freshclam \
     --quiet -l /var/log/clamav/freshclam.log 2>/dev/null" \
     >> /var/spool/cron/nvluser
 ```

## Monitoring ClamAV

The *freshclam* utility loads the new database files from the internet (e.g., from current.cvd.clamav.net server) and signals the ClamAV daemon to reload its configuration.

You can poll the ClamAV status using SNMP, see also the chapter Monitoring using SNMP.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceCicapDStatus.1`

 Indicates whether the C-ICAP instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceFreshClamStatus.1`

 Shows whether the virus signature database is up to date (newer than 3 days).
--------------------------------------------------------------------------------
Section: ### Requirements.md
---
sidebar_position: 7
---

# Requirements

## Interfaces

The nevisAppliance supports one or multiple physical network interfaces. The first interface (eth0) must always be connected to the intranet network. The primary IP address of this network interface shall represent the server and is used for administrative access as well as to open connections from the nevisAppliance to the application servers.

A second interface (eth1) can be used to connect to an internet firewall when the nevisAppliance is acting as a nevisProxy instance. Make sure to define a proper routing on the server if you are using more than one interface connected to different layer 3 networks.

## Routing

The routing is usually set as follows:

* A single-homed (only one Ethernet interface is used) nevisAppliance has only the default route to the gateway within the layer 3 network the nevisAppliance is connected to.
* You need to add static routes as well when using a failover cluster. See the nevisAdmin reference guide for more information.
* A dual-homed (two Ethernet interfaces are used) nevisAppliance has a default route to the gateway connected to the internet. Several host and/or network routes are defined for the intranet interface to route traffic to the application server, nevisAuth, nevisAdmin, NTP/SNMP/SNMTP/SYSLOG and other service hosts.

## NTP

The nevisAppliance requires a network time protocol server (NTP server) to synchronize its system clock. The time zone is set to CET by default. Link the file `/etc/localtime` to the appropriate time zone in `/usr/share/zoneinfo` if you have to change it.
--------------------------------------------------------------------------------
Section: ### Subinterfaces
Your server may have multiple IP addresses to support multiple services. For example, one IP address is used by your company website, the other one by the company's web mail application and a third one by the company's online trading platform.

The nevisappliance command can be used to assign the server's main IP address to the Ethernet interface eth0. Additional addresses are either configured automatically by nevisAdmin/nevisAgent if you are using a failover cluster, or manually by creating additional `ifcfg-eth*` files within the `/etc/sysconfig/network-scripts/` directory.

Example of a server with three IP addresses assigned to its first Ethernet interface eth0:

```
# cat /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=static
ONBOOT=yes
HWADDR=00:0C:29:24:BA:BF
IPADDR=172.16.254.133
NETMASK=255.255.255.0
USERCTL=no
NM_CONTROLLED=no

# cat /etc/sysconfig/network-scripts/ifcfg-eth0:0
DEVICE=eth0:0
BOOTPROTO=static
ONBOOT=yes
IPADDR=172.16.254.134
NETMASK=255.255.255.0
USERCTL=no
NM_CONTROLLED=no

# cat /etc/sysconfig/network-scripts/ifcfg-eth0:1
DEVICE=eth0:1
BOOTPROTO=static
ONBOOT=yes
IPADDR=172.16.254.135
NETMASK=255.255.255.0
USERCTL=no
NM_CONTROLLED=no

```
--------------------------------------------------------------------------------
Section: ### Bonding
Multiple Ethernet interfaces can be used in active/standby mode to have a fault-tolerant network connection.

The following steps are necessary to configure two interfaces to share one IP address and to run in an active/standby mode.

* Define a new virtual interface called `bond0` within the `/etc/modprobe.d/bond0.conf` file. Setting `mode` to `1` enables the active/standby mode (you can also use another mode, e.g., `2` for load balancing):

```
alias bond0 bonding
options bond0 miimon=100 mode=1

```

* Create a new interface which specifies the IP address to be used:

```
# cat /etc/sysconfig/network-scripts/ifcfg-bond0
DEVICE=bond0
BOOTPROTO=none
ONBOOT=yes
IPADDR=172.16.254.133
NETMASK=255.255.255.0
USERCTL=no

```

* Configure the two Ethernet interfaces to be slave of this bond interface:

```
# cat /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
USERCTL=no

# cat /etc/sysconfig/network-scripts/ifcfg-eth1
DEVICE=eth1
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
USERCTL=no
```

* Last, activate the new settings:

```
# systemctl restart network.service
```

Example of a running configuration (ifconfig command output):

```
bond0: flags=5187<UP,BROADCAST,RUNNING,MASTER,MULTICAST> mtu 1500
        inet 172.16.254.32 netmask 255.255.255.0 broadcast 172.16.254.255
        inet6 fe80::20c:29ff:fe3c:47ee prefixlen 64 scopeid 0x20<link>
        ether 00:0c:29:3c:47:ee txqueuelen 0 (Ethernet)
        RX packets 82 bytes 6768 (6.6 KiB)
        RX errors 0 dropped 6 overruns 0 frame 0
        TX packets 63 bytes 9058 (8.8 KiB)
        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0

eth0: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST> mtu 1500
        ether 00:0c:29:3c:47:ee txqueuelen 1000 (Ethernet)
        RX packets 705 bytes 69546 (67.9 KiB)
        RX errors 0 dropped 0 overruns 0 frame 0
        TX packets 501 bytes 140174 (136.8 KiB)
        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0

eth1: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST> mtu 1500
        inet6 fe80::20c:29ff:fe3c:47ee prefixlen 64 scopeid 0x20<link>
        ether 00:0c:29:3c:47:ee txqueuelen 1000 (Ethernet)
        RX packets 6 bytes 360 (360.0 B)
        RX errors 0 dropped 6 overruns 0 frame 0
        TX packets 8 bytes 648 (648.0 B)
        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0
```
--------------------------------------------------------------------------------
Section: ### Architecture-overview.md
---
sidebar_position: 4
---

# Architecture overview

This chapter provides a high-level, feature-oriented view of the nevisMeta component and provides information about the context in which nevisMeta is used.

## Features

nevisMeta is designed to facilitate the setup of federation protocols within the Nevis framework. It offers the following features:

* A central management point of metadata for setups of particular protocols. Each protocol is handled by a dedicated module.
* All necessary information for participants of setups to fulfill roles as defined by the particular protocol. This information is provided in the form of JSON documents that can be retrieved via REST services. The documents enable participants to configure themselves dynamically according to the description of the setup.
* A REST interface that allows retrieving, creating, modifying and deleting setups and entities. The rest interface will return data at the time of the call or, if a date is provided, at a specific point in time (see the chapter REST API V2).
* All modifications are dated: Any changes may be defined to take effect immediately or at any point in the future. Consumers of the nevisMeta REST service (typically participants in those same managed setups) receive instructions on how long to maximally cache the data they received. This enables coordinated changes of setup configuration between all interested participants without the need for explicit coordination communication or deployment windows (see the chapter Entities and states).

## Web console

 The nevisMeta web console offers an easy-to-use administration interface for the module setups that are managed in nevisMeta (see the chapter "Main screen"). It offers the following functionalities:

* creating new setups
* adding new entities with module-specific types to a setup
* editing general properties of the setup that affect all participants
* editing and deleting entities
* specifying the validity date for each modification

These functionalities are protected from unauthorized access.

For an overview of all supported web browsers, see the chapter "Browser Support Policy in Nevis" in the Nevis Product Lifetime and Platform Support Matrix Guide.

## REST API

The REST API provides a well-defined interface for exchanging information with participants of a setup and with other services. Because it is feature-complete, it can also be used to implement a custom, specialized front-end for managing nevisMeta functionality (e.g., custom configuration point). A detailed description of the REST API can be found in the chapter REST API V2.

## Persistence

 nevisMeta offers persistence based on MariaDB and PostgreSQL.

* MariaDB is an SQL-based relational database. The setup of MariaDB is described in "MariaDB setup".
* PostgreSQL is an SQL-based relational database. The setup of PostgreSQL is described in "PostgreSQL setup".

## Supported protocols

 Currently, nevisMeta implements a module for OAuth 2.0. It supports the following protocols:

* OAuth 2.0 [2]
* OpenID Connect Core [3]

## Deployment architecture

The following illustration shows nevisMeta in an abstract architecture:

* Admin users have access directly to the nevisMeta web GUI, where they can edit data of setups and entities.
* Custom Configuration Points may provide a tailored user interface, which allows a Protocol Specialist to interact with nevisMeta using the REST interface (note that such a service is not provided by nevisMeta but must be implemented separately).
* Participant Services consume metadata from nevisMeta to configure themselves dynamically.
* End-users interact with the Participant Services only (i.e., not directly with nevisMeta).

<img className="boxed" src={require('../attachments/7823282/65964896.png').default} alt="nevisMeta abstract architecture"/>

 In the illustrated setup two nevisMeta instances are employed for high availability (failover) but the backup connections for the *Participant Services* and the *Custom Configuration Point* are omitted for clarity. The nevisMeta instances are backed by a database cluster of two nodes.
--------------------------------------------------------------------------------
Section: ### Configuring outage resilience on MariaDB
This chapter is about resilience towards outages of database nodes, which differs from resilience towards failures of nevisMeta instances. To achieve resilience towards failures of nevisMeta instances, two nevisMeta instance addresses must be configured in nevisProxy. Such a configuration enables failover to the second nevisMeta instance if nevisProxy cannot connect to the first nevisMeta instance. For more information, see the nevisProxy reference guide (*InetAddress* parameter of the *HttpConnectorServlet)*.
--------------------------------------------------------------------------------
Section: ### `nevismeta config`
The command *nevismeta* *config* opens the main configuration file *nevismeta.properties* for editing in a console editor.

| Parameter name                                | Default | Description                                                                                                                                                                                                                                                                          |
|-----------------------------------------------|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| fileimportsize                                | 5242880 | Maximum size of importable files in bytes. For example, "5242880" means 5 MB.                                                                                                                                                                                                        |
| maxCacheDuration                              | 600     | Maximum cache duration for REST interface responses in seconds.For example, "600" means 10 min.                                                                                                                                                                                      |
| module.oauthv2.import.regenerate.clientsecret | false   | Regenerates client secrets when importing OAuthV2 client entities. <code>{true &vert; false}</code>                                                                                                                                                                                  |
| expiredDataCleaningInterval                   | 3600    | Interval after which expired data will be cleaned, in seconds. For example, "3600" means 60 minutes or one hour.                                                                                                                                                                     |
| expiredDataCleaningTolerance                  | 120     | Minimum time needed to delete data after expiration, in seconds. For example, "120" means 2 minuses. In majority of cases this value should not be changed. If this value is set too high, it could lead to performance issues.                                                      |
| responseCacheExpiry                           |         | Specifies the expiry time in milliseconds for the GET entities endpoint response cache. If left unset, caching will not be used. If set, the value should be less than nevisAuth's <code>nevismeta.maxAge</code>. Setting it too high can cause usage of outdated data in nevisAuth. |
| server.auth.ninja.truststore                  |         | Specifies the truststore file to use for Ninja to parse the SecToken.                                                                                                                                                                                                                |
| server.auth.ninja.user-getter                 |         | Defines how Ninja gets the user ID from the SecToken.                                                                                                                                                                                                                                |
| server.auth.ninja.role-getters                |         | Defines how Ninja gets user role from the SecToken.                                                                                                                                                                                                                                  |
| server.auth.ninja.sec-role-mapping            |         | Maps SecToken roles to groups or to role principals. Syntax: <code>group &vert; role</code> Recommended setting: "group". See also chapter Configuration of the Web Application in the Ninja reference guide.                                                                        |

In the majority of cases 

For more details, see chapter User ID and Roles in the Ninja reference guide.
--------------------------------------------------------------------------------
Section: ### concept-description.md
---
sidebar_position: 3
---

# Concept Description

This chapter describes the main concepts on which nevisAuth is based.

## What is it about

<img className="boxed" src={require('./assets/nevisauth-concept.drawio.png').default} alt="nevisAuth overview"/>

nevisAuth implements strong user and system authentication for the Nevis identity and access management solution. The product complements nevisProxy, Nevis' entry gateway and web application firewall. Where nevisProxy filters the *content* of user requests to protect your company's online applications against internal and external threats, nevisAuth focuses on the user's *identity*. Its task is to verify whether the user is who he claims to be, to prevent unauthorized users from accessing your applications.

In this context, identification, authentication and authorization play a central role. *Identification* means claiming that you are user X, e.g., by entering your username "userX". *Authentication* is how the system proves if you really are user X. For this, the system can use up to three authentication factors, either separately or combined: something you know (e.g., password or PIN), something you own (e.g., grid card or a third-party token) and something you are (refers to biometrics, e.g., your fingerprint or your typing habits). *Authorization* takes place after the system has successfully identified and authenticated you as really being user X. It is the step that determines what you are allowed to do in the application, your roles and permissions.

nevisAuth covers the whole process of identification, authentication and authorization. If the authentication was successful, nevisAuth copies all relevant security data on a signed security token, the SecToken. This token is the user's *Proof of Authentication* towards nevisProxy and the business applications in the back end.

To be able to perform its tasks, nevisAuth works closely together with nevisProxy. For the verification of the user credentials and retrieval of user roles and permissions, the ideal partner of nevisAuth is nevisIDM, Nevis' product for identity management. However, nevisAuth can also cooperate with LDAP-based directory servers or other authentication services. Also, a request to authenticate a user must not necessarily enter nevisAuth via nevisProxy. nevisAuth provides several other interfaces (APIs), such as the WS-Trust API, to integrate VPN gateways or specific Microsoft services.

Additionally, nevisAuth supports other token formats besides Nevis' proprietary SecToken, such as the SAML assertion, the X.509 user certificate or the JWT claim (OpenID Connect). Thus, nevisAuth enables identity federations with external networks or security domains.

## Main features

* Modular and customizable setup
* Support of a wide range of authentication methods, such as user name/password authentication, X.509 client certificates, security questions, challenge/response procedures, one-time passwords
* Integration of identity federation protocols, such as SAML2, WS-Federation and OpenID Connect
* Support of various token formats, e.g., SAML assertion, the X.509 user certificate or the JWT claim (OpenID Connect)
* Availability of flexible interfaces, e.g. the WS-Trust facade, to easily integrate external systems
* Possibility to create realms/domains to enable single sign-on
* Dynamic adjustment/upgrade of authentication strength to improve security
* Facility to include user roles and permissions to establish a detailed and fine-grained authentication system

## Authentication process including GUI generation

<img className="boxed" src={require('./assets/authentication-process-gui-generation.drawio.png').default} alt="nevisAuth authentication process"/>

The core task of nevisAuth is user identification and authentication. Its goal is that no unauthorized user will access your web applications. In this context, the burden of proof lies with the user. That is, the user must provide information to prove that he is who he claims to be.

This is how it works. A user wants to access a web application protected by Nevis (1) in the preceding figure.
--------------------------------------------------------------------------------
Section: ### SAML assertion
The SAML (2.0) assertion is very similar to the Nevis SecToken*,* but with the following differences:

* It is a standard, defined by [www.oasis-open.org](http://www.oasis-open.org) and supported by major vendors (e.g., Oracle WLS 10.3, IBM WAS 6.1).
* It additionally allows encryption and uses corresponding standards (XML signature and XML encryption, as defined by [www.w3c.org](http://www.w3c.org)).
* It can be federated to a different domain if used in conjunction with the SAML 2.0 protocol.
* XML overhead is huge compared to the Nevis SecToken. The SAML assertion is therefore not suitable for per-request propagation. Instead, use SAML for non-interactive SSO session transfer.

The SAML assertion is appropriate in a federated architecture, where Nevis works together with external third-party services. Together with these external services, Nevis builds an *identity federation*. These are some possible use cases:

* nevisAuth issues a SAML 2.0 assertion as an *identity provider (IdP)*, to allow secure hand-over of the user's identity to an external trusted party.
* As a consumer or service provider (SP), nevisAuth accepts a SAML assertion issued by an external trusted party as the user's proof of authentication. nevisAuth uses the assertion to establish an authentication session in the local environment and to allow the user access to applications in the back end.

:::info

For further details about SAML tokens and plug-in, see [SAML AuthStates](setup-and-configuration/authentication-plugins-and-authstates/saml-authstates/saml-authstates.md).
:::

## Session management

Upon the start of the authentication nevisAuth creates a session. This is an *initial session* as long as nevisAuth did not yet finish the user authentication. Whenever a user is successfully authenticated, nevisAuth upgrades the initial session to an *authenticated session*. It also issues the SecToken. If the authentication failed, the initial session is discarded.

The session data is stored in a session cache, together with the data on the SecToken (or another proof of authentication). To track the authenticated user, Nevis sends a cookie to the client browser, which the browser must submit on any subsequent request. By means of the cookie as well as all information on the SecToken and in the session cache, the session management facilities of nevisAuth and nevisProxy can detect inactivity of the user and trigger a re-authentication. It is possible to terminate the session as well, e.g., if the SecToken is expired.

## Single sign-on

nevisAuth also facilitates *single sign-on (SSO)*. Single sign-on means that the user has to log in only once to be able to access multiple web applications in the back end.

To set up single sign-on within Nevis, you have to group your applications into something we call an SSO *realm*. The authentication happens per SSO realm. If a user is granted access to one application in a realm, he has access to all applications within this realm.

This concept not only allows the user to have to authenticate just once. It also supports upgrading of the authentication strength, such that the authentication method used for the realm is stronger than the in

Nevis recognizes the applications belonging to a realm by their URLs (internet addresses). See the following figure; The SSO realm "Extranet" consists of the applications "app1", "app2" and "app3". To access application "app1", a user will enter the URL `https://extranet.ch/app1` in his browser (to access application "app2", the user must enter `https://extranet.ch/app2`, and so on).

<img className="boxed" src={require('./assets/nevisauth-sso.drawio.png').default} alt="nevisAuth single sign on"/>

To authenticate the user, nevisAuth only needs the user's password for the realm Extranet. Upon successful authentication, the user has access to all three applications app1, app2 and app3. But because of the application path ".../app1" in the URL, Nevis knows that the user wants to use application app1. Thus, nevisProxy is able to forward the user's request to the right application within the realm.

## APIs

To access the authentication service of nevisAuth, Nevis offers various secure interfaces or *APIs*.

Most requests to authenticate a user enter nevisAuth via nevisProxy and the Nevis Authentication Interface, which is a SOAP service (see the following figure. SOAP stands for *Simple Object Access Protocol* and is a network protocol to exchange data.

<img className="boxed" src={require('./assets/nevisauth-apis.drawio.png').default} alt="nevisAuth APIs"/>

But there are several other possibilities to access nevisAuth directly. For example, Microsoft clients using the WS-Trust protocol may access nevisAuth through the WS-Trust facade.

## Architecture – how does it work?

nevisAuth's core responsibility is to process authentication requests. Basically, nevisAuth consists of a broad range of plug-ins, the *AuthStates*. The AuthStates are the building blocks of the authentication process and can be combined in all kinds of variations and sequences. This allows you to implement exactly the kind of authentication you need to protect your applications in an optimal way: as strong as required and as user-friendly as possible.

During the authentication process, the user's login data passes different AuthStates. Each AuthState has one particular responsibility, e.g., to authenticate a user against a certain authentication back end, to manipulate a request, to store information, etc. The AuthState also forwards the data to the next step in the authentication process.

Basically, each AuthState receives input, processes it and produces output (which is the input for the next AuthState). This goes on and on, until the last AuthState within the authentication process is reached.

A specific combination of AuthStates with an entry AuthState, a last AuthState and several AuthStates in between, builds a *domain* (see the following figure. A domain may perform the authentication process for just one application in the back end, or for several applications at once. The latter case facilitates single sign-on. Here, the domain resembles the SSO realm.

<img className="boxed" src={require('./assets/nevisauth-architecture.drawio.png').default} alt="nevisAuth architecture"/>

An authentication process starts as soon as an authentication request enters nevisAuth via nevisProxy, or via one of the other interfaces/APIs. The Authentication Engine, or *AuthEngine*, is responsible for dispatching the request to the first AuthState, as well as transitioning the request from one AuthState to the next. The AuthEngine also identifies whether an AuthState requires more information from the user.

Eventually, the AuthEngine constructs a response for nevisProxy. There are three types of responses:

* `AUTH_CONTINUE`

  The AuthEngine requires more input from the user to continue processing. This results in the generation of a new GUI descriptor and page, which is sent to the user.
* `AUTH_DONE`

  The AuthEngine could finish the authentication successfully. This results in the issuing of a SecToken.
* `AUTH_ERROR`

  The AuthEngine detects an error. No user input can circumvent this error. nevisAuth stops the authentication process. This results in an error message.
--------------------------------------------------------------------------------
Section: ### auditing.md
---
sidebar_position: 115
---

# Auditing

This chapter deals with the auditing of authentication-related events.

## Audit events

Audit events are generated under the following circumstances:

| Event          | Generated by       | Condition                                                                                                                                                                                                                                                    |
|----------------|--------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *authenticate* | AuthEngine         | When during an authentication the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.                                                                                                |
| *stepup*       | AuthEngine         | When during a step-up the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.                                                                                                        |
| *stepdown*     | AuthEngine         | When during a step-down the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.                                                                                                      |
| *unlock*       | AuthEngine         | When during an unlock the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.                                                                                                        |
| *logout*       | AuthEngine         | When during an explicit logout of the user the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.This event can also be triggered by an AuthState in case a session is invalidated. |
| *timeout*      | SessionCache       | The session has been removed from the local session store. If no other session termination event is present, the local reaper finally removed the session.                                                                                                   |
| *terminate*    | SessionCoordinator | The session is going to be killed locally.                                                                                                                                                                                                                   |
| *custom*       | AuthState          | A plug-in generates its own audit events. Check the section "Audit" in the AuthState documentation chapter.                                                                                                                                                  |

## Audit data

The AuthEngine is called by an access proxy or caller and receives various information about the proxy, the user-agent (e.g., browser) in addition to the user's authentication data. After authentication, data from the AuthState plug-ins is also available. The following table lists the possible audit entry data. All this data may be consumed by an audit channel:

| Field                                  | Provided by                                          | Content                                                                                                                                                                                                                                                                                                                      |
|----------------------------------------|------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *Timestamp*                            | System                                               | Audit events are immediately delivered to the audit channel. The timestamp of the event therefore needs to be extracted from the system clock by the audit-channel.                                                                                                                                                          |
| *Event*                                | AuthEngine, SessionCoordinator or AuthState plug-ins | See the column "Generated by" in the table Audit events.                                                                                                                                                                                                                                                                     |
| *Severity*                             |                                                      | *NOTICE*: A successful uncritical event.<br/>*ALERT*: a critical event that requires administrator attention.<br/>*ERROR*: A failed, possibly critical event.                                                                                                                                                                |
| *Detail*                               |                                                      | Additional information describing the event.                                                                                                                                                                                                                                                                                 |
| *SecRoles*                             | AuthState                                            | The user's current security role(s) displayed as a comma-separated list of role identifiers.                                                                                                                                                                                                                                 |
| *AuthLevel*                            | AuthState or configuration                           | The user's authentication level, e.g., "auth.weak".                                                                                                                                                                                                                                                                          |
| *ClientIP*                             | caller (access proxy)                                | Usually the (unverified) user's workstation IP address as passed by the access proxy. If the proxy is installed behind non-transparent network infrastructure (load balancers, firewalls), which replace the source address in the TCP packages, this field is not really useful, as it always contains the same IP address. |
| *ClId*                                 | caller (access proxy)                                | The network channel ID, as generated by the access proxy. This field is used to correlate messages that are sent over the same channel.                                                                                                                                                                                      |
| *ClientSec*                            | caller (access proxy)                                | The security attributes of the network channel (e.g., used SSL protocol and cipher).                                                                                                                                                                                                                                         |
| *ClientType*                           | user-agent                                           | The user-agent (HTTP header), as forwarded by the access proxy.                                                                                                                                                                                                                                                              |
| *Domain*                               | caller (access proxy)                                | The authentication realm, which the access proxy wants to use to authenticate its clients.                                                                                                                                                                                                                                   |
| *DomainMap*                            | AuthState                                            | A list of identity mappings for back end applications.                                                                                                                                                                                                                                                                       |
| *EntryId*                              | caller (access proxy)                                | A unique identifier that allows to distinguish between different access zones or access proxy instances.                                                                                                                                                                                                                     |
| *AuthId*                               | nevisAuth(configuration)                             | A unique identifier that allows to distinguish between different authentication zones or nevisAuth instances.                                                                                                                                                                                                                |
| *LoginId*                              | user                                                 | The user name, visible to and known by the accessing user.                                                                                                                                                                                                                                                                   |
| *Url*                                  | caller (access proxy)                                | The resource, which the user wants to use, and which triggered the authentication.                                                                                                                                                                                                                                           |
| *SessId*                               | nevisAuth(SessionCache)                              | The authentication session, as generated by nevisAuth.                                                                                                                                                                                                                                                                       |
| *ConversationId*                       | AuthEngine                                           | The identifier of the conversation. All requests/response contexts share this identifier until `AUTH_DONE`.                                                                                                                                                                                                                  |
| *Principal*                            | AuthState                                            | The (global) authenticated user principal.                                                                                                                                                                                                                                                                                   |
| *TraceId* (only in SOAP deployment) | caller(access proxy)                                 | Unique transfer ID supplied by nevisProxy or other clients. This ID links the audited operation to the issuing request at the client.                                                                                                                                                                                        |
| List of Authentication Markers         | AuthEngine/ AuthState                                | An Authentication Marker or *auth marker* represents a successfully completed operation that is relevant for the authentication and authorization process. Each auth marker belongs to an AuthState.An *auth marker* has the following form:*`<technology>`:`<type>`".                                                       |

## Audit channels

Audit channels are output-handlers for audit events. They have the following characteristics:

* They define, what (available) data to use and how to format it.
* They implement, where to output the data (file, MQ, ...).

Currently, the nevisAuth standard distribution includes the `NevisAuditChannel`.

:::info

It is also possible to implement a custom `AuditChannel` interface. For a description of the `AuditChannel` interface, see [AuditChannel interface](#auditchannel-interface)
:::

## NevisAuditChannel

This channel outputs all fields, listed in chapter ["Audit data"](#audit-data) and writes them (via log4j) to a file. The file can be rotated based on a size or time-policy. The output is formatted as follows (single line format, newlines added for better readability):

```
2015-04-24 09:08:24,683 INFO
  Domain="SSO"
  LoginId="xxx"
  Principal="xxx"
  Event="authenticate"
  Detail=""
  AuthLevel="auth.weak"
  SecRoles="auth.weak,webmail"
  DomainMap=""
  ClientIP="10.22.214.122"
  ClientSec="TLSv1.2;DHE-RSA-AES256-SHA"
  ClientType="Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36"
  EntryId="extranet.siven.ch"
  ClId="59a4000aacccNFBkB7OwKRjuD5SpPsL/UccBmRn4TM9f+ySOc0F+Zpw="
  Url="https://extranet.siven.ch/jira/secure/MyJiraHome.jspa"
  AuthId="I1"
  SessId="0L1c-sHdIRRcNKG410z0b1DsqZFX6KLmNhhBx4g-YKw"
  TraceId="1d7bf899ab6ca912dd27fdf777bd90a6"
  ConversationId="805056107136"
Trail: SSOLdapLogin{2015-04-24 09:08:24; LDAP:username/password(uid=xxx,ou=people,o=siven,c=ch)}
```

The keys in the log entry names can be mapped as follows to the field entries in section [Audit data](#audit-data):

| Keys in NevisAuditChannel | Available audit data                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|---------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Event                     | Event                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Detail                    | Detail                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| SecRoles                  | ActualRoles                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| AuthLevel                 | AuthLevel                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ClientIP                  | ClientAddress                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ClId                      | ClientId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ClientSec                 | ClientSecurityInfo                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ClientType                | ClientType                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Domain                    | Domain                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| DomainMap                 | DomainMappings                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| EntryId                   | EntryId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| AuthId                    | EsAuthId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| LoginId                   | LoginId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Url                       | Resource                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| SessId                    | SessionId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Principal                 | UserId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| TraceId                | TraceId (only in SOAP deployment)                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Trail                     | (list of) Authentication Markers.<br/>A *Trail* entry consists of a sequence of Authentication Markers or *auth markers*. Together, these auth markers show the route of the user through various AuthStates during a specific authentication and/or authorization event. A trail can contain just one auth marker or several auth markers. A *Trail* entry has the following form: Trail: `<AuthState1>{<date and time>; <auth marker1>}-><AuthState2>{<date and time>; <auth marker2>}->…` |

```text title="Trail examples"
Trail: SSOLdapLogin{2015-04-24 09:08:24; LDAP:username/password(uid=xxx,ou=people,o=siven,c=ch)}
Trail: SSOIdmUserIdPasswordLogin{2015-10-20 09:31:47; nevisIDM:username/password(pbu)}-->SSOIdmPostProcessing{2015-10-20 09:31:47; nevisIDM:selection(profile: Profile-pbu/1000)}
```

## AuditChannel interface

The *AuditChannel* interface contains two methods:

| AuditChannel Methods                                                 | Description                                                                                                                                                               |
|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *init(Properties cfg)*                                               | This method is called by the AuthEngine upon initialization of the *AuditChannels*. Properties configured in the nevisAuth configuration are handed to the *init* method. |
| *audit(String event, String detail, AuditEntry entry, int severity)* | This method is called to deliver audit events. The channel should format and deliver the events according to the audit event destination.                                 |

Each *AuditChannel* is initialized upon nevisAuth start. The configuration properties from the *esauth4.xml* file are handed to the *init(…)* method. The *audit(…)* method is called whenever an audit event is handled.

To write the audit log into a custom storage, implement the *AuditChannel* interface. Configure the *classpath* for the custom *AuditChannel* implementation in the *AuthEngine* *classpath* configuration (see [Plugging authentication infrastructures](../use-cases-and-best-practices/use-cases/plugging-authentication-infrastructures.md)). In common cases, the *classpaths* are put into the */var/opt/nevisauth/`<inst>`/plugin* directory.
--------------------------------------------------------------------------------
Section: ### Kerberos Login Integration
The following steps are needed to integrate a backend service into a Kerberos realm:

1. Register a Service Principal Name (SPN) at the Key Distribution Center (KDC) of the Kerberos realm. Use the following SPN format: `HTTP/<hostname>[:port]` where:
  * `<hostname>` is the fully-qualified virtual host name of the access proxy 
  * `[:port]` is an optional port number
2. Generate a keytab file containing the long-term Kerberos key belonging to the SPN and make it accessible to nevisAuth. This is the point where the used encryption types could be defined, see also [supported encryption types](#supported-encryption-types).
3. Configure the *KerberosLoginAuthState* to use the keytab file as a kerberos credential, for further details please consult [KerberosLoginAuthState](../../setup-and-configuration/authentication-plugins-and-authstates/kerberos-authentication-authstates.md#kerberosloginauthstate)

For further details regarding how to register an SPN at the KDC or how to generate a keytab file with specific encryption types please consult the documentation of the used Kerberos KDC.
--------------------------------------------------------------------------------
Section: ### Step 1: Registering the proxy host in AD
Use the active directory administration to register a new (functional) user, representing the proxy virtual host. Proceed as follows:

1. When registering the new user, enter a user login name. For example, "HTTP/`<proxy-host-name>`", where `<proxy-host-name>` is the hostname used by the clients.
2. Set a password (to be used for the key export later).
3. In the *Account* tab of the user's *Properties* window (see the figure below, go to the *Account options* section and make the following required settings:

* Deactivate *User must change password at next logon*.
* Activate *Password never expires*.
* Select *This account supports Kerberos AES 128 bit* or *This account supports Kerberos AES 256 bit* (see also [Encryption types](#encryption-types)).

4. If you want to use pass-through authentication, go to the *Delegation* tab of the *Properties* window.

* Either activate the option *Trust this user for delegation to any service (Kerberos only)*, or
* List the applications, which Nevis should be allowed to delegate to, under *Trust this user for delegation to specified service only*.

<img className="boxed" src={require('../../assets/properties-window-example-user-configuration.png').default} alt="Properties window - Example user configuration"/>
--------------------------------------------------------------------------------
Section: ### session-cache-scaling.md
---
sidebar_position: 133
---

# Session cache scaling

The session cache inside nevisAuth is configured to have an upper limit to enforce a maximum of parallel user sessions at a time. As session termination notifications may be lost due to network problems, the session cache should be sized to approximately twice the size of the maximum number of parallel user sessions.

1. To configure the session cache, execute the following command:

  ```bash
  nevisauth config
  ```

2. The following parameters are relevant for session cache configuration. Adapt them according to your needs:

  ```xml
  <SessionCache name="SessionCache" size="100000" initialInactivityTimeout="300" inactivityTimeout="43200" maxLifetime="43200">
  ```

The configuration in the previous code snippet provides 100'000 sessions with an initial timeout of 300 seconds. This means that multi-step authentication has to be completed within 5 minutes (the multi-step authentication creates the global authentication session after the first successful step). If the user is too slow in completing the next step, he is forced to start over.

After the authentication is completed, the session lifetime is raised to 12 hours. This time-out enforces a maximum possible session lifetime. Note that idle and screen saver time-outs are enforced by the nevisProxy.

When nevisAuth failure safety is enabled, the number of parallel sessions remains the same, but the initial cache synchronization may need to be disabled as each established session triggers a call to the fallback instance (`syncPullInitial="false"`).
--------------------------------------------------------------------------------
Section: ### failure-safety-and-load-balancing.md
---
sidebar_position: 9
---

# Failure Safety and Load Balancing

This section shows how nevisAuth implements failure safety and load-balancing. It also briefly discusses the global session store.

## Failure safety

nevisAuth manages a global session. As a consequence, the server is stateful and failure safety support requires that the corresponding session cache is synchronized, so that failover-aware clients are able to access it at a different physical location.

The failure safety pattern in nevisAuth is based on a vertical line concept with horizontally paired failure safety. The figure below shows this pattern:

<img className="boxed" src={require('../assets/nevisauth-failure-safety-pattern.drawio.png').default} alt="Failure safety pattern in nevisAuth"/>

The design in the shown pattern has the following advantages:

* The cost of failure safety does not increase dramatically with the number of nevisAuth server instances (synchronization overhead multiplies if the number of synchronized nodes is larger than 2).
* Configuration remains maintainable.

The restrictions include:

* Session stickiness between clients and nevisAuth

  For optimal performance and to prevent session loss, an established session context (e.g., the user is authenticated and the corresponding channel is associated with a client, i.e., a reverse proxy instance) should be handled over the same communication channel. In case of a failure, the client failover (e.g., the reverse proxy) should address the nevisAuth instance that holds the backup of the session state (slave instance). Failover to another nevisAuth instance will result in an error (unknown session exception).

* Session stickiness between clients and reverse proxy:

  Session loss arises when the load balancer in front of the reverse proxy does not route the user's established channel to the same reverse proxy (e.g., based on the SSL session ID, cookies or source IP address).

## Load balancing

nevisAuth gets about two to ten hits per user session, for example for a login, a step-up, and a logout. In other words, failure safety is a big issue (as nobody is able to work when login is not possible), while load balancing is far less important. When considering the session synchronization above, a client may distribute calls to the two nevisAuth instances. If every (distributed) client does this, session synchronization delays may lead to sessions that have been modified on both instances. In this case, synchronization fails as sessions are protected (using an optimistic locking scheme). This problem is solved by synchronous synchronization (setting the synchronization delay to 0 seconds), but this increases the overhead and callers are forced to wait a little longer.

## Global Session Store

To be able to synchronize sessions between nevisAuth instances, nevisAuth must store sessions in a JDBC database. This allows session sharing within nevisAuth clusters of arbitrary sizes. See [Session management](../setup-and-configuration/components/session-management.md) for details on how to configure the JDBC global session store.
--------------------------------------------------------------------------------
Section: ### session-termination-polling-and-actor-identification.md
---
sidebar_position: 8
---

# Session Termination Polling and Actor Identification

Upon receiving an `AUTH_DONE` response state together with a *SecToken*, nevisProxy identifies the user session as an authenticated session. Further requests may only cross nevisProxy. Therefore, nevisProxy holds the master session. This means, if a logout is detected, either instructed by the user or a back-end application. nevisProxy is then responsible for sending a logout or kill request to nevisAuth.

However, it is also possible that nevisAuth decides to terminate the session. This might happen, for example, if the nevisAuth session reaper detects a timed-out session. In this case, the session coordination between nevisProxy and nevisAuth can be achieved using the `poll_terminated_sessions` method.

An external server (usually nevisProxy) can use this method to collect notifications of terminated sessions. The method handler will postpone sending a response until at least a minimal duration has passed (since this notification mechanism is understood to be near-real-time only) and, if no sessions have been terminated since the last call, it will wait up to a maximal duration for the termination of new events. Both minimal and maximal durations can be specified with the request.

To keep track of termination notifications and administer which notifications have been consumed by which actor, each external server must be identified with a unique `actorId`. This is done via the HTTP header `actorId` (in SOAP deployment) or, as a fallback, via the `SubjectDN` in the transport layer client certificate used by the actor.
--------------------------------------------------------------------------------
Section: ### Connectivity
* `service.maintainSession` (boolean, "false")

  Whether to maintain the HTTP session from one request to another in a bound service client.

* `service.poolingMode` ({load balancing,failover}, "failover")

  This property sets the handling of multiple connection URLs. Load balancing is sticky in for a bound service client.

* `service.binding` ({thread, none}, "thread")

  Whether and how to bind a service client. None will create the client for every request. The thread option will store the client in the ThreadLocal therefore it can be reused for subsequent outgoing requests in the same nevisAuth request processing.

* `service.discardInterval` (time in seconds, "10")

  Time in seconds to disregard URLs when communication resulted in a non-application error (that is, an error that indicated a system problem at the service).

* `ervice.retryDiscardedResources` (boolean, "false")

  If all services are marked as discarded, then this property defines whether to nevertheless retry a service. If activated, this forms an "emergency mode" where services are accessed despite the discard interval. The next service to be retried will be selected according to the configured pooling mode.

* `service.retries` (number, defaults to number of connection URLs)

  Number of retries to attempt when experiencing connectivity errors before assuming all services are unavailable.

* `service.httpclient.tls.trustStoreRef`
* `service.httpclient.tls.keyObjectRef`
* `service.httpclient.tls.hostnameVerification`
* `service.httpclient.proxy.host`
* `service.httpclient.proxy.port`

  :::info

  HttpClient properties work the same as described [here](/nevisauth/setup-and-configuration/components/http-client#httpclient-configuration), however this AuthState uses a JAX-WS soap client. So only the configuration options specified above are applicable.

  :::
--------------------------------------------------------------------------------
Section: ### Properties
* `servicePrincipal` (string or "auto", -)

  The Service Principal Name (SPN) reflects the fully-qualified virtual host name of the access proxy (i.e., the host name in the URL, accessed by the browser client). It has the format `HTTP/<hostname>@<REALM>`.

  The Kerberos realm (i.e., the Active Directory domain) needs to be configured in UPPERCASE. It is mandatory to specify the realm.

  If the special value "auto" is configured, the AuthState will extract the SPN from incoming SPNEGO/Kerberos tokens and will look for a related Kerberos credential. Use this feature in scenarios where nevisAuth has to impersonate many SPNs and configuring many AuthStates is not acceptable, or where deciding on the ServicePrincipal to impersonate for a particular request is difficult.

* `kerberosCredentials` (path, "conf/kerberos-credentials.properties")

  Path to a properties file containing service principal name and keytab file path pairs. A keytab file stores the long-term Kerberos key of one or more principals. If `servicePrincipal` defines a specific service principal name then a related entry with the defined SPN has to be present. If `servicePrincipal` is configured to "auto" then after extracting the SPN from incoming SPNEGO/Kerberos token the AuthState will look for a suitable keytab file using this property file.

    <details>
    <summary>Example <b>kerberos-credentials.properties</b> file content:</summary>
    <div>
      HTTP/service1.hostname@REALM=conf/kerberos.keytab
      <br/>
      HTTP/service2.hostname@REALM=conf/kerberos.keytab
      <br/>
      HTTP/service3.other-hostname@OTHER.REALM=conf/other.keytab
    </div>
  </details>

* `permittedRealms` (whitespace-separated list of realms or `*`, defaults to realm of service principal)

  A whitelist of trusted realms, only users from listed realms are allowed. In a multi-realm setup with cross-realm trust this parameter could be used to limit and exclude some realms from the auth flow which are otherwise trusted by the Key Distribution Center (KDC).

  The default behavior allows users only from the realm of the configured service principal. If `servicePrincipal` is configured to "auto" then default can not be used. Using an asterisk completely disables this check and allows authentication of users irrespective of their realm.

  The `permittedRealms` property supports variable expressions.

* `userIdFormat` (string {full | unqualified}, "full")

  The format of the user ID set upon successful authentication.

  <details>
    <summary>Example assuming a Kerberos user: <b>username@REALM</b></summary>
      <table>
        <tr>
          <th>UserIdFormat</th>
          <th>UserId</th>
          <th>LoginId</th>
        </tr>
        <tr>
          <td>full</td>
          <td>username@REALM</td>
          <td>username@REALM</td>
        </tr>
        <tr>
          <td>unqualified</td>
          <td>username</td>
          <td>username@REALM</td>
        </tr>
      </table>
  </details>

  The `userIdFormat` property supports variable expressions.

* `limitSessionLifetime` (boolean, "false")

  If configured to "true" then the lifetime of the underlying Kerberos service ticket used by the client during the SPNEGO negotiation will be considered when determining the lifetime of Nevis session. In this case the expiration time of Nevis session can not be longer than the expiration time of the Kerberos service ticket.
--------------------------------------------------------------------------------
Section: ### Properties
* `ServicePrincipal` (string or "auto", -)

  The principal name reflects the fully qualified virtual host name of the access proxy (i.e., the host name in the URL, accessed by the browser client). It has the format `HTTP/<hostname>@<REALM>`.

  The Kerberos realm (i.e., the Active Directory domain) needs to be configured in UPPERCASE. It is mandatory to specify the realm.

  If the special value "auto" is configured, the AuthState will extract the SPN from incoming Kerberos tokens and will look for a suitable credential. Use this feature in scenarios where nevisAuth has to impersonate many SPNs and configuring many AuthStates is not acceptable, or where deciding on the ServicePrincipal to impersonate for a particular request is difficult.

* `UserIdFormat` (string {full,unqualified}, "full")

  The format of the user ID set upon successful authentication.

  ```text title="Example"
  //Assuming a Kerberos user username@REALM:

  full: UserId="username@REALM", LoginId="username@REALM"
  unqualified: UserId="username", LoginId="username@REALM"
  ```

* `PermittedRealms` (whitespace-separated list of realms or "*", defaults to realm of principal)

  Only users from realms listed are allowed. The default allows only users from the realm of the principal (HTTP/hostname@REALM).
  An asterisk disables this check and allows authentication of users irrespective of their realm.

* `BackendServices` (whitespace-separated list of service principals, -)

  Each service principal must be of the format `HTTP/<hostname-of-backend>@<REALM-OF-BACKEND>`.
--------------------------------------------------------------------------------
Section: ### Properties
* `connection.N` (string, required)

  One or several connection strings may be configured with postfixes of the form `.N` (N being a consecutive numbering). The connection string is a comma-separated list of key/value pairs. The following keys are supported:

  * `host` Host name of the RADIUS server (required)
  * `authPort` Port for authentication requests. Default: 1812
  * `acctPort` Port for accounting requests. Default: 1813
  * `secret` Shared secret required to communicate with the server (required). Use nevisCred (with the neviscred://... syntax) to protect the value in the configuration.
  * `timeout` Server communication time-out in milliseconds. Default: 10000 (10 seconds)

  This AuthState uses the UDP protocol to send messages to backend servers. It is thus susceptible to SOCKS proxies, as described in the chapter [Configuring proxies](../../use-cases-and-best-practices/use-cases/configuring-proxies.md).

* `poolingMode` ({failover,load balancing}, failover)

  Defines the handling of multiple configured connections.

* `discardInterval` (duration in seconds, 10)

  Sets the interval during which a backend service will not be connected to when connectivity problems occurred.

* `retryDiscardedResources` (boolean, false)

  When all configured connections are blocked by the `discardInterval`, enabling this setting will have the AuthState retry connections before the `discardInterval` has passed. The next connection to retry will be selected according to the pooling mode configured.

* `request.type` (string {Access-Request,Accounting-Request}, required)

  The RADIUS RequestType that shall be sent to the server.

  Note that Access-Request has a special behavior:

  * If no User-Name attribute is configured: the `loginId` or `${inargs:isiwebuserid}` will be set (if applicable).
  * If no User-Password attribute is configured: `${inargs:isiwebpasswd}` will be set (if applicable).
  * If no State attribute is configured: The state received in the last RADIUS response (`${sess:radius.State}`) will be set (if applicable).

* `request.attributes` (comma-separated list, -)

  The RADIUS attributes to send in the request packet. Each attribute must be specified in the form `<attr-type>=<attr-value-expression>`.
  Example: `User-Name=${request:userId}, User-Password=${inargs:passwd},State=${}`

* `authenticateOn` (string, -)

  RADIUS _ResponseType_ that signals authentication. If the server responds with this type of packet, the AuthState will signal authentication with the user ID that was used in the request.

* `scope` (string {outargs, notes, session, inctx, inargs, roles}, "outargs")

  Variable scope where attributes of incoming response are stored.
--------------------------------------------------------------------------------
Section: ### Properties
* `host` (string, "localhost")

  A comma- or space-separated list of hostnames to be used as backend servers. Load balancing is not supported. Fail-safety to the next server in the list is done upon any (technical) failures. The last backend successfully used is remembered.

  This AuthState uses the UDP protocol to send messages to backend server. It is thus susceptible to SOCKS proxies, as described in the chapter [Configuring proxies](../../use-cases-and-best-practices/use-cases/configuring-proxies.md).

* `authPort`  (number, 1812)

  Port of the authentication server.

* `secret` (string, -)

  Shared secret required to communicate with the server. The secret must be generated on the ACE server using the administration tools of the ACE installation.

  Use nevisCred (with the neviscred://... syntax) to protect the value in the configuration.

* `timeout` (number [sec], 60)

  Server communication time-out in seconds.

* `retryTime` (number [sec], 120)

  This period defines how long a failed back-end server is ignored before it is used again for failover.

* `retryCount`  (number, 3)

  Specifies the number of retries before aborting. Retries are not done on the failed back-end server but on the next host in the list (round-robin failover). Retries are aborted if all servers in the list have been tried.

* `userIdMapper` (string, "${inargs.isiwebuserid}")

  This attribute allows to change the input argument sent by the user.

* `passwordMapper` (string, "${inargs.isiwebpasswd}${inargs.tokencode}")

  This attribute allows to specify the value used as passcode.

* `propagateResponse` (string, -)

  A list of response attribute names that should be propagated to the notes. If set to all, all RADIUS response attributes will be propagated. Disabled by default.

* `customTransitionMessagePattern_[0-n]`  (string, -)

  A message template (a pattern) that is matched against the _AccessChallenge_ _reply-message_ delivered by the server. If it matches, the result will be set to `customTransition_[0-n]`. The pattern must be a Java regular expression.
--------------------------------------------------------------------------------
Section: ### useridpasswordauthenticatestate.md
---
sidebar_position: 76
---

# UseridPasswordAuthenticateState

## Introduction and overview

The JNDI-based *UseridPasswordAuthenticateState* AuthState permits performing simple authentication (e.g., password login) to any LDAP directory via LDAP or LDAPS.

The AuthState supports the following features:

* Simple login (login ID, password).
* Prospect login (the directory is queried for the user's existence, but no credential is checked).
* Password change (the user's *userCredential* attribute can be updated with a new password).
* Password expiration detection (SunONE, Novell eDirectory, AD and OpenLDAP).
* Direct directory bind, in case of a flat directory structure (see the `userDN` property).

During a login, the AuthState processes the following steps:

1. The AuthState checks that all input fields configured in the GUI are provided by the user. Otherwise, the GUI is displayed (If the AuthState is final the GUI is always displayed).
2. If no `userDN` is configured, the AuthState opens a connection to the LDAP and searches for the user with either the configured `userBaseDN` and `userFilter` or with a `baseDN` and filter derived from the configured LDAP dialect (via the property `dirStyle`).
If a `userDN` is configured, this connection will use the DN and password specified in the connection string.
3. If no user was found, the result `usernotfound` is returned. If multiple users were found and `userSelectAttr` is configured, the AuthState will display a selection of users based on the values of the attribute. If multiple users were found but `userSelectAttr` is not defined, the transition `usernotunique` is returned.
4. The AuthState uses the `userDN` and the user password to bind to the LDAP. If this bind succeeds, the user is authenticated. Depending on the dialect of the server (set in property `dirStyle`), a required password change can be signaled by a special error code. If `userCheckOnly` is enabled, this step is omitted. If the bind failed, the AuthState will stop processing with the result `default`.
5. If new passwords are provided (properties `newPw1Source` and `newPw2Source`), a password change is attempted using the connection bound to the user in step 3. The details of the password change depend on the dialect configured. This step is ommitted if `userCheckOnly` is enabled.
6. The user attributes are fetched. This query will be performed according to the `delegate`` properties configured, but some additional, dialect-specific attributes that are used for password expiration detection are also fetched.
7. The user roles are fetched and transformed according to the `role`` properties configured.
8. If a password expiration has been detected in step 3 or 5, the result `pwchangerequired` (if a matching transition is configured) or `pwchange` is selected. Otherwise, the result `ok` is returned.

## Structured user sub-tree in LDAP

Indirect directory bind by first locating the user anonymously or with a functional LDAP account (see `userBaseDN` property).

## Authorization support

Coarse-grained authorization support on nevisProxy by retrieving role or group information from the directory and propagate them as Nevis security roles (see `roleBaseDN` property).

## User-profile support

User profile support by retrieving further attributes from the directory and `delegateBaseDN` property.

## Fail-safety

The LDAP connector is failsafe, performing a failover when the client library (JNDI) throws a communication exception.Note: Old releases may perform a failover on any exception, i.e., a user providing an invalid passphrase is authenticated against every directory. If the directory uses a failure counter, bookkeeping of user login failures may therefore be wrong.

## Description

The following table and chapters describe the characteristics of the AuthState.

| Topic    | Description                                                        |
|----------|--------------------------------------------------------------------|
| Class    | `ch.nevis.esauth.auth.states.jndi.UseridPasswordAuthenticateState` |
| Logging  | JNDIState, JNDI                                                    |
| Auditing | none                                                               |
| Marker   | LDAP:username/password                                             |
| Methods  | authenticate, setup                                                |

## Properties
--------------------------------------------------------------------------------
Section: ### Network
* `connection1, ..., connection9` (url, -)

  This property configures the network connection and simple (functional) authentication when the authentication needs to query the LDAP to have access to directory subtrees (login information is required if required data is not visible, i.e., authorized to an anonymous client). If two-way SSL is used, the LDAP directory may perform authentication based on the client certificate. As JNDI is used as a client library, connection parameters, keystores and truststores must be configured as system properties.

  Connections are used in the indexed order for fail-safety, i.e., load balancing and stateful target discarding are not supported at the time. The general syntax is:

  ```
  (ldap|ldaps)://<host-or-ip>:<port>
   [<functional-user-DN> (neviscred://<neviscred-alias>|secret://<obfuscated-password>|<plain-password)]
  ```

  This AuthState uses the LDAP protocol when establishing a connection with an LDAP server. The AuthState is thus susceptible to SOCKS proxies, as described in the chapter [Configuring proxies](../../../use-cases-and-best-practices/use-cases/configuring-proxies.md).

  Examples:

  ```
  ldap://ldap.siven.ch:389
  ldaps://ldap.siven.ch:636 CN=admin,O=siven,C=ch secret://Ll41Zsw54rmeNi2ZeoZD
  ```

  The following (backward compatible) properties are available too:

  * url (URL): URL part of the connection
  * user (DN): User part of the connection above
  * password (string): Password part of the connection

  The default connection time-out is five seconds (com.sun.jndi.ldap.connect.timeout=5000).
  The JNDI client sets the following system properties by default (see Sun documentation for details).
  To configure different behavior, set the appropriate values in `JAVA_OPS`.

  ```
  com.sun.jndi.ldap.connect.pool.maxsize=8
  com.sun.jndi.ldap.connect.pool.timeout=300000 // cache connections for up to 5 minutes
  com.sun.jndi.ldap.connect.pool.protocol="plain ssl"
  com.sun.jndi.ldap.connect.pool.authentication=none // only cache unauthentic connections
  ```

  The following per-pool defaults will be set and may be overridden by defining equivalent properties for the AuthState:

  ```
  com.sun.jndi.ldap.connect.pool=true // turn on connection pooling
  com.sun.jndi.ldap.connect.timeout=5000 // 5sec connect time-out
  com.sun.jndi.ldap.read.timeout=10000 // 10sec read time-out
  ```

* `searchSizeLimit` (int, 256)

  This property limits the number of results returned by an LDAP search. This way, you can control resources such as memory and network bandwidth.
--------------------------------------------------------------------------------
Section: ### directresponsestate.md
---
sidebar_position: 67
---

# DirectResponseState

## Introduction and overview

This AuthState can be used to send a direct HTTP response to an end user / client by forcing nevisProxy to directly forward the response.

An example is a situation where nevisAuth needs to send a JSON response to a web application. As the *DirectResponseState* does nothing but generating a response, it should be used as a final AuthState and the *resumeState* flag should be set to false.

A typical example where the *DirectResponseState* can be used is in the context of a mobile application: Depending on whether the authentication was successful or not, nevisAuth will send different JSON content in the HTTP response.

## Description

The following table and chapters describe the characteristics of the AuthState.

| Topic    | Description                                                      |
|----------|------------------------------------------------------------------|
| Class    | `ch.nevis.esauth.auth.states.directResponse.DirectResponseState` |
| Logging  | DirectResponseState                                              |
| Auditing | none                                                             |
| Marker   | none                                                             |
| Methods  | process, generate                                                |

## Properties

* `contentType` (string, - )

  This optional property defines the Content-Type header field of the HTTP response. It must be set if the content property is set.

* `content` (string, - )

  This optional property defines the content of the HTTP response. The value can be a URL of a file, starting with file://. For example:
  `<property name="content" value="file://path/to/my/file"/>`.

  nevisAuth does not have to be restarted when the file content changes.

* `statusCode`  (string, "200")

  This property defines the status code of the HTTP response status line.

* `header.<header-field>` (string, -)

  Optional properties to define custom HTTP response header fields.

## Input

none

## Transitions

none (should only be used as final AuthState)

## Output

An HTTP response containing the fields and content defined in the properties.

## Errors

none

## Notes

none

## Example

The following _DirectResponseState_ definition is used when the processing has failed. It sends a JSON response with an attribute called ErrorCode, whose value is 150:  `{ErrorCode: "150"}`

```xml
<AuthState class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState" final="false" name="GenMob-AuthErrGeneric" resumeState="false">
     <Response value="AUTH_ERROR">
     <!-- This is not necessary but is kept here to avoid a warning -->
     <Gui name="DummyGui" />
     </Response>
     <property name="content" value="{ "ErrorCode":"150" }" />
     <property name="contentType" value="application/json" />
     <property name="statusCode" value="401" />
</AuthState>
```

The following _DirectResponseState_ definition can be used when the processing was successful and sends a JSON response with an attribute called message whose value is login successful: `{message: "login successful"}`

```xml
<AuthState
name="GenMob-Ok" class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState" final="true" resumeState="false">
     <Response value="AUTH_DONE"/>
     <property name="contentType" value="application/json"/>
     <property name="content" value="{"message":"login successful"}"/>
     <property name="header.Expires" value="Tue, 15 Nov 2020 08:12:31 GMT"/>
</AuthState>
```

The AuthStates can be referenced by other AuthStates. For example, the following AuthState will use the previously defined _DirectResponseStates_, which depends on the result condition:

```xml
<AuthState class="ch.nevis.esauth.auth.states.xml.DocumentProcessor" final="false" name="GenMob-Ok" resumeState="true">
         <ResultCond name="default" next="GenMob-AuthErrGeneric" />
         <ResultCond name="ok" next="GenMob-Ok" />
...
```

```xml
<AuthState name="DirectResponse" class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState" final="true" resumeState="false">
     <Response value="AUTH_ERROR"/>
     <property name="contentType" value="application/json"/>
     <property name="content" value="{"Error Message":"${notes.lasterrorinfo}"}"/>
     <property name="statusCode" value="401"/>
     <property name="header.Expires" value="Tue, 15 Nov 2020 08:12:31 GMT"/>
</AuthState>
```

The following example uses the contents in the session to generates a JSON response providing the authentication level stored in the notes in the JSON status attribute:

```xml
<AuthState
class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState" final="false" name="GenMob-RegNewDevAuthDoneResponse" resumeState="false">
     <Response value="AUTH_DONE">
     <Gui name="AuthDoneDialog" />
     </Response>
     <property name="content" value="{ "status":"${notes:authlevel}" }" />
     <property name="contentType" value="application/json" />
     <property name="header.isiwebauthstate" value="valid" />   
     <property name="statusCode" value="200" />
</AuthState>
```
--------------------------------------------------------------------------------
Section: ### relyingpartystate.md
---
sidebar_position: 96
---

import REUSE from '/docs/reusable-md/_new-auth-http-client-information.md'

# RelyingPartyState

<REUSE/>

## Designated usage of the RelyingPartyState and integration with nevisProxy

The AuthState *RelyingPartyState* implements the authorization code flow and can be used to implement login in a Nevis-protected web application via an OpenID Connect identity provider. This is achieved by configuring nevisProxy to intercept unauthenticated requests to the web application and requiring authentication by nevisAuth. A nevisAuth instance configured with the *RelyingPartyState* will issue an authentication request to the OpenID Connect provider via an HTTP redirect. The OpenID Connect provider will then require the end user to authenticate. If successfully completed, the provider will redirect the end user back to the relying party with an authorization code. Upon receipt of an authorization code, the *RelyingPartyState* will redeem it for an ID and access token at the provider. The ID token returned by the provider will then be verified by the *RelyingPartyState*, the user ID will be set to the subject claim in the ID token and further claims contained in the ID token will be propagated in the session. nevisAuth will respond to nevisProxy with *AUTH_DONE* and a SecToken, which nevisProxy can then delegate to the originally requested web application. This flow is also depicted in the following figure.

```plantuml
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}


title Nevis and Open ID Connect Relying Party: Authorization Code Flow

participant "End-user / Resource Owner" as client

box "Open ID Connect Relying Party"

participant nevisProxy as proxy
participant "nevisAuth (RelyingPartyState)" as auth
participant "Nevis protected Webapp/Resource" as resource

end box

participant "Open ID Connect IdP" as idp

client -> proxy: GET WebApp (original request)
proxy -> auth: authenticate()
auth -> client: Authentication Request
client -> idp: Authentication Request
idp -> idp: Authenticate End-user
idp -> client: Authentication Response \n (Authorization Code)
client -> auth: Authentication Response \n (Authorization Code)
auth -> idp: Token Request \n (Authorization Code)
idp -> auth: Token Response \n (ID Token, Access Token)

group Key Renewal Process only if required
auth -> idp: Get Verification Key
idp -> auth: Verification Key
end group

auth -> auth: validate ID Token / extract claims
auth -> auth: write claims to session
auth -> auth: authenticate user as subject in ID Token
auth -> proxy: authentication done
proxy -> auth: pass through original request with authentication token
auth -> client: response

@enduml
```

## Preconditions and limitations

The following preconditions and limitations exist:

* The *RelyingPartyState* AuthState requires the OpenID Connect provider to provide a [metadata document](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
* Required key material must be provided as a JWK document under the URL provided in the `jwks_uri` field of the metadata document.
* Only ID tokens provided as plain JWT or JWS (signed with RSA signature scheme) are supported.
* `acr` claims are ignored.

## Description

The following table describes the characteristics of the *RelyingPartyState* AuthState.

| Topic    | Description                                                                                                                                                                                                          |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Class    | `ch.nevis.esauth.auth.states.oauth2.openid.rp.RelyingPartyState`                                                                                                                                                     |
| Logging  | OIDCRelyingParty                                                                                                                                                                                                     |
| Auditing | none                                                                                                                                                                                                                 |
| Marker   | none                                                                                                                                                                                                                 |
| Methods  | process Issues an authentication request and a token request upon receipt of a successful authentication response. Authenticates end user and propagates claims if authentication response contains valid ID token.  |

## Properties

* `redirectURI` (string (URL))

  The _redirect_uri_ used in the authentication request. A valid URL or a variable which is substituted with a valid URL during runtime is supported.

* `clientId` (string)

  The client_id used in the authentication and token request.

* `clientSecret` (string)

  The _client_secret_ used in the token request. The AuthState supports both a fixed client secret and a variable that is substituted during runtime.

* `scope` (space-separated string)

  Requested scope used in the authentication request.

* `claimsRequest` (string)

  The _claims_ request parameter.  This value is expected to be formatted in JSON and does not accept trailing spaces nor tabs.

* `providerConfiguration` (string)

  Supported values are

  * the URL of the provider metadata document,
  * a string containing provider metadata as per specification, or
  * a variable containing a provider metadata document.

  This AuthState uses the HTTP protocol to fetch the metadata document (depends on the URL configured). It is thus susceptible to HTTP proxies, as described in chapter [Configuring proxies]([Configuring proxies](../../../../use-cases-and-best-practices/use-cases/configuring-proxies.md)).

* `maxAge` (integer in seconds)

  The _max_age_ request parameter used in the authentication request

  :::info

  The _max_age_ property is not supported by Google IdP (they return an invalid expire time), so do not add this property while using Google as IdP.
  :::

* `acr_values` (string)

  Requested Authentication Context Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request. The Authentication Context Class satisfied by the authentication performed is returned as the acr Claim Value. The acr Claim is requested as a Voluntary Claim by this parameter.

* `arbitraryAuthRequestParam.[paramName]` (string)

  Arbitrary additional request parameters used in the authentication request.
  The property supports variable substitution.

  ```xml title="Example"
  <property name="arbitraryAuthRequestParam.[paramName]" value="[paramValue]" />
  ```

* `userId` (string, "${sess:[AuthStateName].idTokenClaim.sub}")

  The user ID by which the user will be authenticated. The AuthState supports both a fixed user ID or a variable one that is substituted during runtime.

* `clientAuthMethod` (string, "client_secret_basic")

  The secret can be sent to the token endpoint in two ways:

  * `client_secret_basic` (default)

    The client secret and clientID are sent to the token endpoint with the HTTP Basic authentication scheme.

  * `client_secret_post`

    The client secret and clientID are sent to the token endpoint with the HTTP Post scheme.

* `responseMode` (string, "query")

  The way to handle authorization callback (to nevisAuth)

  * `query` (default)

    The callback via GET request

  * `form_post`

    The callback via POST request

* `allowRedirect` (boolean, true)

  After receiving a response from the OpenID Connect identity provider, RelyingPartyState will automatically set redirect to the original request URL. Set this variable to "false" to disable this behavior.

  :::info

  After you disable the redirect here, add another AuthState for redirecting back to the original request URL.
  :::

* `httpclient.*` (String)

  Configure the outgoing HTTP communication towards the metadata provider. For a list of valid HTTP properties, see [HTTP Client](/nevisauth/setup-and-configuration/components/http-client).

## Input

none

## Transitions

* `failed`

  Authentication was not successful, the ID token was not valid or an internal error occurred.

* `ok`

  Authentication was successful and the ID token is valid.

## Output

* `session:[AuthStateName].tokenResponse.[field]`

  The value of fields of the received token response. For example:

  ```
  RelyingParty.tokenResponse.id_token = [encodedIDToken]
  RelyingParty.tokenResponse.access_token = [encodedAccessToken]
  ```

* `session:[AuthStateName].idTokenClaim.[claimName]`

  The value of the claims present in the ID token. For example:

  ```
  RelyingParty.idTokenClaim.sub = [username]
  ```

## Errors

none

## Notes

none

## Example

```xml
<AuthState name="RelyingParty" class="ch.nevis.esauth.auth.states.oauth2.openid.rp.RelyingPartyState" final="false">
        <ResultCond name="ok" next="AuthDone"/>
        <ResultCond name="failed" next="AuthError"/>   
        <property name="redirectURI" value="[redirectURI]" />
        <property name="clientId" value="[clientId]" />
        <property name="scope" value="openid email" />
        <property name="claimsRequest"
            value="{&quot;id_token&quot;:{&quot;given_name&quot;:null}, &quot;userinfo&quot;:{&quot;address&quot;:null}}" />
        <property name="clientSecret" value="[clientSecret]" />
        <property name="providerConfiguration" value="[providerMetadataDocumentURI]" />
        <property name="maxAge" value="3600" />
        <property name="arbitraryAuthRequestParam.access_type" value="offline" />
        <property name="arbitraryAuthRequestParam.new_value" value="#{StringUtils.contains(inargs['auth-strength'],'2') ? 'qoa2':'qoa1'}" />
</AuthState>
```

If not present yet, add the root certificate to the truststore (`-Djavax.net.ssl.trustStore`) that is defined in the `JAVA_OPTS` configuration option in the *env.conf* file. See also the following sample code snippet. The root certificate is used to *prove* the authenticity of the provider configuration and to *verify* the authenticity of the token and authorization endpoints.

```
keytool -import -keystore /var/opt/keybox/default/truststore.jks -file GeoTrustGlobalCA.pem
```
--------------------------------------------------------------------------------
Section: ### introduction-to-openid-connect-relying-party.md
---
sidebar_position: 94
---

# Introduction to OpenID Connect relying party

An "OpenID Connect relying party" is an OAuth 2.0 client application requiring end-user authentication and claims from an OpenID Connect provider (as defined in [the Specification](http://openid.net/specs/openid-connect-core-1_0.html). Put in other words, a relying party relies on authentication information and claims issued by another entity. A common use case is to support login in a web application via an identity provider such as e.g., Google and PayPal.

In nevisAuth this functionality is implemented with the AuthStates *OIDCProviderMetadataFetcherState*, the *RelyingPartyState* and the *UserinfoClientState*.
--------------------------------------------------------------------------------
Section: ### introduction-to-oauth2-authstates.md
---
sidebar_position: 99
---

# Introduction to OAuth2 AuthStates

## Introduction

An OAuth2 AuthState is a collection of OAuth 2.0 client applications requiring end-user authentication and claims from an OAuth2 provider (as defined in [RFC 6749](http://datatracker.ietf.org/doc/html/rfc6749). In this situation, the client relies on authorization information and claims issued by another entity. A common use case is to support login to a web application via an identity provider such as, for example, Facebook and GitHub.

In nevisAuth, this functionality is implemented with the following AuthState: [OAuth2ClientState](oauth2clientstate.md).

Designated usage of the OAuth2 AuthState(s) and integration with nevisProxy

The OAuth2 AuthState(s) implement the authorization code flow. You can use the OAuth2 AuthState(s) to implement the login to a Nevis-protected web application with an OAuth2 identity provider. This is what happens:

1. nevisProxy intercepts an unauthenticated request to the web application and requires authentication by nevisAuth.
2. The nevisAuth instance, which is configured with the OAuth2 AuthState(s), issues an authorization request to the OAuth2 identity provider via an HTTP redirect.
3. Subsequently, the OAuth2 identity provider requires the end user to authorize.
4. Upon successful completion of the authorization, the provider redirects the end user back to the client with an authorization code.
5. After receiving the authorization code, the OAuth2 AuthState redeems the code for an access token at the provider.
6. The OAuth2 AuthState asks for the user's information with another HTTP GET request, and propagates the user information in the session.
7. nevisAuth responds to nevisProxy with `AUTH_DONE` and a SecToken.
8. nevisProxy delegates the SecToken to the originally requested web application.

The following figure shows the described flow:

```plantuml
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}


title Nevis and OAuth 2 client: Authorization Code Flow

participant "End-user / Resource Owner" as client

box "OAuth2 Client"
participant nevisProxy as proxy
participant "nevisAuth (OAuth2ClientState)" as auth
participant "Nevis protected Webapp/Resource" as resource
end box

participant "OAuth2 IdP" as idp

client -> proxy: GET WebApp (original request)
proxy -> auth: authenticate()
auth -> client: Authentication Request
client -> idp: Authentication Request
idp -> idp: Authenticate End-user
idp -> client: Authentication Response \n (Authorization Code)
client -> auth: Authentication Response \n (Authorization Code)
auth -> idp: Token Request \n (Authorization Code)
idp -> auth: Token Response \n (ID Token, Access Token)
auth -> idp: User information \n Authorization: Bearer <Access Token>
idp -> auth: User information

group Only when email endpoint is configured
auth -> idp: User email \n Authorization: Bearer <Access Token>
idp -> auth: User email
end group

auth -> auth: write user info / email to session
auth -> auth: authenticate user by user ID from user info
auth -> proxy: authentication done
proxy -> auth: pass through original request with access token
auth -> client: response

@enduml
```

## A note on the root certificate

The root certificate is used to *prove* the authenticity of the provider configuration and to *verify* the authenticity of the token and authorization endpoints.

If not present yet, add the root certificate to the truststore (`-Djavax.net.ssl.trustStore`) that is defined in the `JAVA_OPTS` configuration option in the *env.conf* file. See also the following sample code snippet:

```
keytool -import -keystore /var/opt/keybox/default/truststore.jks -file GeoTrustGlobalCA.pem
```
--------------------------------------------------------------------------------
Section: ### authorization-server.md
---
sidebar_position: 89
---

# Authorization server and Open ID Connect provider plug-ins

The nevisAuth OAuth2 authorization server and Open ID Connect provider plug-ins basically implement the two roles authorization server and resource server as defined by the OAuth 2 specification in the [AuthorizationServer](authorizationserver.md) and the [AccessTokenConsumer](accesstokenconsumer.md). The *AuthorizationServer* issues access tokens to third-party clients with the approval of the resource owner. The *AccessTokenConsumer* accepts access tokens issued by the *AuthorizationServer* and grants access to protected resources if the access token could be successfully verified.

The designated usage of the *AuthorizationServer* and *AccessTokenConsumer* are illustrated in the following figure:

<img className="boxed" src={require('../../../../assets/nevisauth-authorization-code-flow.drawio.png').default} alt="Authorization code flow with Nevis"/>

The previous figure depicts an authorization code flow as it takes place in a typical Nevis environment consisting of nevisProxy and nevisAuth:

1. An end user requests a page from a third-party web application.
2. As the web application requires access to the OAuth2 protected resource to fulfill the request in this scenario, the web application redirects the end user to Nevis with an authorization request.
3. nevisProxy intercepts the request and sends it to nevisAuth via the internal SOAP interface, where it is validated by the *AuthorizationServer* AuthState (hereby implementing the authorization endpoint). After authenticating the end user and establishing the user's consent (interaction not shown in this figure), an authorization response including an authorization code is sent to the web application via an HTTP redirection.
4. After receiving the authorization code, the web application sends a token request including the authorization code to Nevis.
5. nevisProxy intercepts the request and sends it to nevisAuth via the internal SOAP interface, where it is validated by the *AuthorizationServer* AuthState (hereby implementing the token endpoint). After successfully verifying the authorization code, a token response including an access token and if requested an ID token and refresh token are issued directly to the web application.
6. Now being in possession of an access token, the web application requests the OAuth2 protected resource. This request is intercepted by nevisProxy and sent for authentication to nevisAuth, which verifies the submitted access token.
7. After successfully verifying the access token, the resource request is passed to the resource, which then responds to the web application.

n the designated usage scenario, multiple sessions are established in the process of the authorization code flow. In step 3, a session with the end user's browser is established as the end user will be authenticated (user ID = end user's ID). In step 5, a session with the web application is established as the client will be authenticated (user ID = client_id). In step 7, a virtual session bound to the access token will be established with the web application (user ID = end user's ID associated with the submitted access token). I.e., whenever the web application requests a resource and supplies an access token, the session previously established when sending the same access token will be selected.

:::info

The most productive setups include two or more nevisAuth instances in a load balancing or failover configuration (or a combination of both). In such a scenario, a nevisAuth instance must be able to consume authorization codes issued by any of the other instances. To enable this, a common OutOfContextDataServices (see chapter [Shared out-of-context data](../../../components/shared-out-of-context-data.md)) must be used. Note that all instances must use the same key to sign token responses for this scenario to work.
:::
--------------------------------------------------------------------------------
Section: ### Properties
* `accessTokenLifetime` (seconds, 3600)

  Defines how long an access token issued by the authorization server should be valid per default (can be overwritten by client policies).

  :::info

  Note that the calculation of the expiration time is based on the issuing time of the authorization code, not on the time the access token is returned in the AuthorizationServer's response.
  :::

* `refreshTokenLifetime` (seconds, 1 year)

  How long a refresh token issued by the authorization server should be valid per default (can be overwritten by client policies).

* `authCodeLifetime` (seconds, 600)

  How long an authorization code issued by the authorization server should be valid.

* `keystoreref` (string, "DefaultKeyStore"), `keyobjectref` (string, "DefaultSigner")

  This property configures the key and certificate to use when issuing tokens. The access token is encrypted using the configured public key. The ID token is signed using the configured private key. Currently, RSA and Elliptic Curve (EC) keys are supported.

  If the nevisAuth instances are configured in a load balancing or load balancing configuration, the `keystoreref` of all the instances should reference the same keys.

* `keyID` (string, - )

  This property configures the kid JOSE header value of the issued access and ID tokens. It allows the authorization server to explicitly signal a change of key material to recipients. The meaning of the `kid` header is slightly different for [signed](https://tools.ietf.org/html/rfc7515#section-4.1.4) and [encrypted](https://tools.ietf.org/html/rfc7516#section-4.1.6) tokens.

  **Note:**
  * kid JOSE header value will be generated automatically (if `keyID` is not set) from the key which is used to sign or encrypt the token using JWK thumbprint (RFC 7638) method.
  * ID Token encryption is using JWKS, therefore the keyID for the encrypted ID Token will contain the keyID belonging to the key used from the JWKS. Setting this keyID property has no effect on ID Token encryption.

* `dataSource` (string, "local")

  Determines what data source should be used to configure OAuth 2.0 clients and scopes. With dataSource=local, client and scope configuration data is supplied via configuration properties. With `dataSource=nevismeta`, client and scope configuration data is supplied via nevisMeta.

* `propagationScope` (string, "session")

  Define propagation scope to store information for following AuthStates.

* `encryptAccessToken` (boolean, true)

  This property defines the format of the Access Token. If set to:

  * true, the Access Token will be encrypted (JWE).
  * false, the Access Token will not be encrypted (JWS).

* `nestedJWSAccessToken` (boolean, false)

  This property defines how JWS Access Token is generated. If set to:

  * true, the JWS Access Token is nested (JWS inside JWS Access Token).
  * false, the JWS Access Token is not nested.

  This property can only use when encryptAccessToken set to false to generate JWS Access Token.

* `rotateRefreshToken` (boolean, false)

  This property defines if a new Refresh Token is issued together with the Access Token on the Token Endpoint while exchanging a refresh token for a new access token (`grant_type=refresh_token`).

  * true, a new Refresh Token is issued, the existing Refresh token is deleted.
  * false, the existing Refresh token is returned and remains valid.

* `absoluteRefreshTokenLifetime` (boolean, false)

  This property defines if a new Refresh Token in a token rotation sequence is issued with the same expiration time as the initial Refresh Token.

  * true, the expiration time of the new Refresh Token will be the same as the old Refresh Token.
  * false, the expiration time of the new Refresh Token will be the current time plus `refreshTokenLifetime`.

* `removeEmptyClaimsInToken` (boolean, false)

  This property defines whether empty claim(s) will appear in the Access Token and ID Token.

  * true, the ID Token and Access Token will not include empty claim(s).
  * false, the ID Token and Access Token may include empty claim(s).

* `openid.jwks.httpclient.*` (String)

  Configure the outgoing HTTP communication to the jwksUri specified for the client, to download keys for ID Token encryption. For a list of valid HTTP properties, see [HTTP Client](/nevisauth/setup-and-configuration/components/http-client).

* `openid.jwks.addx5c` (boolean, false)

  This property defines whether `x5c` field will appear in the ID Token header.

  * `true`, the ID Token will include `x5c` field in the token header.
  * `false`, the ID Token will not include `x5c` field in the token header.

* `jwt.bearer.aud` (String)

  Configure the accepted audience for validating JWTs in JWT Bearer flow. If left unset any non-null and non-empty value will be accepted for audience.
--------------------------------------------------------------------------------
Section: ### AuthState / Instance HTTP client
The "instance" HTTP client is **used by most auth states** and allows a per-auth-state configuration of the HTTP client in the _esauth4.xml_ file.
For example, adding the `httpclient.tls.keyObjectRef` property to the auth state configures the key object references for this specific auth state.
The benefit of using this client is having fine-granular control over its behaviour and configuration, for example configuring individual trust stores only used by this client.

```java title="Intance HTTP client"
import ch.nevis.esauth.util.httpclient.api.HttpClient;
import ch.nevis.esauth.util.httpclient.api.HttpClients;
import ch.nevis.esauth.util.httpclient.api.Http;

Properties properties = new Properties();
HttpClient httpClient = HttpClients.create(properties);
Http.get().url("nevis.net").build().send(httpClient); 
```
--------------------------------------------------------------------------------
Section: ### session-management.md
---
sidebar_position: 36
---

# Session management

The session coordinator is responsible for managing the session lifecycle using the _local_ and _remote_ session stores.

The two key phases or states of the nevisAuth session are:

1. Unauthenticated session (also mentioned as initial session)
2. Authenticated session

The authentication engine uses two different inactivity timeouts depending on the authentication phase. The session coordinator enforces the current inactivity timeout and an absolute session lifetime.

The different timeouts are:

* **initial** inactivity timeout

  The user is performing a multistep authentication and has not yet fully established an authenticated session. This timeout is compared against the last access time.

* **established** inactivity timeout

  The user has successfully logged in. This timeout is compared against the last access time during the authentication process.

* **absolute** session timeout

  The session cannot be valid longer than the specified timeout. This timeout is compared against the creation time. This timeout is overridden by the time-to-live attribute of the *[TokenAssembler](/nevisauth/setup-and-configuration/components/token-assemblers-and-keystores#token-assembler)*, if the session was created via the AuthEngine.

When nevisAuth does not receive any session "hits", the established inactivity timeout needs to be equal to the absolute session timeout (the longest acceptable global session lifetime). Session hits may be performed by any client that gets requests from the authenticated user.

As nevisProxy instances know about every request a user is sending, the global authentication session is usually controlled by nevisProxy instances. The above session timeouts therefore are only relevant for limiting unauthenticated sessions and for clearing sessions where no termination notifications from nevisProxy instances arrive.

A simple session store configuration, in conjunction with the timeouts enforced by the AuthEngine, looks as follows:

```xml title="Session store configuration example"
<SessionCoordinator
  sessionInitialInactivityTimeout="600"
  sessionInactivityTimeout="28800"
  sessionInitialMaxLifetime="1200"
  sessionMaxLifetime="28800"
  sessionIdRandomBytes="32">
  
  <LocalSessionStore
     maxSessions="100000"
     reaperPeriod="60" />
  
  <TokenAssembler name="default">
     <Selector default="true"/>
     <TokenSpec version="CSSO-1.0" ttl="28800" algorithm="SHA256withRSA">
     ...
  </TokenSpec>
  
  <Domain name="SSO1" default="true"
     reauthInterval="0"
     inactiveInterval="1800">
     ...
  </Domain>
```

This example enforces:

* A maximum inactivity timeout to perform a login step of 600 seconds (only relevant for stateful multistep authentications), to be enforced by nevisAuth.
* The "screen lock" timeout (i.e., the inactivity timeout, that triggers a reauthentication on an existing session with some minimal credential requirements) is disabled.
* An inactivity timeout of 1800 seconds (i.e., the reverse proxy or client terminates the session and notifies nevisAuth, if the user does not send any requests during this period), to be enforced by the nevisProxy. Note that this setting only applies if the InactivePolicy of the IdentityCreationFilter is set to "global".
* A maximum session lifetime of 1200 seconds for Unauthenticated sessions.
* A maximum session lifetime of 28800 seconds for authenticated sessions, enforced by the lifetime of the security token. This is also the maximum lifetime for the authentication state within the session in nevisProxy.

:::info

Re-authentication (lock/unlock) can be enabled by setting `reauthInterval` to a value higher than 0 (zero). However, note that spontaneously locking sessions during application usage is non-trivial for many modern web applications and compatibility with this behavior should therefore be examined for each application.
:::

## SessionCoordinator configuration

The following list provides an overview of the `SessionCoordinator` configuration attributes for the two main groups regarding session management: lifetime and identifier.

* `sessionInitialInactivityTimeout` (Integer, seconds, optional, 600)

  Default value: `600`

  The session's initial inactivity timeout, which is raised to inactivityTimeout as soon as the initial login is completed. A user needs to perform a login step within this period. Otherwise, the user is forced to start over.

* `sessionInactivityTimeout` (Integer, seconds, optional, 28800)

  Default value: `28800`

  The session's inactivity timeout. When nevisAuth does not get any session events during this period, the session is killed.

  Kill the session if: lastAccessTime + inactivityTimeout <= now

  :::caution

  This attribute must have the same value as the maxLifeTime attribute.
  :::

* `sessionInitialMaxLifetime` (Integer, seconds, optional, 1200)

  Default value: `1200`

  The session's initial absolute timeout (applies to unauthenticated sessions), which is raised to maxLifetime as soon as the initial login is completed (e.g. when the authentication flow reaches `AUTH_DONE`). A user needs to complete the login within this period. Otherwise, the user is forced to start over.

* `sessionMaxLifetime` (Integer, seconds, optional, 28800)

  Default value: `28800`

  The session's absolute timeout. (applies to authenticated sessions)

  Kill the session if: creationTime + maxLifeTime <= now

  This attribute must have a value that is greater than or equal to the maximum of all TokenAssembler's ttl attribute because expired SecTokens already define the maximum lifetime of an authentication session.

* `sessionIdRandomBytes` (Integer, byte, optional, 32)

  Default value: `32`

  The session generates session IDs that are being used as global session identification and are part of the SecToken. The ID is generated by base64 encoding the specified number of true random bytes. The default of 16 bytes therefore represents 128 true random bits. The session ID length therefore is: sessionIdRandomBytes * 4 / 3 + $instance name length$

  :::info

  The session ID inside nevisAuth is prefixed with the nevisAuth instance ID to distinguish sessions generated by different nevisAuth instances.
  :::

* `sessionIdPreGenerate` (Boolean, optional, true)

  Default value: `true`

  Under normal circumstances, a session receives its final ID only after the state `AUTH_DONE` is reached for the first time. At this point, the previous (temporary) session ID is changed to a randomly generated ID as configured using `sessionIdRandomBytes`.

  Under some circumstances, it is desirable to know the final session ID during the authentication process. This can be achieved by setting `sessionIdPreGenerate` to "true". The session variable `ch.nevis.esauth.sess.id.pregenerate` will then be filled with the future session ID upon creation of the session.
--------------------------------------------------------------------------------
Section: ### Terminated session polling
As mentioned before different session lifetime configuration in nevisProxy and nevisAuth requires syncrhonization.

An other use-case where nevisProxy is not aware of session modifications done in nevisAuth is when you use a nevisAuth REST service or nevisAdapt to kill sessions in nevisAuth. In such case you should set `EnablePollTerminatedCalls` to true in the `esauth4Connector` in nevisProxy to synchronize sessions.

Technically nevisProxy calls nevisAuth using the `poll_terminated_sessions` soap operation where nevisAuth will wait for maximum 30 seconds to respond. In case there are session terminations initiated by the caller nevisProxy instance, the reponse with terminated sessions will be returned immediately. In case there are no expired sessions, nevisAuth will send an empty response once 30 seconds passed. nevisProxy will remove the received sessions itself and it will reconnect again to listen for more sessions to be removed.

## Session indexing

nevisAuth sessions can be indexed by a configurable session attribute. Enable indexing by adding the `SessionIndexing` element, see [Session indexing](#session-indexing) for further information.

* `attribute` (String, "$session attribute name$", optional, `ch.nevis.session.loginid`)

  Default value: `ch.nevis.session.loginid`

  Enable indexing on a configured session variable.  

* `attributeMapping` (Enum {none, unicodeEscape, hash}, optional, `hash`)

  Default value: `hash`

  Defines the format in which the session index value is written into the remote session store in case [Session indexing](#session-indexing) is turned on.
  Available mappings are:

  * `none`
  
    The value of the session index is stored as it is in the session without any change (legacy behavior).
  
  * `unicodeEscape`
  
    Non-Latin 1 (ISO 8859-1) characters in the session index value are unicode-escaped (\uxxxx), for example, `abçdefğ` is stored as `ab\u00E7def\u011F`.
  
  * `hash`
  
    The SHA-256 (hex) hash of the session index value is stored, for example, `abçdefğ` is stored as `20c76ac7893952f0d6993b1977ec13893f76cc5fdf4eb4d00f788e89c9101785`.

## Local session store

nevisAuth uses an in-memory session store to hold authentication sessions. This session store uses an inactivity timeout mechanism with a session reaper mechanism to get rid of expired sessions. The session store has an upper limit to prevent uncontrolled session creation and heap space growth.

The use of the `LocalSessionStore` is **required** for the operation of nevisAuth, it cannot be disabled.

The following list provides an overview of the `LocalSessionStore` configuration attributes.

* `maxSessions` (Integer, maximum number, optional, 100000)

  Default value: `100000`

  The maximum number of session entries allowed. This parameter is the upper limit for parallel global authentication sessions. If the reverse proxy is solely using nevisAuth as an authentication infrastructure, only this number of authenticated clients are able to pass the reverse proxy at a time.
  
  Note that once the maximum amount is reached no new session will be created until an existing session expires. In kubernetes based deployments this might not be desired as nevisAuth might look healthy, but actually cannot receive new load.

* `reaperPeriod` (Integer, seconds, optional, 60)

  Default value: `60`

  The reaper thread locks the session cache regularly (defined by this period) to clean up expired sessions.

## Remote session store

Typical reasons for storing sessions remotely are, to provide resilience, and to share sessions between nevisAuth instances.

Whenever a session event is fired, for example when a session is deleted or updated, all session listeners are informed about the recent change. As a listener the remote session store will attempt to synchronize the current state of the session with the remote session database.

The `RemoteSessionStore` element encapsulates the configuration options for the database connection, synchronization features and the cleanup of expired sessions. The remote session store is enabled by defining the `RemoteSessionStore` element. To disable it, either remove the element or comment it out.

By default, setting both authenticated and unauthenticated sessions are synchronized. This can be changed, so only authenticated session are stored.
--------------------------------------------------------------------------------
Section: ### Multiple nevisAuth instances with resilience
More resilience can be achieved by using a replicated MariaDB setup and increasing retry failure. Note that increasing the rerty period and number will have some affects on memory usage in case of high load and prolonged syncronization issues.

```xml title="Example with replicated remote session store databases and retries" {12,17}
<SessionCoordinator
 ...>
 
 <LocalSessionStore 
  maxSessions="100000"/>

 <RemoteSessionStore
  provider="jdbc"
  connectionUser="nss_auth"
  connectionPassword="nss_auth"
  connectionUrl="jdbc:mariadb:sequential//host-db1:3306,host-db2:3306/NSS"
  syncPullInitial="false"
  syncFailRetryPeriod="200"
  syncFailRetryCount="3"
  storeUnauthenticatedSessions="true"/>
```

## Configuring Resilient Session Sharing with MariaDB

This chapter is about resilience towards outages of session sharing database nodes, which differs from resilience towards failures of nevisAuth instances. To achieve resilience towards failures of nevisAuth instances, configure two nevisAuth instance addresses in nevisProxy. Such a configuration enables failover to the second nevisAuth instance if nevisProxy cannot connect to the first nevisAuth instance. For more information, see the nevisProxy reference guide (`InetAddress` parameter of the *HttpConnectorServlet*).
--------------------------------------------------------------------------------
Section: ### Resilience to Database Instance Outage
This chapter explains how to set up two MariaDB instances for session sharing with replication . The advantages of this solution are:

* Sharing of sessions between nevisAuth instances and support of nevisProxy for failover for the nevisAuth instances.
* Resilience towards outage of one of the MariaDB instances or its host (e.g., in case of a power outage).
* Resilience towards a failure of the network infrastructure between nevisAuth and one of the MariaDB instances (e.g., in case of a data center outage).

:::info

The above statements hold only as long as at least one of the two MariaDB instances is running and reachable. Simultaneous outage of both database instances hinders nevisAuth from sharing sessions.
:::
--------------------------------------------------------------------------------
Section: ### certificates-keys-and-public-key-infrastructure.md
---
sidebar_position: 26
---

# Certificates keys and public key infrastructure

Key material is used for various tasks in nevisAuth:

* Data signing (e.g., identity token signing)
* Data encryption (e.g., SAML response encryption)
* Transport security (SSL/TLS) in the front end (server)
* Transport security (SSL/TLS) in the back end (e.g., LDAPS or HTTPS connections)
* Certificate validation (expiration checking, trust validation, revocation checking)

Key material can be stored in the filesystem, on an HTTP webserver, on LDAP or on a hardware security module (HSM). Certificates stored on the file system, on an HTTP server or on LDAP will be frequently updated if not specified otherwise. It is also possible to use resource pools instead of directly configuring the path or URL to the resources. This enables failover or load balancing functionality.
--------------------------------------------------------------------------------
Section: ### rest-service-implementations.md
---
sidebar_position: 46
---

# REST service implementations

## TAN service

The TAN service is a REST service that sends TAN messages to recipients and responds to the client with the TAN code that it sent to the recipient. This service can access any session parameter when given the SecToken of the user. Alternatively, it can also operate stateless. The following list depicts the configuration properties of the TAN REST service:

* Class

  `ch.nevis.esauth.rest.service.TANService`

* Logging

  `REST`

* Default base path

  `/tan`

* Properties

  * `tanTemplate` (string, "6{ABCDEFGHIJKLMNOPQRSTUVWXYZ}")

    The template from which the TAN is formed. Defaults to 6 uppercase characters.

  * `sender` (string, -)

    The sender of the TAN. Can be overridden by query or form parameters.

  * `recipient` (string, -)

    The recipient of the TAN. Depending on the TAN channel this might be a mobile phone number or an e-mail address. Can be overridden by query or form parameters.

  * `messageTemplate` (string, "MTAN authentication code: ${notes:mtan.challenge}")

    The message template sent to the recipient. The actual message can be overridden by query or form parameters.

  * `channel` (string, "SMTP")

    The channel used to send the TAN message. Valid channels are "smtp", "aspsmssoap", "ucp", "http", "Swissphone", "null". The channel properties are described in [TAN authentication plug-ins](../../authentication-plugins-and-authstates/standard-authentication-authstates-and-plugins/tan-authentication-plugins.md).

  * `customerField` (string, -)

    This string can only be used with the _SwissPhone_ channel. It is optional. According to the IMASYS specification its maximum length is 254 chars with the "iso-8859-1" charset.

```xml title="Example"
<RESTService name="tanService" class="ch.nevis.esauth.rest.service.TANService" path=" /tan">
      <property name="rolesAllowed" value="nevisAuth.tanUser"/>
      <property name="channel" value="HTTP"/>
      <property name="httpUrl" value="http://www.smsbooster.com/send.asp"/>
      <property name="httpHeader.Referer" value="https://intranet.nevis.com/sms_service/index.htm"/>
      <property name="httpSuccessStatus" value="200-399" />
      <property name="httpParam.SMSTelefon" value="${notes:tan.http.receivers}"/>
      <property name="httpParam.smsMessage" value="${notes:tan.http.message}"/>
      <property name="httpParam.USERID" value="<yourID>" />
      <property name="httpProxyHost" value="proxy.nevis.com"/>
      <property name="httpProxyPort" value="3128"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of a TAN service:

* `GET`

  Path: `generate`

  MIME response type: `application/xml`,`application/json`

  Generates a TAN, sends it to the defined recipients and responds to the client with the generated TAN code.

  * `sender` (string, -)

    The sender of the TAN message. This will override the "sender" property if defined.

  * `recipient` (string, -)

    The recipient of the TAN message. This will override the "recipient" property if defined.

  * `message` (string, -)

    The message template of the TAN message that is sent to the recipient through the channel.
    This will override the "messageTemplate" property if defined.

  * `lang` (string, -)

    The language of the message template. If this parameter is not set, the default language of the authEngine is selected.

    Furthermore, channel-specific properties can be overridden by handing a parameter with the same name.
    This works for the following channel-specific properties:

    * smtpSubject
    * smtpHost
    * smtpPort
    * smtpUser
    * smtpPass

    See [TAN authentication plug-ins](../../authentication-plugins-and-authstates/standard-authentication-authstates-and-plugins/tan-authentication-plugins.md) for a detailed description of the channel-specific properties.

* `POST`

  Path: `generate`

  MIME response type: See corresponding `GET` method

## SAML metadata service

The SAML metadata service provides a document describing the available *IdentityProvider* entities for the nevisAuth instance. The service complies with the specification "Metadata for the OASIS SAML V2.0". For details, see [Metadata for the OASIS SAML V2.0](https://docs.oasis-open.org/security/saml/v2.0/saml-metadata-2.0-os.pdf).
The metadata can be used by *ServiceProviders*, for example if the *ServiceProvider* supports automatic importing of IdP information. The following information is provided:

* A unique ID that identifies the `idpDescriptor`.
* The supported protocol (SAML 2.0).
* Public signature and encryption key info material.
* Supported SAML bindings.
* List of issued SAML attributes.
* `NameID` descriptions.

The provided metadata will be signed with the configured signer key.

The following list describes the SAML metadata service:

* Class

  `ch.nevis.esauth.rest.service.SAMLMetadataService`

* Logging

  `REST`

* Default base path

  `/meta/SAML2.0`

  The REST service is available under the "/nevisauth/meta/SAML2.0" URL using the GET method.

* Properties

  * `state.<name>` (string, -)

    The name of the state of which metadata should be published..

  * `signatureKeyInfo` (string, "certificate")

    The content of the keyinfo which should be delivered when requesting SAML metadata.

  * `keystoreref` (string, "DefaultKeyStore")

    The keystore which contains the keyobject that should be used to sign the metadata.

  * `keyobjectref` (string, -)

    The signer with which the metadata should be signed with.

```xml title="Example"
<RESTService name="SAMLMetadataService"
          class="ch.nevis.esauth.rest.service.SAMLMetadataService"
          path="/rest/samlmeta">
     <property name="state.MyIdentityProvider1"
          value="https://nevisauth.com/idp1"/>
     <property name="state.MyIdentityProvider2"
          value="https://nevisauth.com/idp2"/>
     <property name="out.keystoreref" value="SAMLMetadataKeyStore"/>
     <property name="out.keyobjectref" value="SAMLMetadataSigner"/>
</RESTService>
```

The following list shows the available HTTP methods for the REST interface of a SAML metadata service:

* `GET` `/nevisauth/meta/SAML2.0`

  MIME response type: `application/samlmetadata+xml`

  Retrieves the metadata of all known entities.

* `GET` `/nevisauth/meta/SAML2.0/{id}`

  MIME response type: `application/samlmetadata+xml`

  Retrieves metadata by ID (SAML 2.0 Entity Descriptor entity ID).
  In case of an IdentityProviderState, the entity ID will be the out.issuer parameter by default.

  * `id` (string, -)

    The entity ID of a SAML 2.0 Entity Descriptor.

## OAuth 2.0 token introspection service

The OAuth 2.0 token introspection service as defined in the [RFC 7662](https://tools.ietf.org/html/rfc7662) is:

> [...] a method for a protected resource to query an OAuth 2.0 authorization server to determine the active state of an OAuth 2.0 token and to determine meta-information about this token.

nevisAuth provides this service out-of-the-box.  The resource, which is the HTTP client of the service, must provide the name of the authorization server to be used to validate the token. This is the [AuthorizationServer](../../authentication-plugins-and-authstates/oauth-2.0-and-openid-connect-plugins/authorization-server-and-open-id-connect-provider-plugins/authorizationserver.md) AuthState that generates the tokens to protect the resource. The name of the *AuthorizationServer* AuthState is provided as a path parameter in the URL of the HTTP request.

The following list describes the OAuth 2.0 token introspection REST service:

* Class

  `ch.nevis.esauth.rest.service.tokenintrospection.TokenIntrospectionService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/oauth/introspect`

* `authstates` (string, -)

  Comma-separated list of names of [AuthorizationServer](../../authentication-plugins-and-authstates/oauth-2.0-and-openid-connect-plugins/authorization-server-and-open-id-connect-provider-plugins/authorizationserver.md) AuthStates that are exposed by the token introspection service. If this list does not include the name of a specific AuthorizationServer, the service will report all tokens for this authorization server as being invalid.

* `authentication` (string {"BASIC"}, -)

  Space-separated list of methods accepted for authentication using the request header. For more information see OAuth 2.0 Token Introspection. More info how to do authentication with token introspection service here.

```xml title="Example"
<RESTService name="tokenIntrospection" class="ch.nevis.esauth.rest.service.tokenintrospection.TokenIntrospectionService" path="/oauth/introspect">
        <property name="authstates" value="AuthorizationServer1, AuthorizationServer2"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of the OAuth 2.0 token introspection service:

* `POST` `/nevisauth/oauth/introspect/{AuthorizationServerName}`

  Retrieves the state of a token for a given AuthorizationServer.

  See the [Token Introspection specification](https://tools.ietf.org/html/rfc7662#section-2.1) for details.

  * `AuthorizationServerName` (string, -)

    The name of the authorization server against which to validate the token (that is, the name of the respective AuthorizationServer AuthState).

* `POST` `/nevisauth/oauth/introspect/`

  Retrieves the state of a token for a given AuthorizationServer.

  See the [Token Introspection specification](https://tools.ietf.org/html/rfc7662#section-2.1) for details.

  :::info
  This endpoint can only be used when only one AuthorizationServer AuthState is configured in the RESTService
  :::
--------------------------------------------------------------------------------
Section: ### Request and response examples using cURL
* **Example 1 - Invalid refresh token**

  The following command line example queries nevisAuth. It asks whether the refresh token with value *2YotnFZFEjr1zCsicMWpAA* is valid for the *AuthorizationServer* named *authServer*. The server answers that the token is not valid.

  ```
  curl 'https://siven.ch:8991/nevisauth/oauth/introspect/authServer' -i -X POST \
    --insecure --cert /var/opt/keybox/public/node_keystore.pem:password \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    -d 'token=2YotnFZFEjr1zCsicMWpAA&token_type_hint=refresh_token'

  HTTP/1.1 200 OK
  Date: Mon, 08 Jul 2019 10:15:18 GMT
  Content-Type: application/json
  Content-Length: 17
  {"active": false}

  ```

* **Example 2 - Valid access token**

  The following command line example queries nevisAuth. It asks whether an access token is valid for the *AuthorizationServer* named *sivenAuthServer*. The client does not provide any information on the token type (there is no attribute *token_type_hint*). The server answers that the token is valid and provides some additional information (note that the output of the cURL command line is modified for the sake of clarity):

  ```

  curl 'https://siven.ch:8991/nevisauth/oauth/introspect/sivenAuthServer' -i -X POST \
    --insecure --cert /var/opt/keybox/public/node_keystore.pem:password \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    -d 'token=eyJlbmMiOiJBMjU2R0NNIiwiYWxnIjoiUlNBLU9BRVAtMjU2In0.eiIwgVmejF087iqtrXjQ-xvRByUVyNuiHpxZn5VUfKuW1U3NP8EtSjnGfrcYm7M-uzdaUxmOwAD_c_PerHjPEpERQ91uxCACPQiY23IyzJKaPp9QByRptZLdyd8cwSg4u5OBAq9R1RDO4vTdHpn5E8K7jmQILXnASC_s9DrHsy0.64RgOvcQgqz8Eoff.oKUt3euLvn9AUKuE6IIu62Pz2slX4X68_G6j48B7xb1Bjcti4wIfpuY0Sr8X6KU-miHOY6BTLVUg2hmkzHAX4Mu65HG98UgmiEnOmru5qnzWzXBqOxxUAKSgoo-VZAYrDblSjTDOIZ-Q3n2n_eYDtnh2_lGZEjbGuMRsHhQu-qWoO3I_PSRSh9_w-Aia8XItE0p1tGz4fD7AG8Ox0LQfnA_Lx2an76elVpJFF6ZAFHnR5U1r9DFuFGgBayEi2N8qHiyrSsr214SA_36vpraUaEqg1rKkkIAmt0_QNI9beMAp7HEU-8dUs6ovHniUVkvU-_NkaIuGsddwUjXwSFH0MH70bAP_Y_aTtL5SJa9TMVs7yy31pIg6NCg4OIBABgLlVAa1W3scEb5bXPNSR6O2fPnt0SURi0QRzRJlz778zWYzagqjhtGUoM6nKt1fYdCOwhgvXZajgZHQUBy4FGS_76WTYauXgAVaV_6XbRG4JM9FNZHK1TaiNJiiCu_jDUsQERu9JfLLOHRmB9JhTmLPAxh6Vcx4dd7dkYPH.gbcKRDPaXAGA3fKaXEu8uA'
  HTTP/1.1 200 OK
  Date: Mon, 16 Jul 2019 18:11:54 GMT
  Content-Type: application/json
  Content-Length: 243
  {
      "active": true,
      "client_id": "sdfo2992342335232",
      "username": "michel",
      "scope": "user:read user:write",
      "sub": "1231sdwraewerwee",
      "aud": "https://siven.ch/resource",
      "iss": "https://www.siven.ch",
      "exp": 1563295046,
      "iat": 1563294446
  }

  ```

## OAuth 2.0 token revocation service

The OAuth 2.0 token revocation service as defined in the [RFC 7009](https://datatracker.ietf.org/doc/html/rfc7009) is as follows:

> [...] allows clients to notify the authorization server that a previously obtained refresh or access token is no longer needed. This allows the authorization server to clean up security credentials.

nevisAuth provides this service out of the box. The resource, which is the HTTP client of the service, has to provide the name of the authorization server to be used to revoke the token. The same *AuthorizationServer* AuthState that generated the tokens is used to revoke them. The name of the *AuthorizationServer* AuthState is provided as a path parameter in the URL of the HTTP request.

The following list describes the OAuth 2.0 token revocation REST service:

* Class

  `ch.nevis.esauth.rest.service.tokenrevocation.TokenRevocationService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/oauth/revoke`

* Properties

  * `authstates` (string, -)`

    Comma-separated list of names of AuthorizationServer AuthStates that are exposed by the token revocation service. If this list does not include the name of a specific AuthorizationServer, the nevisAuth logs error, and does not start.

  * `authentication` (string {"BASIC"}, -)

    Space-separated list of methods that will be accepted for authenticating using the request header. For more information, see [RFC 7009](https://datatracker.ietf.org/doc/html/rfc7009#section-2.1). More info how to do authentication with token revocation service here.

```xml title="Example"
<RESTService name="tokenRevocation" class="ch.nevis.esauth.rest.service.tokenrevocation.TokenRevocationService" path="/oauth/revoke">
        <property name="authstates" value="AuthorizationServer1, AuthorizationServer2"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of the OAuth 2.0 token revocation service:

* `POST` `/nevisauth/oauth/revoke/{AuthorizationServerName}`

  Revokes a token of a given AuthorizationServer.

  See the [RFC 7009](https://datatracker.ietf.org/doc/html/rfc7009#section-2.1) for details.

  * `AuthorizationServerName` (string, -)

    The name of the authorization server against which to revoke the token (that is, the name of the respective AuthorizationServer AuthState).

* `POST` `/nevisauth/oauth/revoke/`

  Revokes a token of a given AuthorizationServer.

  See the [RFC 7009](https://datatracker.ietf.org/doc/html/rfc7009#section-2.1) for details.

  This endpoint can only be used when only **one** AuthorizationServer AuthState is configured in the RESTService

:::info

When multiple instances of nevisAuth having the same OAuth2/OIDC flow, you need to setup the MariaDB OOCDs to share revoked token(s) between instances.
:::

## JSON Web Key Set (JWKs)

The OAuth 2.0 JSON Web Key Set as defined in the [RFC 7517](https://datatracker.ietf.org/doc/html/rfc7517) is:

> [...] JWKs and JWK Sets are used in the JSON Web Signature [[JWS](https://datatracker.ietf.org/doc/html/rfc7517#ref-JWS)] and JSON Web Encryption [[JWE](https://datatracker.ietf.org/doc/html/rfc7517#ref-JWE)] specifications.

nevisAuth provides this service out of the box. The resource, which is the HTTP client of the service, has to provide the name of the authorization server to be used to expose the JWKs.

The following list describes the JWKs service:

* Class

  `ch.nevis.esauth.rest.service.jsonwebkey.JWKSService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/.well-known/jwks.json`

* Properties

  * `authstates` (string, -)

    Comma-separated list of names of AuthorizationServer  AuthStates that are exposed by the JWKs. If this list does not include the name of a specific [AuthorizationServer](../../authentication-plugins-and-authstates/oauth-2.0-and-openid-connect-plugins/authorization-server-and-open-id-connect-provider-plugins/authorizationserver.md), the nevisAuth logs error, and does not start.

```xml title="Example"
<RESTService name="jwks" class="ch.nevis.esauth.rest.service.jsonwebkey.JWKSService" path="/.well-known/jwks.json">
 <property name="authstates" value="AuthorizationServer1, AuthorizationServer2"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of the JWKs service:

* `GET` `/nevisauth/.well-known/jwks.json`

  Get JWKs of a given AuthorizationServer.

  See the [JWKs RFC](https://datatracker.ietf.org/doc/html/rfc7517) for details.

## OAuth 2.0 Authorization Server Metadata

The OAuth 2.0 Authorization Server Metadata as defined in the [RFC 8414](https://datatracker.ietf.org/doc/html/rfc8414) is:

> [...] The metadata for an authorization server is retrieved from a well-known location as a JSON [[RFC8259](https://datatracker.ietf.org/doc/html/rfc8259)] document, which declares its endpoint locations and authorization server capabilities.

nevisAuth provides this service out-of-the-box. The resource, which is the HTTP client of the service, must provide the name of the authorization server and necessary endpoints to be used to expose the Authorization Server Metadata.

The following list describes the Authorization Server Metadata:

* Class

  `ch.nevis.esauth.rest.service.oauthdiscovery.DiscoveryService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/.well-known/openid-configuration`

* Properties

  * `authstate` (string, -)

    AuthState that contains the information to be used by the Authorization Server Metadata (e.g: scopes, grant_type, response_type,...). If it is not the name of an existing AuthorizationServer, the nevisAuth will log error and won't start.

  * `issuer` (string: URI, -)

    The authorization server's issuer identifier, which is a URL that uses the "https" scheme and has no query or fragment components. If this property is not set, the Issuer will be automatically extracted from the AuthorizationServer AuthState. If no issuer is found neither from the AuthorizationServer nor from the configuration, nevisAuth will show an error.

  * `authorizationEndpoint` (string: URI, -)

    URL of the authorization server's authorization endpoint [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749). This is REQUIRED unless no grant types are supported that use the authorization endpoint (authorization code grant and implicit grant are using authorization endpoint).

  * `tokenEndpoint` (string: URI, -)

    URL of the authorization server's token endpoint [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749). This is REQUIRED unless only the implicit grant type is supported.

  * `registrationEndpoint` (string: URI, -)

    URL of the authorization server's OAuth 2.0 Dynamic Client Registration endpoint. (more info)

  * `jwksService` (string, -)

    Name of the [JWKs Service](#json-web-key-set-jwks). If this property is configured, the jwks_uri will be automatically generated using the nevisAuth root context.

  * `jwksUri` (string: URI, -)

    URL of the authorization server's JWK Set [JWK](https://datatracker.ietf.org/doc/html/rfc8414#ref-JWK) document. If this property is not set, the jwks_uri will be automatically extracted from the jwksService configured above.

  * `revocationService` (string, -)

    Name of the [Revocation Service](#oauth-20-token-revocation-service). If this property is configured, the revocation_endpoint will be automatically generated using the nevisAuth root context.

  * `revocationEndpoint` (string: URI, -)

    URL of the authorization server's OAuth 2.0 revocation endpoint [RFC7009](https://datatracker.ietf.org/doc/html/rfc7009). If this property is not set, the revocation_endpoint will be automatically extracted from the revocationService configured above.

  * `introspectionService` (string, -)

    Name of the [Introspection Service](#oauth-20-token-introspection-service). If this property is configured, the _introspection_endpoint_ will be automatically generated using the nevisAuth root context.

  * `introspectionEndpoint` (string: URI, -)

    URL of the authorization server's OAuth 2.0 introspection endpoint [RFC7662](https://datatracker.ietf.org/doc/html/rfc7662). If this property is not set, the introspection_endpoint will be automatically extracted from the introspectionService configured above.

  * `parService` (string, -)

    Name of the [PAR Service](https://github.com/nevissecurity/docs.nevis.net/blob/integration/2023-05-IS-release/docs/nevisauth/setup-and-configuration/components/rest-service-api/rest-service-implementations.md#pushed-authorization-requests-service). If this property is configured, the _pushed_authorization_request_endpoint_ will be automatically generated using the nevisAuth root context.

  * `parEndpoint` (string: URI, -)

    URL of the authorization server's OAuth 2.0 Pushed Authorization Request Endpoint [RFC9126](https://datatracker.ietf.org/doc/html/rfc9126). If this property is not set, the _pushed_authorization_request_endpoint_ will be automatically extracted from the parService configured above.

  * `userinfoEndpoint` (string: URI, -)

    URL of the authorization server's [OAuth 2.0 UserInfo Endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo).

```xml title="Example"
<RESTService name="discovery" class="ch.nevis.esauth.rest.service.oauthdiscovery.DiscoveryService" path="/.well-known/openid-configuration">
 <property name="authstate" value="AuthorizationServer"/> 
 <property name="issuer" value="https://nevis.net"/>
 <property name="authorizationEndpoint" value="https://nevis.net/auth"/>
 <property name="tokenEndpoint" value="https://nevis.net/token"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of the Authorization Server Metadata service:

* `GET` `/nevisauth/.well-known/openid-configuration`

  Get metadata of a given AuthorizationServer.

  See the [Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414)

## Pushed Authorization Requests Service

The OAuth 2.0 Pushed Authorization Requests as defined in the [RFC 9126](https://datatracker.ietf.org/doc/html/rfc9126) is:

> [...] JWT-Secured Authorization Request (JAR) [RFC9101](https://datatracker.ietf.org/doc/html/rfc9101) provides solutions for the security challenges by allowing OAuth clients to wrap authorization request parameters in a Request Object, which is a signed and optionally encrypted JSON Web Token (JWT) [RFC7519](https://datatracker.ietf.org/doc/html/rfc7519).

To cope with the size restrictions, JAR introduces the request_uri parameter that allows clients to send a reference to a Request Object instead of the Request Object itself.

nevisAuth provides this service out of the box. The resource, which is the HTTPS client of the service, has to provide the name of the authorization server to be used to expose the PAR.

The following list describes the PAR service:

* Class

  `ch.nevis.esauth.rest.service.par.PARService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/par`

* Properties

  * `authstate` (string, -)

    Name of AuthorizationServer AuthStates that is using for PAR. 
If this property does not include the name of a specific [AuthorizationServer](../../authentication-plugins-and-authstates/oauth-2.0-and-openid-connect-plugins/authorization-server-and-open-id-connect-provider-plugins/authorizationserver.md), the nevisAuth logs error, and does not start.

  * `lifetime` (duration in seconds, 90)

  Maximum duration in seconds for PAR request URI to be valid. The config value from 5 to 600.

  * `authentication` (string {"BASIC"}, -)

    Space-separated list of methods accepted for authentication using the request header.

```xml title="Example"
<RESTService name="par" class="ch.nevis.esauth.rest.service.par.PARService" path="/par/">
 <property name="authstate" value="AuthorizationServer1"/>
</RESTService>
```

The following list shows the HTTPS methods available for the REST interface of the PAR service:

* `POST` `/nevisauth/par`

  Send Authorization Data to PAR Service of a given AuthorizationServer.

  See the [PAR](https://datatracker.ietf.org/doc/html/rfc9126) for details.

## Session management and termination API

Using the Session management and termination API, you can terminate and remove one or more sessions in nevisAuth. Using the API does not trigger logout in federation use cases.

:::info Experimental feature
API and implementation are likely going to change in the future.
:::
--------------------------------------------------------------------------------
Section: #### Terminated session polling
Whenever nevisAuth terminates a session, nevisProxy is not automatically aware. To keep nevisProxy in the loop, the *EnablePollTerminatedCalls* has to be set to *true* in the *Esauth4ConnectorServlet* in the nevisProxy instances connected to the nevisAuth instance. By default, the feature is turned off.

## Session Management REST Endpoint

* Class

  `ch.nevis.esauth.rest.service.session.ManagementService`

* Logging

  `REST`

* Default base path

  `/management/session`

```xml title="Example"
<RESTService name="ManagementService" class="ch.nevis.esauth.rest.service.session.ManagementService" />
```

The following list shows the HTTP methods available for the REST interface of the nevisAuth session management service:

* `DELETE` `/nevisauth/management/session/<sessionId>`

  Deletes session based on sessionId.

  HTTP status codes:
  * `204` OK
  * `400` Missing input
  * `404` Missing / invalid session
  * `500` Error

* `DELETE` `/nevisauth/management/session`

  Query parameter: `attributeName`, `attributeValue`

  Deletes sessions based on provided query parameters.

  * `attributeName` has to match the attributeName used for Session indexing, defaults to `loginId`
  * `attributeValue` the value used to find sessions

  HTTP status codes:
  * `204` OK
  * `400` Missing input
  * `404` Missing / invalid session
  * `500` Error
--------------------------------------------------------------------------------
Section: ### authstate-integration.md
---
sidebar_position: 600
---

# Plugin Deployment

In the [Quickstart](quickstart) chapter, we already learned how to integrate a simple custom AuthState into our nevisAuth instance. This chapter provides more insight into how to deal with specific situations.

## Plugin Packaging

A nevisAuth Plugin should bring all its required dependencies, except the `nevisauth-authstate-api`.
By default the `pom.xml` generated by the Maven archetype uses the [Apache Maven Assembly Plugin](http://maven.apache.org/plugins/maven-assembly-plugin) to create a `ZIP archive` file containing the Plugin `jar` file and all its transitive `compile` and `runtime` dependencies in the subfolder `lib`.
Additionally, the files `README`, `LICENSE`, and `NOTICE` are included if they exist in the project base directory.

## Plugin Classpaths

nevisAuth plugins are loaded when the nevisAuth instance starts. The AuthEngine checks specific paths on the filesystem to find the configured AuthStates and their dependencies.

The paths that are investigated by the AuthEngine are configured in the nevisAuth configuration:

```xml
<AuthEngine name="AuthEngine"
    classPath="/opt/nevisauth/plugin:/var/opt/nevisauth/default/plugin"
    classLoadStrategy="PARENT_FIRST"
    useLiteralDictionary="true"
    addAutheLevelToSecRoles="true"
    compatLevel="none"
    inputLanguageCookie="LANG"
>
```

The plugins that are delivered with the nevisAuth package are located in the `/opt/nevisauth/plugin` directory.
We recommend putting instance-specific plugins into the instance directory: `/var/opt/nevisauth/<instance-name>/plugin`.

The classloading strategy defines how the classes are discovered by the classloader. With `PARENT_FIRST`, the AuthEngine classloader first checks whether the class has already been loaded by a parent classloader (which is the container's classloader). With `PARENT_LAST`, the AuthEngine classloader will try to discover and load the class, but delegate the class loading to the parent if it cannot be found.

Different strategies have different effects. With `PARENT_FIRST`, you reduce the amount of the MetaSpace memory of the Java virtual machine. However, if you are using libraries that also exist in the web application server classpath it is recommended using `PARENT_LAST` to avoid classloading conflicts.

## Classpath Conflict Resolution

Similar to the problem of loading classes from the AuthEngine's classpath first vs. loading classes from the web application server's classpath first, different plugins may also produce library conflicts.
Therefore, it is sometimes necessary to configure a classpath on the AuthState to avoid library dependency confusion. This will lead to a separate classloader being used for that AuthState (an AuthState classloader).

The problem can be illustrated as follows:

Imagine an AuthState A, which depends on library_v1 and an AuthState B, which depends on library_v2. If the libraries contain the same classes but implement different functionality or method signatures, nevisAuth may fail during runtime because AuthState A and B expect a
different behavior of the library.

This can be solved by configuring a separate classloader per AuthState, as the following example shows:

```xml
<AuthState name="UseridPasswordState" class="ch.example.UseridPasswordFileAuthState"
        classPath="/var/opt/nevisauth/default/plugin/auth-state-example-1.0-SNAPSHOT"
        classLoadStrategy="PARENT_LAST">
    <ResultCond name="ok" next="AuthDone"/>
    <ResultCond name="failed" next="AuthError" />
    <property name="passwordFileLocation" value="/var/opt/nevisauth/default/conf/passwords.txt"/>
</AuthState>
```

In this case, the `ZIP archive` `auth-state-example-1.0-SNAPSHOT.zip` containing the AuthState `ch.example.UseridPasswordFileAuthState` must be extracted into the directory `/var/opt/default/plugin`.
Due to the `PARENT_LAST` class loading strategy, the directory `/var/opt/nevisauth/default/plugin/auth-state-example-1.0-SNAPSHOT` will be consulted first before checking the AuthEngine's classpath for loading classes.

Note that with some libraries you cannot have multiple jar entries on various classloading levels. (either the same or different version)
Such example is the Slf4j API using log4j2 as implementation. Define such dependencies in your dependency list as provided.
--------------------------------------------------------------------------------
Section: ### GUI Generation
As a general rule, a GUI is always generated if an AuthState responds with an `AUTH_CONTINUE` or `AUTH_ERROR` response.
nevisAuth does not generate GUIs itself. Instead, it builds a _GUI descriptor_ which is sent back to the client.
If the client is nevisProxy, it in turn forwards it to nevisLogRend, the login renderer application.
The login renderer then responds with an HTML document that implements the GUI described in the GUI descriptor. This rendered GUI will then be forwarded by nevisProxy to the end-user's user agent.

The GUI descriptor is configured in the AuthState configuration as part of the response element of an AuthState.
It guides the login renderer to create a certain GUI by describing the content, but not the layout, of the GUI.

The following code snippet shows an example of the GUI descriptor as part of an AuthState configuration.

Refer to [Response generation](/nevisauth/setup-and-configuration/components/authentication-engine/authentication-processing-authstates-and-state-flow#response-generation) for more detailed information.

```xml
<Gui name="LoginPage" label="UIDPWDialog">
  <GuiElem name="isiwebuserid" type="text" label="Username" value="" />
  <GuiElem name="isiwebpasswd" type="pw-text" label="Password" value="" />
  <GuiElem name="submit" type="button" label="Login" value="Login" />
</Gui>
```

## Technology Stack

nevisAuth is a web application written in Java. We are using the following technologies:

| Technology       | Version | Description                                                                                                                                                                          |
|------------------|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Linux            |         | Operating System                                                                                                                                                                     |
| Java             | 17      | Compile and runtime environment. As a runtime environment, newer Java versions can (and are) used, because the JVMs are typically backwards compatible.                              |
| Java Servlet API | 5       | The Java Servlet API specifies how HTTP requests are received and how HTTP responses are sent back to the client. nevisAuth implements filters and servlets to handle such requests. |
| Jax-WS           | 4.x     | The web service stack used to retrieve SOAP web service requests and respond with SOAP responses.                                                                                    |
| Jax-RS           | 3.x     | The web service stack used to accept and respond to REST web service calls.                                                                                                          |
--------------------------------------------------------------------------------
Section: ### response-fields.md
| Attribute | Type | Description |
| --------- | ---- | ----------- |
| `statusCode` | `Number` | UAF status code for the authentication operation, see UAF Status Codes. |
| `description` | `String` | Detailed message containing a user-friendly description of the authentication result. This is the stringified representation of the JSON described in the [Authentication Server Response]. |
| `additionalTokens` | `Array` | New authentication or authorization token(s) for the client that are not natively handled by HTTP transport. |
| `location` | `String` | If present, indicates to the client web application that it should navigate to the URI contained in this field. |
| `postData` | `String` | If present, and in combination with `location`, indicates the client should POST the contents to the specified location. |
| `newUAFRequest` | `String` | Server may return a new UAF protocol message with this field. This might be used to supply a fresh request to retry an operation in response to a transient failure, to request additional confirmation for a transaction, or to send a deauthentication message in response to a permanent failure. |
--------------------------------------------------------------------------------
Section: ### response-fields.md
| Attribute | Type | Description |
| --------- | ---- | ----------- |
| `statusCode` | `Number` | UAF status code for the operation, see UAF Status Codes. If the client provided a `dispatchTarget` in the `SendUAFResponse` context, the validation of the FIDO UAF contents was successful, but the dispatch target could not be created, nevisFIDO will return a UAF status code `UNACCEPTABLE_CONTENT` (1498). |
| `description` | `String` | Detailed message containing a user-friendly description of the registration result and the dispatch target ID (if one was created). This is the stringified representation of the JSON described in the [Registration Server Response]. |
| `additionalTokens` | `Array` | New authentication or authorization token(s) for the client that are not natively handled by HTTP transport. |
| `location` | `String` | If present, indicates to the client web application that it should navigate to the URI contained in this field. |
| `postData` | `String` | If present, and in combination with `location`, indicates the client should POST the contents to the specified location. |
| `newUAFRequest` | `String` | Server may return a new UAF protocol message with this field. This might be used to supply a fresh request to retry an operation in response to a transient failure, to request additional confirmation for a transaction, or to send a deregistration message in response to a permanent failure. |
--------------------------------------------------------------------------------
Section: ### Technical architecture
<img className="boxed" src={require('./assets/68816657.png').default} alt="System overview"/>

* *Client tier*: Interface for user interaction, either via the web application or via SOAP calls from a third-party component.
* *Access tier*: Secure reverse proxy (nevisProxy), single point of entry for applications that enables a physical separation of networks. Manages user authentication and authorization in cooperation with the authentication service.
* *Presentation tier*: Visualization of data from business tier.
* *Business tier*: Implementation of the business logic as a set of services and modules.
* *Resource tier*: Persistency management via a directory service (LDAP) or a database (for example MySQL or Oracle).

## Installation and Integration
--------------------------------------------------------------------------------
Section: ##### Content-only view
The nevisWorkflow GUI is designed to be embedded into other web applications on the browser-side within either an iframe or a pop-up window. For proper embedding, it's usually desired to show only the *task form* or *process starting form* without the surrounding menu items and page header. This can be achieved by inserting the "contentonly" part within the URL.

```
/neviswf/contentonly/showTask.xhtml?taskId=1652
```
--------------------------------------------------------------------------------
Section: ##### Failover/Load balancing
Web service endpoint properties (e.g., *ws.adminservice.endpoint, ws.adminservice.clientcert.endpoint*) take a comma-separated list of URLs. If load balancing is *true*, then requests to web services are issued to different endpoints, chosen by a round-robin algorithm. However, after a logged-in user made his/her first request to one of the endpoints, subsequent requests go to the same endpoint afterwards (sticky session).

When a web service call fails due to connection error, the next web service endpoint is taken from the list. Connection to the failed endpoint is retried after a defined retry timeout interval.
--------------------------------------------------------------------------------
Section: #### With manual DB upgrade
:::info Not recommended!
Both Activiti as well as nevisWorkflow DB upgrades might require running a piece of java code packed with the new version of nevisWorkflow. This Java code can handle tasks that cannot be done with pure SQL scripts. For example prefilling a new column with some user information where the information comes from NevisIDM. For Activiti, nevisWorkflow have no control over this requirement. Upgrading the DB manually might cause an inconsistent DB.
:::

1. Install new RPM package of nevisWorkflow

 Install RPM of new version

 ```
 rpm -i neviswf-newversion.rpm
 ```

2. Stop nevisWorkflow

 ```
 neviswf stop
 ```

3. Upgrade database by running the DB upgrade scripts manually
   1. Find the upgrade scripts in the folder `/opt/neviswf/resources/database/sql/<database-type>/upgrade`
      * Prior to nevisWF 1.4.1.0, the database upgrade files are shipped in the neviswf-db-version.tar.gz file*
   2. Find the current version of Activiti and nevisWorkflow database in the ACT_GE_PROPERTY table:
      * *schema.version* – for Activiti
      * *neviswf.schema.version* – for nevisWorkflow
   3. Upgrade the Activiti tables by gradually executing the upgrade scripts starting from the version number in the database to the new Activiti version number. The Activiti DB upgrade scripts can be found in `/sql/<db-type>/upgrade/org/activiti/db/upgrade` folder.
   4. Execute the different components in the following order:
      1. *upgradestep.513.to.515.engine.sql*
      2. *upgradestep.513.to.515.history.sql*
      3. *upgradestep.513.to.515.identity.sql*
   5. Upgrade the nevisWorkflow tables by gradually executing the upgrade scripts found in `/sql/oracle/upgrade/ch/adnovum/neviswf/datamodel/upgrade` in a similar manner.
   6. To keep track of the current database version and for the sake of a later automatic upgrade to work, the `neviswf.schema.version` property is stored in `ACT_GE_PROPERTY` table. For versions prior to `1.2.1.0` this property does not exist, so it first needs to be inserted.

    ```
    INSERT INTO ACT_GE_PROPERTY(NAME_,VALUE_,REV_)
    VALUES('neviswf.schema.version','1.2.1.0', 1);
    ```

      * The `neviswf.schema.version` property is automatically updated, when the nevisWorkflow database upgrade script is executed.
      * The neviswf.schema.version does always correspond to the newest nevisWorkflow version number. The property indicates the last nevisWorkflow version number, where the database has changed (not including Activiti tables).
4. Start nevisWorkflow
   * Start nevisWorkflow with the `start` command. After the new RPM install, the new version of the web application will be deployed.

    ```
    neviswf start
    ```

## Configuration - Workflows

Workflows are standard Activiti workflows. Documentation can be found on the homepage of Activiti.org.
--------------------------------------------------------------------------------
Section: #### nevisIDM
The following table lists the parameters related to nevisIDM.

| Parameter name | Description |
| --- | --- |
| ws.adminservice.endpoint |  Mandatory. Comma-separated list of endpoint URIs of the nevisIDM admin service used. |
| ws.adminservice.wsdl.resource | WSDL resource of the nevisIDM admin service. Default: `/wsdl/nevisidm_adminservice_v1.wsdl`. |
| ws.adminservice.class | Class used as nevisIDM admin service client. Default: `ch.adnovum.nevisidm.ws.services.v1.AdminServiceV1`. |
| ws.adminservice.request.timeout | Request timeout when communicating with the nevisIDM admin service. Default: `120000`. |
| ws.adminservice.connect.timeout | TCP connection timeout when establishing the connection to the nevisIDM admin service. Default: `15000`. |
| ws.adminservice.token.encoding | Forwarded SecToken encoding options Possible values: `automatic` or `null`: Lets the framework encode the password property (re-encode in UTF-8). `forward`: Forwards the whole HTTP authorization header unchanged. You may need to set the TokenEncoding attribute of the Ninja configuration. `character encoding`, for example: `UTF-8`: Converts basic auth header bytes as encoding then converts to Base64.  |
| nevisidm.cache.enabled | Enables caching of nevisIDM results. Used to optimize the performance and reduce the load on nevisIDM. Default: `true`. |
| nevisidm.cache.maxentries | Number of entries stored in the nevisIDM result cache. This number should correspond to the expected number of simultaneous users. Default: `100`. |
| nevisidm.cache.ttl | Lifetime of an entry in the nevisIDM result cache in milliseconds. Default: `60000`. |
| ws.adminservice.loadbalancing | Enable round-robin load balancing between endpoints, when more endpoints are defined. Default: false. |
| ws.adminservice.clientcert.endpoint | Comma-separated list of endpoint URIs of the nevisIDM admin service that use client certificate-based authentication. This endpoint is used by the technical user. |
| ws.adminservice.clientcert.keystore | Path to JKS keystore to be used for two-way SSL, when the *ws.adminservice.clientcert.endpoint* is defined. If this configuration is empty, then `javax.net.ssl.keyStore` is used. Default: empty. |
| ws.adminservice.clientcert.keystore.password | Password for JKS file defined in *ws.adminservice.clientcert.keystore* Default: empty. |
| ws.adminservice.clientcert.alias | Alias of the certificate in `javax.net.ssl.keyStore` used by technical user to connect *ws.adminservice.clientcert.endpoint*. |
| ws.selfadminservice.endpoint | Comma-separated list of endpoint URIs of the nevisIDM self admin service used. |
| ws.selfadminservice.wsdl.resource | WSDL resource of the nevisIDM self admin service. Default: `/wsdl/nevisidm_adminservice_v1.wsdl`. |
| ws.selfadminservice.class | Class used as nevisIDM self admin service client. Default: `ch.adnovum.nevisidm.ws.services.v1.SelfAdminServiceV1`. |
--------------------------------------------------------------------------------
Section: ### Storing passwords in nevisCred
Passwords appearing in neviswf.properties can be stored in nevisCred. Simply use the following syntax where applicable:

```
password.property=neviscred://<passwordId>
```

where `<passwordId>` is the same as it is stored in nevisCred. Example:

```
mail.server.password=neviscred://smtpPassword
```

Prerequisite is to have the nevisCred client available on the same machine where nevisWorkflow is installed. If ncclient is in the default location *(/opt/neviscred/bin/ncclient),* no configuration is needed. To set non-default location, add the following argument to vmargs.conf:

```
-Dch.nevis.neviscred.client=/neviscred/client/location/ncclient
```

Another valid prefix for passwords is *"plain://".* This is only used to mark in the configuration that the password is in plain text. It is the same as without the prefix.

To mark a plain text password, use the following syntax:

```
password.property=plain://<plainTextPassword>
```

where `<plainTextPassword>` is the password itself. For example:

```
mail.server.password=plain://smtpPassword
```

is exactly the same as:

```
mail.server.password=smtpPassword
```

## Operation and Administration - Embedded container deployment

From version 1.11.0.0 on, nevisWorkflow can be deployed in the following ways:

| Deployment Type | Remarks | State |
| --- | --- | --- |
| Wildfly | nevisWorkflow deployed as a web application. | Stable |
| GlassFish | nevisWorkflow deployed as a web application. | Stable |
| Standalone | nevisWorkflow deployed as a web application including an embedded container. | Stable, recommended deployment type |

The following sections describe the configuration of the standalone deployment type.
--------------------------------------------------------------------------------
Section: #### Adnwildfly instance parameters gathering
The recommended way to migrate from containers to standalone is to use the property file. The same property file can be used to create the standalone instance. See the following sample property file:

```script title="Sample property file"
db_type=oracle
db_user_app_password=unwf02
db_user_app_username=******
db_user_adm_username=unwf01
db_user_adm_password=******
db_connection_host=acme.adnovum.ch
db_connection_port=8884
db_connection_db_name=ACME_DB
db_connection_pool_id=neviswfDs
db_connection_url=jdbc:oracle:thin:@acme.adnovum.ch:8884:ACME_DB
db_admin_connection_pool_id=neviswfAdminDs
ws.adminservice.endpoint=https://acme.adnovum.ch:8080/nevisidm/services/v1_39/AdminService
JVM_KEYSTORE_PASSWORD=******
JVM_TRUSTSTORE_PASSWORD=******

```

:::info
From version 1.13.x and above, standalone deployment only uses the property `db_connection_url` to establish a database connection instead of the properties `db_connection_host, db_connection_port` and `db_connection_db_name`. This is to provide more flexibility to the user for further advanced connection configuration, such as load balancing, connection attributes, etc.
:::

If there is no property file, it is suggested to create one, as all settings can be gathered in one place. Also, you can reuse the file later to create the instance.

The */var/opt/neviswf/.setup.defaults* file of the last created instance is a good starting point. As reference, use `/var/opt/adnglassfish/.setup.<instance_name>`  or `/var/opt/adnwildfly/.setup.<instance_name>`. Those files contain all the settings used to create the instance.

On instance creation, it is adviced gathering the property values in the following order:

1. The package defaults
2. The provided property file
3. The properties provided on the command line

This means that first the package defaults will be considered, then the values from the given property file (if any) and finally the properties provided on the command line (if any).
--------------------------------------------------------------------------------
Section: ##### Using the property file during the instance creation
Once you have the property file, you can start with the instance creation. Eexecute one of the following commands:

```
neviswf inst create <new_instance_name> <property_file_location> WF_DEPLOY_TYPE="standalone" NEVISWF_SERVER_URL="<neviswf endpoint>"
```

Some notes:

* It is important to set *WF_DEPLOY_TYPE* correctly to create an **standalone** instance.
* The *NEVISWF_SERVER_URL* parameter is mandatory and specifies whether HTTP or HTTPS has to be used to access the nevisWorkflow web application and the host and port. To find out the endpoint of nevisWorkflow (*neviswf*) on *adnwildfly* - which has to be reused for the new instance - executing the command `neviswf <instance name> status`.

```
neviswf inst create <instance> <property file location> WF_DEPLOY_TYPE="standalone" NEVISWF_SERVER_URL="<neviswf endpoint>"
```
--------------------------------------------------------------------------------
Section: ### glossary.md
---
sidebar_position: 500
---

# Glossary

This page is an alphabetical list of terms and concepts that are useful in understanding Nevis Authentication Cloud functionality. Use the sidebar on the right to browse the page, or your internet browser's **find** (`Ctrl+F` / `⌘+F`) function to search for specific terms.

## Access Key

Access keys are API tokens that allow you to communicate with the Authentication Cloud API. Each access key is a unique identifier that identifies an application or user when making an API request.

## API

API stands for Application Programming Interface. APIs are mechanisms that enable two software components to communicate with each other using a set of definitions and protocols. In the context of APIs, "application" refers to any software with a distinct function. "Interface" can be thought of as a contract of service between two applications. This contract defines how the two communicate with each other using requests and responses.

## Assertion

When a user wants to log into a service, the server sends a challenge and the authenticator signs it with a key pair previously registered to that service. This creates the assertion. The format of the assertion is always the same regardless of the device being used.

## Attestation

Attestation is the process of verification of a generated key pair that is specific to a device. Once the key pair is verified (attested) it can be used to cryptographically prove that the device is genuine. 

## Authentication

Authentication is the process of verifying a user through their registered authenticator before allowing access to a resource. This ensures only those with authorized credentials gain access to secure systems.

The process involves the server providing the authenticator with a challenge, which they cryptographically sign with the key pair created in registration, and then return to the server to confirm authenticity. 

## Biometrics

Biometrics are measurements of physical characteristics that uniquely identify individuals. This includes fingerprint mapping, facial recognition, retina scans etc. Using technologies that can create and compare biometric measurements with very high precision, biometrics can be used to identify and securely authenticate users.

## Cross-platform authenticators

A type of passkey authenticator also referred to as roaming authenticators, it is a portable hardware device that can be used to verify a user's identity across multiple platforms, examples are a security key or a mobile device.

Cross-platform devices allow a user to authenticate on new devices, where a credential does not exist. Therefore allowing users to authenticate into a service even when there existing workstation is lost or corrupted.

## Challenge

A challenge, in terms of challenge-response authentication is a security step, where the client that wants to access a system has to provide evidence, that they have the right to access. The challenge can take the form of a password prompt, a request for biometric authentication, or even a CAPTCHA request.

## Discoverable credentials

Discoverable credentials is a mechanism used in passkeys, that allows a user to authenticate into a service without the need to enter a username or password, providing a significant ease of use advantage to the user.

When used, a user is provided a list of the available, discovered credentials on their authenticator, from which they can select the one to be used.

This mechanism supports the feature Conditional UI or autofill.

## FIDO

FIDO is an abbreviation for Fast Identity Online, and refers to the FIDO Alliance, an open-industry association that promotes passwordless authentication and device attestation solutions. The FIDO UAF and FIDO2 specifications are industry standards that define secure, passwordless authentication solutions.

## Introspection

Token introspection is a mechanism that allows resource servers to get information about access tokens. Through this, resource servers can check the validity of access tokens and discover other information, such as which user and which scopes are associated with the token.

## Mobile app

In the context of Nevis Authentication Cloud, mobile app refers to an app on a mobile device that bears Authentication Cloud functionality, that is used for secure authentication. This can either be a customer application with a Nevis Mobile Authentication SDK integration, or a custom-branded Access App provided by Nevis.

## Multi-device passkeys

Multi device passkeys (MDC) are credentials that can be moved and synced between devices. This means that if a user has multiple devices, they can use the built in authenticator to validate a credential regardless if they are using the device that was used to create the credential.

This offers a higher degree of usability as users can utilize any of their devices to authenticate into services without having to individually enroll each one. MDC’s may also be shared between different users. For example you can AirDrop your passkey to another person in the case of shared accounts.

MDC’s are commonly embedded into devices like a mobile phone, or laptop. Platforms that support MDCs are Windows Hello, Apple iCloud Keychain, and Google password manager.

## One-time password (OTP)

A one-time password is a machine-generated security code that is used as a second factor in traditional multi-factor authentication scenarios. OTPs are typically provided via SMS messages, and they are only valid for a given time period, after which they expire.

SMS OTPs have the advantage of allowing multi-factor authentication that relies on only cell-service on the user device. On the other hand, they provide poor protection in scenarios, when an attacker is in posession of a device.

## Passkey

A passkey is a digital credential, tied to a user account and a website or application. Passkeys allow users to authenticate without having to enter a username or password, or provide any additional authentication factor. This technology aims to replace legacy authentication mechanisms such as passwords.

When a user wants to sign in to a service that uses passkeys, their browser or operating system helps them select and use the right passkey. The experience is similar to the way saved passwords work. To make sure only the rightful owner can use a passkey, the system asks them to unlock their device. This may be performed with a biometric sensor (such as a fingerprint or facial recognition), PIN, or pattern.

## Passkey autofill

The passkey autofill feature is intended to provide an experience for passkeys similar to that of traditional autofill to ease the user experience, and transition users to passwordless authentication.

Passkey autofill integrates passkey options directly into the browser's familiar autofill suggestions. When a user taps on a username field on a website that supports passkeys, the browser shows the available passkeys for that service. The passkey can then be selected, and the browser automatically completes the sign-in process using the device's authentication mechanism e.g. Face ID or fingerprint.

This streamlined approach eliminates the need to search for passkeys or remember which one to use, making passkey authentication more user-friendly and encouraging wider adoption for enhanced security.

## Payment Service Directive 2 (PSD2)

The Revised Payment Services Directive (PSD2) is a European directive introduced in 2009 with the aim to create a more open, competitive, and secure payments landscape in the EU and EAA.

To improve competition in the payments landscape, Payment Services Directive (PSD2) allows non-bank financial institutions to access bank data and bank accounts. This is based on the idea that users own the data and accounts rather than banks, and so they can make the decisions on who should have access to their data. 

## Phishing

Phising is an attempt to steal sensitive information, such as passwords or credit-card numbers in order to gain access to protected resources, or sell the acqiured information. In a phising attempt, the attacker typically impersonates a reputable source to trick users into revealing sensitive information.

## Platform authenticators

Platform authenticators are built-in security features on devices like smartphones and laptops that provide strong authentication without the need for external hardware. They leverage the device's inherent capabilities, such as fingerprint sensors, facial recognition cameras, or PIN codes, to verify the user's identity. Common examples include Apple's Touch ID and Face ID, Windows Hello, and the fingerprint scanners found on many Android devices. These authenticators offer a convenient and secure way to access devices and online services, eliminating the need for passwords and providing a seamless user experience.

## Public key cryptography

Public key cryptography is a method of encrypting or signing data using two encryption keys: a public key, that is available for anyone to use, and a private key, that is kept secret. The public key is used for encryption and signature verification, while the private key is used for decryption and signing. The main benefit of the method is that no secret is stored on the server side, which eliminates the security issues associated with server-side data breaches.

## Push bombing

Push bombing is a multi-factor authentication (MFA) fatigue attack, in which the attacker triggers multiple login attempts to a service, using leaked passwords against a traditional multi-factor authentication setup involving a password plus a second factor. The attacker types in the stolen password, which triggers a push notification on the user authenticator device to complete the authentication using the second factor.

The method is often successful, because - especially in work scenarios - users have to re-authenticate to various services many times a day, which can create a habit of approving second-factor push messages without too much thought.

## Registration

Authenticator registration is the process of setting up a new authenticator, such as a security key or an authenticator app, to allow a user to authenticate using FIDO methods to access a service.

This process involves linking the authenticator to an account through a simple process, such as scanning a QR code on a secondary device or initiating the process from the primary device. Once registered, the authenticator can be used to verify the identity of the user and provide a strong authentication mechanism to access their account.

## Relying party

In the context of Passkeys, the relying party is the web application or service that offers the option for users to log in using passkeys.

## Response signing

Response signing is a security measure to ensure the authenticity of information received from a web application server API. This is an additional measure for when requests to the API are made on devices that you do not control. In practice, the signature is sent along with the API response, and in case an attacker modifies the response body, the signature gets broken. This can be detected in your application backend, so that you can block it.


## REST API

REST API is an interface that two computer systems use to exchange information securely over the internet. REST stands for Representational State Transfer, and it is a software architecture with defined conditions on how the API should work. Using the REST API architecture brings several benefits. An important one is scalabilty. Systems that use REST APIs optimize client server interactions. REST APIs are stateless, meaning that servers do not retain past request data. This reduces server load. RESTful APIs are also independent of the programming languages used to create the server applications.

## REST API requests and responses

The basic function of a REST API is similar to browsing the internet. An API call happens through the following steps:

1. The clients contacts the server through sending a request when it needs a resource. The client uses the correct format for the request, as explained in the API documentation of the web application.
2. The server performs the authentication of the client to make sure it has permission to make the request.
3. If the authentication is successful, the server receives and processes the request.
4. The server returns a response to the client. This response contains information about whether the request was successful, and if yes, then also the data requested.

## SDK

SDK stands for Software Development Kit, and it is a set of software-building tools in one installable package. An SDK can be used by developers to easily integrate their apps with third party services.

## Single-device passkeys

Single-device passkeys or single device credentials (SDCs) are passkeys that are bound to a specific device, meaning they can only be used to sign in from the device from which they were created. This enhances security by preventing the credential from being copied or transferred to another device.

While they offer strong protection against phishing and account takeovers, their limitation lies in the lack of flexibility for users who frequently switch between devices.

## Strong Customer Authentication (SCA)

Strong Customer Authentication (SCA) is a European regulatory requirement to reduce fraud and make online and contactless offline payments more secure. It applies to all customer-initiated online and contactless offline payments within the EU, EEA and the UK.

SCA requires authentication to employ at least two of the following three elements: 

* Something the user knows, such as a pin or password
* Something the user has, such as a mobile device or a hardware token
* Something the user is, meaning biometric measurements 

## Token

An authentication token is a computer-generated code that is used to verify the identity of a user. The use of tokens allows users access to resources, without having them re-enter their login credentials each time they visit. Auth tokens are encrypted and machine-generated. They can expire and can be revoked, which provides better protection against attack scenarios like brute-force attacks or stolen passwords.

## Transaction signing

Transaction signing is a security measure, where a user authenticates again when reviewing the transaction they are making. This marks it as valid and authentic. In terms of secure authentication, this means that when committing to a sensitive transaction - such as transferring money through a banking application, the user is asked to authenticate using their pre-registered secure authentication method. This ensures that no sensitive transaction is processed without the explicit permission of the authenticated user, even if the user has already authenticated for login to the application.

## Two-factor authentication (2FA)

Two-factor authentication (2FA) is a security measure that requires two separate forms of authentication to allow access to a resource. Two-factor authentication can be used to strengthen the security of a system.

## User presence

With user presence (UP), the intent is to ensure that a user is physically present and in control of the authenticator. For example, an external hardware device used for authentication might have a touch sensor that cannot be controlled by software. The primary function of user presence is to provide some indication that a user was physically in control of the device during an authentication or registration ceremony.

## User verification

User verification (UV) serves to ensure that the person authenticating to a service is in fact who they say they are for the purposes of that service. The relying party directs the authenticator to perform user verification, the authenticator performs user verification locally and signals to the application whether user verification was successful. User verification can take various forms, such as password, PIN, fingerprint, face scan, etc. The point is for the user to not only prove physical possession of the device, but ownership of it.

## WebAuthn

WebAuthn, or the Web Authentication API is a specification written by W3C and FIDO as part of the FIDO2 framework. The API allows servers to register and authenticate users without passwords, instead using public key cryptography. With this method, servers can integrate with the strong authenticators built into devices, such as Windows Hello or apple's Touch ID or Face ID, and leverage them for easy and secure authentication.
--------------------------------------------------------------------------------
Section: ### azure-ad-b2c-integration.md
---
sidebar_position: 5
---

import Vimeo from '../../../../src/components/Vimeo';

# Azure AD B2C integration overview

In this tutorial, you learn how to extend your Azure AD B2C (AD B2C) signup and login process with Authentication Cloud, so that your Customers can use passwordless authentication.

Authentication Cloud offers passwordless signup and login for websites and web applications with your Access App. The Access App is branded to match your corporate identity, is built using a hardened SDK, and is FIDO UAF-certified. The solution complies with the Payment Services Directive 2 (PSD2) requirements and provides Strong Customer Authentication (SCA).

**Time to complete the tutorial**: If you are also setting up your AD B2C properties, it takes about 2 hours to complete this tutorial.

:::note Azure AD B2C tutorials
Our Azure AD B2C documentation is based on the official [Microsoft Azure Active Directory B2C documentation](https://learn.microsoft.com/en-us/azure/active-directory-b2c/). In our tutorials, you can find links to the relevant Microsoft pages. In case of discrepancies between the two, refer to the official Microsoft documentation.
:::

Get a glimpse with the following screencast of how cool the passwordless experience for the customers of Muvonda is, once it is integrated to Authentication Cloud.

<Vimeo src="https://player.vimeo.com/video/483106262?badge=0&autopause=0&player_id=0&app_id=58479&h=6f2123e58e" title="Azure AD B2C Biometric Login"/>
--------------------------------------------------------------------------------
Section: ### register-web-app.md
---
sidebar_position: 35
---

import Vimeo from '../../../../src/components/Vimeo';

# Register a web application

<Vimeo src="https://player.vimeo.com/video/694831438?badge=0&autopause=0&player_id=0&app_id=58479&h=6f2123e58e" title="Registering a Web Application"/>

1. Make sure you are using the directory that contains your Azure AD B2C tenant.
2. In the Azure portal, search for and select **Azure AD B2C**.
3. Select **App registrations**, and then select **New registration**.
4. Enter a **Name** for the application. For example, `webapp1`.
5. Under **Supported account types**, select **Accounts in any identity provider or organizational directory (for authenticating users with user flows)**.
6. Under **Redirect URI**, select **Web**, and then enter `https://jwt.ms` in the URL textbox.
7. Under **Permissions**, select the **Grant admin consent to openid and offline_access permissions** checkbox.
8. Select **Register**.

For a web application, you need to create an application secret. The client secret is also known as an application password. The secret is used by your application to exchange an authorization code for an access token.

1. On the **Azure AD B2C - App registrations** page, select the application you created, in our example, `webapp1`.
2. In the left menu, under **Manage**, select **Certificates & secrets**.
3. Select **New client secret**.
4. Enter a description for the client secret in the **Description box**. For example, `clientsecret1`.
5. Under **Expires**, select a duration for which the secret is valid, and then select **Add**.
6. Record the secret Value for use in your client application code. This secret value is never displayed again after you leave this page. You use this value as the application secret in your application code.

Connect the `webapp1` app with the `https://jwt.ms/` app for testing a user flow or custom policy by enabling the implicit grant flow in the app registration:

1. In the left menu, under **Manage**, select **Authentication**.
2. Under **Implicit grant and hybrid flows**, select both the **Access tokens (used for implicit flows)** and **D tokens (used for implicit and hybrid flows)** checkboxes.
3. Select **Save**.

For more information, see [Tutorial: Register a web application in Azure Active Directory B2C](https://docs.microsoft.com/en-us/azure/active-directory-b2c/tutorial-register-applications?tabs=app-reg-ga) in the Microsoft Azure documentation.
--------------------------------------------------------------------------------
Section: ### temenos-registration.md
---
sidebar_position: 10
sidebar_label: Registration with Temenos
---

# Register an authenticator with Temenos

If a user already exists in the customer-side system, you can initiate an authenticator registration that creates the same user in Infinity Fabric and Authentication Cloud and creates a new FIDO UAF authenticator tied to this user. On this page, you can find two main registration use cases: registration using only a mobile banking app, and registration using a mobile banking app and your web banking application.

## Registration using mobile banking app

In this use case, a mobile banking app is used to register an authenticator. The following step list shows the high-level workflow:

1. The user opens the mobile banking app and enters their username and password.
2. The user chooses to register a second-factor authenticator.
3. The user receives an SMS with a code and enters the code into the mobile banking app.
4. The mobile banking app registers the new authenticator with the help of Nevis Mobile Authentication SDK and Authentication Cloud.
6. The mobile banking app receives the registration confirmation.

The following diagram shows a more detailed example of an end-to-end sequence of registering a new PIN or biometric authenticator through a mobile banking app. The diagram includes customer, Temenos, and Authentication Cloud functions, with the following color coding:

* <font color="#F0AC00">Yellow</font>: Temenos functions
* <font color="#168CA9">Blue</font>: Nevis Mobile Authentication SDK and Authentication Cloud functions

:::note Nevis Mobile Authentication SDK
The SDK is integrated into the mobile banking app.
:::

Authentication Cloud functions include API calls to initiate the registration, verify a status token, and optionally, to get the `username`. For more information about these calls, see [Register a mobile app](../../api-doc/api-use-cases/mobile-app/register-mobile-app) and [Retrieve a user](../../api-doc/api-use-cases/manage-users-and-authenticators/retrieve-user).

```plantuml
@startuml

skinparam sequenceMessageAlign direction
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

actor "End-user" as user
participant "Mobile banking app" as app
participant "Infinity Fabric" as infinity
participant "Authentication Cloud" as authcloud
user -[#F0AC00]> app: Enter username and password
app -[#F0AC00]> infinity: Send user credentials
infinity -[#F0AC00]> infinity: Verify credentials
infinity --[#F0AC00]> app: Return result: verification successful
infinity -[#F0AC00]> infinity: Generate SMS challenge
infinity -[#F0AC00]> user: Send SMS
user -[#F0AC00]> app: Enter SMS code
app -[#F0AC00]> infinity: Forward the code
infinity -[#F0AC00]> infinity: Verify the code
infinity -> authcloud: Initiate registration
authcloud --> infinity: Registration initiated
infinity --[#F0AC00]> app: Send the dispatch token and \nthe code verification response
app -> app: Forward the dispatch token to the Nevis Mobile Authentication SDK
app -> app: Register PIN or biometric authenticator, \nand generate public-private key pair
app -> authcloud: Initiate authenticator registration using the dispatch token and the public key
authcloud --> app: Authenticator registered
app -[#F0AC00]> infinity: Send status token to verify the registration
infinity -> authcloud: Check token validity with the status endpoint
authcloud --> infinity: Return token status response
group Optional
    infinity -> authcloud: Get ""username"" by ""userId""
    authcloud --> infinity: Return ""username""
end
infinity --[#F0AC00]> app: Authenticator registration completed

@enduml
```

## Registration using a mobile banking app and a web application

In this use case, both the web banking application and a mobile banking app are used to register an authenticator. The following step list shows the high-level workflow:

1. The user opens the web banking application and enters their username and password.
2. The user chooses to register a second-factor authenticator.
3. The web banking application presents a QR code to start the registration.
4. The user reads the QR code with the mobile banking app.
5. The mobile banking app registers the new authenticator with the help of Nevis Mobile Authentication SDK and Authentication Cloud.
6. The web banking application sends the registration confirmation to the mobile banking app.

The following diagram shows a more detailed example of an end-to-end sequence of registering a new FIDO UAF authenticator using a mobile banking app and your web application. The diagram includes customer, Temenos, and Authentication Cloud functions, with the following color coding:

* <font color="#6F7C80">Gray</font>: Customer functions
* <font color="#F0AC00">Yellow</font>: Temenos functions
* <font color="#168CA9">Blue</font>: Nevis Mobile Authentication SDK and Authentication Cloud functions

:::note Nevis Mobile Authentication SDK
The SDK is integrated into the mobile banking app.
:::

Authentication Cloud functions include API calls to initiate the registration, verify a status token, and optionally, to get the `username`. For more information about these calls, see [Register a mobile app](../../api-doc/api-use-cases/mobile-app/register-mobile-app) and [Retrieve a user](../../api-doc/api-use-cases/manage-users-and-authenticators/retrieve-user).

```plantuml
@startuml

skinparam sequenceMessageAlign direction
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

actor "End-user" as user
participant "Mobile banking app" as app
participant "Web banking \napplication frontend" as webapp
participant "Infinity Fabric" as infinity
participant "Authentication Cloud" as authcloud
user -[#6F7C80]> webapp: Enter username and password
user -[#6F7C80]> webapp: Initiate registering a new authenticator
webapp -[#F0AC00]> infinity: Send registration request
infinity -> authcloud: Initiate registration
authcloud --> infinity: Return QR code and status token
infinity --[#F0AC00]> webapp: Forward QR code
webapp -> webapp: Display QR code
app -[#6F7C80]> webapp: Read QR code
app -> app: Forward the token to the SDK
app -> app: Register PIN or biometric authenticator, \nand generate public-private key pair
app -> authcloud: Store public key
authcloud --> app: Return result: public key saved
webapp -[#F0AC00]> infinity: Poll for status check
infinity -> authcloud: Check token validity with status endpoint
authcloud --> infinity: Return token status
group Optional
    infinity -> authcloud: Get ""username"" by ""userId""
    authcloud --> infinity: Return ""username""
end
infinity --[#F0AC00]> webapp: Confirm successful registration
@enduml
```
--------------------------------------------------------------------------------
Section: ### test-access-app.md
---
sidebar_position: 30
---

import Vimeo from '../../../src/components/Vimeo';

# Test the Access App

Your Authentication Cloud instance comes with a single-page test web application so that you can discover the basic functionality of the Authentication Cloud using the Access App.

<Vimeo src="https://player.vimeo.com/video/674778995?badge=0&autopause=0&player_id=0&app_id=58479&h=6f2123e58e" title="Azure AD B2C Biometric Login"/>

## Install the test Access App
--------------------------------------------------------------------------------
Section: ### qr-codes-overview.md
---
sidebar_position: 30
---

import Vimeo from '../../../src/components/Vimeo';

import REUSE from '/docs/reusable-md/_registration-and-authentication-flow.md'
import REUSE01 from '/docs/reusable-md/_usernameless-info.md'

# QR codes

In the branded Access App, we use QR codes to register users and authenticators, and also as a secure and versatile transaction authentication method.

<img className="centered" src={require('../assets/auth_method_1-QR_code.png').default} alt="QR code login"/>

## QR codes overview

QR code based transaction approval is one of the most reliable authentication methods as it does not rely on communication with a specific device. This makes it ideal in cases where more convenient mechanisms, such as push notifications are not acceptable.

We recommend QR codes as an authentication method, if the following are true for your business:

- You want secure authentication to work with the widest range of devices.
- You do not want to rely on the availability of push services on user devices.
- You want the option for usernameless authentication.
- You do not want to invest in major technical development.

For authentication with QR codes, you do not rely on specific device capabilities, or settings on the user side. Your users can register any Android or iOS device as an authenticator, and use them to authenticate transactions.

When the web application calls for authentication, it presents a QR code. Users scan the QR code using the Access App on one of their registered authenticator devices, and sign the transaction with either a PIN, or biometrics.

:::info
QR code based requests, like push messages, can also be fetched directly from a user device. For more information, see [Fetch ongoing operations](./push-notifications-overview#fetch-ongoing-operations)
:::

<Vimeo src="https://player.vimeo.com/video/803022968" title="QR Code based authentication"/>

## Registration and authentication flow

<REUSE
authmethod="QR codes"
/>

1. [Register a mobile app](../api-doc/api-use-cases/mobile-app/register-mobile-app)
2. [Authenticate with QR codes](../api-doc/api-use-cases/mobile-app/authenticate-QR-code)

<REUSE01
authmethod="QR codes"
/>

Read more about QR codes in the [QR Code](../../nevisaccessapp/features/channels/qr_code) section of the Access App documentation.
--------------------------------------------------------------------------------
Section: ### FIDO2-prerequisites.md
---
sidebar_position: 20
sidebar_label: Prerequisites
---

# FIDO2 integration prerequisites

To get started, you need the following information available:

* Instance ID
* Access Key

For more information on the instance ID and the Access Key, see the [Developer documentation](../../api-doc/api-doc.md).

## Relying party

Before you can integrate WebAuthn, provide the following information about your web application, the relying party:

**Relying party name**: The name of your choosing, for example: `Siven Chocolate Factory`.

**Relying party ID**: The domain or part of the domains of your web applications that you plan to register and authenticate users on, for example: `siven.ch`.

**Origins**: The list of the origins of your web application. Each origin has to be explicitly allowed, for example:

* `https://www.siven.ch`
* `https://login.siven.ch:9443`
* `https://sso.login.siven.ch`

As WebAuthn can only be used from a [secure context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts), the origins must be one of the following:

* A local address: `http://localhost`.
* An `https://` address on condition that the application provides a valid SSL certificate.

:::info

The **Relying party ID** must be a subset of all the origins you intend to use.

For example, the `siven.ch` **Relying party ID** matches the `https://login.siven.ch:9443` origin, but not the `https//bank.ch/` origin.

:::

## Autofill UI prerequisites

To enable the autofill UI feature for passkeys, add the `username` and `webauthn` value to any existing `autocomplete` annotations on the username input field as follows:

```
<div>
  <label for="username">Username:</label>
  <input name="username" id="loginform.username"
         autocomplete="username webauthn">
</div>
```

For more information, see [passkeys.dev](https://passkeys.dev/docs/use-cases/bootstrapping/).

[Contact Nevis support](https://portal.nevis.net) with the relying party information so that we can configure your Authentication Cloud instance.
--------------------------------------------------------------------------------
Section: ### architecture-overview.md
---
sidebar_position: 15
sidebar_label: Architecture overview
---

# FIDO2 architecture overview

<img className="boxed" src={require('../../assets/fido2_architecture.png').default} alt="FIDO2 architecture overview"/>

**User device**: A FIDO2-capable authenticator device, such as a laptop or mobile device which runs the web browser.

**Authenticator**: Allows the use of biometric methods, for example fingerprint scanning or face detection to authenticate.

Authenticators can be the following:

* Platform authenticators, built into the user device.
* Roaming authenticators, connected to the user device with USB, BLE, or NFC connections.

**Relying party** The relying party is the web application to secure using WebAuthn, to register and authenticate users. The relying party has a frontend and a backend part. The backend has to communicate with the Authentication Cloud API to start the registration or the authentication.

**Authentication Cloud FIDO2 JavaScript solution**: Authentication Cloud provides a JavaScript-based solution that can be used to handle the communication between the [WebAuthn API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API) and the Authentication Cloud API. The frontend of the relying party must include a JavaScript solution to connect to the Authentication Cloud API. For more information about the JavaScript solution, see [Register a FIDO2 authenticator](../../api-doc/api-use-cases/fido2/direct-communication/register-fido2-authenticator/#create-a-webauthn-credential-with-the-javascript-solution) and [Authenticate with FIDO2](../../api-doc/api-use-cases/fido2/direct-communication/authenticate-with-fido2.md/#authenticate-with-the-webauthn-credential-using-the-javascript-solution).
--------------------------------------------------------------------------------
Section: ### glossary.md
---
sidebar_position: 60
---

# Glossary

| **Term**         | Description                                                                                                                                                                                                                                                                                                                 |
|------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FIDO2            | FIDO2 enables users to leverage common devices to easily authenticate to online services in both mobile and desktop environments. The FIDO2 specifications are the World Wide Web Consortium’s (W3C) Web Authentication (WebAuthn) specification and FIDO Alliance’s corresponding Client-to-Authenticator Protocol (CTAP). |
| WebAuthn         | FIDO2 Web Authentication - a core component of FIDO Alliance’s FIDO2 set of specifications - is a web-based API that allows websites to update their login pages to add FIDO-based authentication on supported browsers and platforms.                                                                                      |
| CTAP             | The FIDO2 Client to Authenticator Protocol is complementary to WebAuthn. It enables an external authenticator, such as a security key or a mobile phone, to work with browsers that support WebAuthn, and also to serve as an authenticator to desktop applications and web services.                                       |
| Ceremony         | The concept of a ceremony is an extension of the concept of a network protocol, with human nodes alongside computer nodes and with communication links that include user interface(s), human-to-human communication, and transfers of physical objects that carry data.                                                     |
| Relying Party    | The entity whose web application utilizes the Web Authentication API to register and authenticate users.                                                                                                                                                                                                                    |
| Relying Party ID | A valid domain string that identifies the WebAuthn Relying Party on whose behalf a given registration or authentication ceremony is being performed.                                                                                                                                                                        |
--------------------------------------------------------------------------------
Section: ### Authenticator
Credentials belonging to the user are managed by an [authenticator](/configurationguide/fido2-concept-and-integration-guide/overview/browsers-and-authenticators). The WebAuthn Relying Party interacts with it through the client device by using the Relying Party JavaScript Application, which internally relies on the WebAuthn API provided by the client browser.

## Relying party backend

The relying party backend characterizes the **group of components** which in combination act together as the Relying Party backend of a FIDO2 Relying Party client. In the context of FIDO2, communication between a FIDO Client and a FIDO Server *always* occur via the Relying Party JavaScript Application and Nevis backend. In Nevis FIDO2, this backend includes the necessary Nevis components described below and the protected backend entity named *Web application* in the Nevis FIDO2 architecture figure.
--------------------------------------------------------------------------------
Section: #### nevisProxy
Towards the client-facing edge of the system, the **nevisProxy** component serves as the perimeter server. It's able to protect web applications from unauthenticated access and ensures that authentication takes place before requests are passed to those web applications. In Nevis FIDO2, nevisProxy is configured to accept requests according to the FIDO2 protocol and forwards them to the authentication subsystem. As in all Nevis setups, additional functions of nevisProxy are web application firewall, session management (single sign-on), and reverse proxy functionality like routing and rerouting of requests to downstream components. In Nevis FIDO2, nevisProxy will route FIDO2 HTTP requests to nevisAuth, which forwards them to nevisFIDO. The latter two form the authentication subsystem.
--------------------------------------------------------------------------------
Section: ### Example
1. The user opens the web application in the browser.
2. The browser tries to access the web application to display information to the user.
3. Nevis detects that the browser is not authenticated. It asks the user to provide his login identifier to authenticate.
4. The user provides his login information.
5. The login information is sent to the Nevis backend.
6. After identifying the user, Nevis asks the user to provide FIDO2 authentication.
7. The user authenticates using the FIDO2 Authenticator available on the client device.
8. The signed FIDO2 assertion is sent to the Nevis backend for validation.
9. The user is now authenticated and able to access the web server.
10. The user is now logged in and able to access the web application.

<img className="boxed" src={require('../../assets/fido2-auth/fido2-authentication-example.png').default} alt="FIDO2 Authentication Example"/>

## Technical flow

The technical flow in the following figure explains the component interaction in detail. The step numbers in the next figure do not correlate with the simplified example above.

:::note
The following flow is a simple compact example. Depending on requirements, changes or different approaches might be required.
The key fix points are:

* WebAuthn API in the browser.
* FIDO2 HTTP API in nevisFIDO.
* nevisAuth must be aware of the status of the FIDO2 authentication.
:::

```plantuml
@startuml
skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  BorderColor #CDD2D4
  BackgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

skinparam database {
   BorderColor #12677C
   BackgroundColor #168CA9
}



title FIDO2 Authentication

actor User as User

box "Client Device"
 participant "Browser" as BR #499985
 participant "FIDO2 Authentication\nClient Javascript" as JS #499985
end box

box "Relying Party Backend" #CDD2D4
    participant nevisProxy as P
    participant nevisAuth as A
    participant nevisLogRend as L
    participant nevisFIDO as F
    database nevisIDM as I
    participant "Relying Party\nWeb Application" as relyingPartyWebApp #SteelBlue
end box

User -> BR: Open browser
autonumber
BR -> P: Access protected resource
P -> A: Require authentication
activate A
    rnote over A #ECECEC
        Fido2AuthState
    end note
A -> L: Request rendering login page
deactivate A
activate L
L --> BR: Login page with FIDO2 Authentication Client Javascript
deactivate L

== Initialise Authentication ==

User -> BR: Provide username

BR -> JS: authenticate(username)
activate JS


JS -> P: username
autonumber stop
P -> A
autonumber resume

group HTTP API: Authentication Options Service
activate A
    rnote over A #ECECEC
        Fido2AuthState
    end note
A -> F: ""ServerPublicKeyCredentialGetOptionsRequest""

activate F
end group

F -> I: get Fido2 credentials\n based on username
activate I
autonumber stop
I --> F:
autonumber resume
deactivate I
    hnote over F
        FIDO2 config in nevisfido.yml <size:20><&file></size>
    end note
F -> F: Generate challenge
autonumber stop
F --> A: ""ServerPublicKeyCredentialGetOptionsResponse""
autonumber resume
deactivate F
A --> JS: ""ServerPublicKeyCredentialGetOptionsResponse""
deactivate A

== Authentication ==

JS -> BR: ""navigator.credentials.get""
BR -> User: Authenticate
activate User
User --> BR
deactivate User
    hnote over BR
        private <size:20><color:red><&key></color></size>
    end note
BR -> JS: Assertion

group HTTP API: Authentication Service
JS -> P: POST ""ServerPublicKeyCredential""\nto /nevisfido/fido2/assertion/result
P-> F
activate F
end group

F -> F: Get session using challenge
F -> I: Get Fido2Credential by ID
activate I
autonumber stop
I --> F
autonumber resume
deactivate I
hnote over F
    authenticator (public <size:20><color:green><&key></color></size>)
    session <size:20><&hard-drive></size>
    rp config <size:20><&file></size>
end note
F -> I: Update Fido2Credential (SignCounter)
activate I
autonumber stop
I --> F: response
autonumber resume
deactivate I
F -> F: Update session status
F --> JS: ""ServerResponse""
deactivate F
deactivate A

== Solidify Authentication at nevisAuth ==

JS -> P: Continue authentication with the\n""fido2SessionId"" in the header
activate A
autonumber stop

P -> A
autonumber resume
rnote over A #ECECEC
    Fido2AuthState
end note
A -> A: Parse and compare ""fido2SessionId""\nwith the stored value

group HTTP API: Status Service
activate F
A -> F: Verify authentication status for ""fido2SessionId""
F -> F: Fetch session for ""fido2SessionId""
F --> A: ""success""
end group
deactivate F
A -> A: ""ok"" result condition
A -> A: ""AuthDone""
A --> P: SecToken
deactivate A
P --> BR: HTTP 302 Redirect

autonumber stop
deactivate A

== Access Relying Party Services ==

BR -> P: Access Relying Party service\n(<color:red>""cookie""</color>)
P -> relyingPartyWebApp: Providing access to Relying Party service
activate relyingPartyWebApp
 relyingPartyWebApp --> BR
deactivate relyingPartyWebApp
BR --> User
deactivate BR
|||
@enduml
```

1. User accesses protected resource.
2. nevisProxy detects the user is not yet authenticated to access the protected resource, dispatches to nevisAuth.
3. nevisAuth enters the authentication flow with Fido2AuthState, which requests rendering a login page, that includes FIDO2 Authentication Client Javascript.
4. A login page is loaded in the browser, alongside the FIDO2 Authentication Client Javascript.
5. User provides its username.
6. The FIDO2 Authentication Client Javascript's `authenticate(username)` method is called.
7. The username is posted to nevisAuth.
8. Fido2AuthState recognizes it received a `username` and posts a `ServerPublicKeyCredentialGetOptionsRequest` to nevisFIDO, initiating FIDO2 Authentication.
    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/fido2/attestation/options`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/authentication-services/authentication-options-service)    
9. nevisFIDO queries the FIDO2 credentials from nevisIdm.
10. Challenge is generated and the `ServerPublicKeyCredentialGetOptionsResponse` is built.
11. The `ServerPublicKeyCredentialGetOptionsResponse` is returned to the FIDO2 Authentication Client Javascript.
12. The FIDO2 Authentication Client Javascript initiates an authentication using the received Options response via the WebAuthn API in the browser.
13. Dialog presented to the user by the browser to unlock the private key.
14. The user authenticates.
15. The WebAuthn API generates an assertion and returns it to the FIDO2 Authentication Client Javascript.
16. The FIDO2 Authentication Client Javascript posts the `ServerPublicKeyCredential` with the assertion to nevisFIDO directly.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/fido2/assertion/result`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/authentication-services/authentication-service)

17. nevisProxy forwards the request to the nevisFIDO endpoint, which is unprotected.
18. nevisFIDO session lookup. (This session is independent of the nevisAuth session)
19. nevisFIDO queries the FIDO2 credentials from nevisIdm.
20. The FIDO2 credential is updated with a new SignCounter, to prevent cloned authenticators. (the counter is **not** increased by a predefined number)
21. FIDO2 session is updated to reflect the current status.
22. ServerResponse is returned stating the status of the FIDO2 authentication.
23. The FIDO2 Authentication Client Javascript uses the `fido2SessionId` in the header to access nevisAuth and signal that the Authentication ceremony has been succeeded.
24. nevisAuth receives the `fido2SessionId` header and compares it with the one it stashed into the session.
25. `Fido2AuthState` verifies the status of the ceremony by accessing the status service of nevisFIDO.

    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/fido2/status`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/status-service)

26. Session lookup in nevisFIDO.
27. nevisFIDO returns the found status `success`.
28. The `Fido2AuthState` finishes processing by setting the result condition `ok` and nevisAuth continues the authentication flow based on the result.
29. An `AuthDone` AuthState is reached.
30. nevisAuth returns to nevisProxy with a `SecToken`.
31. nevisProxy redirects the client based on the result to the original resource, which can now be accessed by the authenticated client.

## Integration
--------------------------------------------------------------------------------
Section: ### usernameless-authentication.md
---
sidebar_position: 12
---

# Usernameless Authentication

## Description

A user is trying to access a web application, for example an e-banking application, which requires authentication. The user must provide the required authentication with a FIDO2 capable authenticator. Furthermore, the web application is protected by Nevis (notably nevisProxy and nevisAuth).
--------------------------------------------------------------------------------
Section: ### Example
1. The user opens the browser to connect to a web application.
2. The browser attempts to connect to a web application protected by Nevis.
3. Nevis detects that the user is not authenticated.
4. The browser sends usernameless login information to the Nevis backend.
5. Nevis asks the user to provide FIDO2 authentication using one of its discoverable credentials.
6. The user selects one of its discoverable credentials and authenticates using the FIDO2 Authenticator available on its device.
7. The signed FIDO2 assertion is sent to the Nevis backend for validation.
8. The assertion contains user related information and cryptographic material, which Nevis uses to identify and authenticate the previously unknown user.
9. The user is now logged in and able to access the web application.

<img className="boxed" src={require('../../assets/fido2-auth/fido2-usernameless-authentication-example.png').default} alt="FIDO2 Authentication Example"/>

## Integrate
The technical flow as well as the integration of usernameless authentication is the same as [FIDO2 Authentication](/configurationguide/fido2-concept-and-integration-guide/use-cases/authentication), with notable exceptions:

1. [The requirement of discoverable credentials](#discorverable-credentials). The presence of discoverable credentials can be ensured by enforcing that during registration the `ServerPublicKeyCredentialCreateOptionsRequest` the FIDO2 Registration Client Javascript sends to nevisFIDO contains `residentKey: "required"`. This forces the authenticator to create a credential on the client-side, or otherwise abort the registration.
2. The `authenticate(username)` method of FIDO2 Authentication Client Javascript must be called with an empty string, as in `""`. The identification of the user is then accessible over the Status Service of nevisFIDO. To access this endpoint, the fido2SessionId is needed, which is returned in the `ServerPublicKeyCredentialGetOptionsRequest` the FIDO2 Authentication Client Javascript received upon starting authentication.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/fido2/status`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/status-service)
--------------------------------------------------------------------------------
Section: ### registration-webapp.md
---
sidebar_position: 6
---

# Registration with Web Application

In this use-case, the FIDO2 Registration is integrated into the web application, where the FIDO2 credentials will be used at. For a generic description and prerequisits, please see [Registration](/configurationguide/fido2-concept-and-integration-guide/use-cases/registration).

## Technical Flow

The initial authentication depends on the custom integration as well as the existing means of authentication the end user possesses. Thus, the initial authentication steps are not explained in detail but only referenced.

:::note
The following flow is a simple compact example. Depending on requirements, changes or different approaches might be required.
The key fix points are:

* WebAuthn API in the browser.
* FIDO2 HTTP API in nevisFIDO.
:::

```plantuml
@startuml
skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  BorderColor #CDD2D4
  BackgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

skinparam database {
   BorderColor #12677C
   BackgroundColor #168CA9
}

title FIDO2 Registration

actor User as User

box "Client Device"
 participant "Browser" as BR #499985
 participant "FIDO2 Registration Client Javascript" as JS #499985
end box

box "Relying Party Backend" #CDD2D4
    participant nevisProxy as P
    participant nevisAuth as A
    participant nevisLogRend as L
    participant nevisFIDO as F
    participant "Relying Party\nWeb Application" as WebApp #SteelBlue
    database nevisIDM as I
end box

User -> BR: Open browser


== Legacy Authentication ==

ref over P, A, JS, BR, User, L, I: Authenticate at Nevis using a legacy credential (e.g. a password), to access the Web Application 

== Initialise Registration ==

autonumber
BR -> WebApp: Access web application
activate WebApp
WebApp -> BR: Web application with ""FIDO2 Registration Client Javascript""
deactivate WebApp
activate BR
User -> BR: Clicks to register FIDO2
BR -> JS: FIDO2 Registration Javascript Client runs\n(<color:red>""cookie""</color>)
activate JS

group HTTP API: Registration Options Service
JS -> P: POST ""ServerPublicKeyCredentialCreationOptionsRequest""\nto /nevisfido/fido2/attestation/options
activate P
P -> P: Delegate the SecToken
autonumber stop
P -> F
deactivate P
autonumber resume



activate F
end group


F -> I: get Fido2 credentials\n based on username
activate I
autonumber stop
I --> F:
autonumber resume
deactivate I
    hnote over F
        FIDO2 config in nevisfido.yml <size:20><&file></size>
    end note
F -> F: Generate challenge
autonumber stop

F --> P
P --> JS: ""ServerPublicKeyCredentialCreationOptionsResponse""

== Registration ==

autonumber resume
JS -> BR: ""navigator.credentials.create()""
BR -> User: Confirm
activate User
User --> BR: Authorize
deactivate User
    hnote over BR
        Generate key material
        private <size:20><color:#BF3666><&key></color></size>
        public <size:20><color:#499985><&key></color></size>
    end note
BR -> JS: Attestation object containing <size:20><color:#499985><&key></color></size>

group HTTP API: Registration Service
autonumber resume
JS -> P: POST ""ServerPublicKeyCredential"" to /nevisfido/fido2/attestation/result
autonumber stop
P -> F
end group

autonumber resume
activate F
F -> F: Get session using challenge
F -> F: Validate registration
hnote over F
    public <size:20><color:#499985><&key></color></size>
    session <size:20><&hard-drive></size>
    rp config <size:20><&file></size>
end note
F -> I: Store <size:20><color:#499985><&key></color></size> as FIDO2Credential
activate I
autonumber stop
I --> F: response
autonumber resume
deactivate I
F -> F: Update session status
F --> JS: ""ServerResponse""
deactivate F
JS --> JS: Error handling
deactivate A
JS -> BR: Return to the Web Application
deactivate JS
@enduml
```

1. The user accesses a Web Application after authenticating at Nevis with a legacy credential (a password for example).
2. The Web Application loads into the browser, with it the FIDO2 Registration Client Javascript.
3. The user initiates FIDO2 Registration on the GUI of the Web Application.
4. The Web Application calls into the FIDO2 Registration Client Javascript.
5. The FIDO2 Registration Client Javascript posts the `ServerPublicKeyCredentialCreationOptionsRequest` to the Registration Options Service of nevisFIDO, which is exposed by nevisProxy.

   **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/fido2/attestation/options`

   **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/authentication-services/authentication-options-service)
6. nevisProxy delegates the SecToken into the request, which then will be parsed by nevisFIDO.
7. nevisFIDO maps the username into a user in nevisIDM, then queries the credentials of the user.
8. Challenge is generated and the `ServerPublicKeyCredentialCreationOptionsResponse` is built, then returned.
9. The FIDO2 Registration Client Javascript receives the `ServerPublicKeyCredentialCreationOptionsResponse` and initiates registration with it at the Browser's WebAuthn API.
10. Dialog presented to the user by the browser to confirm the credential creation.
11. The user approves the credential creation.
12. The WebAuthn API generates the keys and returns an attestation to the FIDO2 Registration Client Javascript.
13. IDO2 Registration Client Javascript assembles then posts a `ServerPublicKeyCredential` to the nevisFIDO REST API that is exposed by nevisProxy.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/fido2/attestation/result`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/registration-services/registration-service)
14. nevisFIDO session lookup. 
15. Incoming request validated according to the WebAuthn specification.
16. nevisFIDO stores the FIDO2 credential in nevisIDM, such that it is related to the username.
17. FIDO2 session is updated to reflect the current status.
18. `ServerResponse` is returned stating the status of the FIDO2 ceremony. At this point the FIDO2 registration is completed.
19. The FIDO2 Registration Client Javascript logs the errors if necessary.
20. The FIDO2 Registration Client Javascript returns to the Web Application, which may proceed.

## Integration
--------------------------------------------------------------------------------
Section: ### Overview
The following diagram illustrates the integrated flow, as well as the main points of configuration.

<img className="boxed" src={require('../../../assets/fido2-auth/fido2-registration-webapp.drawio.png').default} alt="FIDO2 Registration with web application"/>
--------------------------------------------------------------------------------
Section: ### Disclaimer
The guide assumes the Nevis components nevisProxy, nevisFIDO and nevisIDM are already installed and setup in some configuration. It is also assumed that the web application of the relying party is operational and is protected by Nevis.
--------------------------------------------------------------------------------
Section: ### Integrate FIDO2 Registration with a Web Application
1. Copy the Javascript files and integrate them into your web application as you see fit.

    <details>
    <summary>FIDO2 Registration Client Javascript</summary>

    ```javascript title='fido2_registration.js'
    async function attestation(options) {
        try {
            const credential = await navigator.credentials.create({
                "publicKey": options
            });
            const requestBody = {
                id: credential.id,
                type: credential.type,
                response: {
                    clientDataJSON: base64url.encode(credential.response.clientDataJSON),
                    attestationObject: base64url.encode(credential.response.attestationObject)
                }
            };

            await fetch("/nevisfido/fido2/attestation/result", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody)
            });
        } catch (error) {
            console.error("Error while submitting WebAuthn attestation:", error);
        }
    }

    async function register(username, displayName) {
        if (!username) {
            console.error("Invalid username");
        }
        if (!displayName) {
            console.error("Invalid displayName");
        }
        if (!isWebAuthnSupportedByTheBrowser()) {
            console.error("WebAuthn is not supported by the browser!");
            return;
        }

        const request = {
            username,
            displayName,
            authenticatorSelection: {
                residentKey: "required",
                authenticatorAttachment: "platform",
                userVerification: "required"
            },
            attestation: "direct"
        };

        try {
            const response = await fetch("/nevisfido/fido2/attestation/options", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(request)
            });

            const options = await response.json();
            options.user.id = base64url.decode(options.user.id);
            options.challenge = base64url.decode(options.challenge);
            if (options.excludeCredentials != null) {
                options.excludeCredentials = options.excludeCredentials.map(({
                    id,
                    ...rest
                }) => ({
                    ...rest,
                    id: base64url.decode(id)
                }));
            }
            if (options.authenticatorSelection.authenticatorAttachment === null) {
                options.authenticatorSelection.authenticatorAttachment = undefined;
            }
            await attestation(options);
        } catch (error) {
            console.error("Error during FIDO2 registration:", error);
        }
    }
    ```
    </details>

    <details>
    <summary>Base64url encoding library</summary>

    ```javascript title='/var/opt/nevislogrend/&lt;instance&gt;/data/applications/def/resources/base64url.js'
    /*
    * Base64URL-ArrayBuffer
    * https://github.com/herrjemand/Base64URL-ArrayBuffer
    *
    * Copyright (c) 2017 Yuriy Ackermann <ackermann.yuriy@gmail.com>
    * Copyright (c) 2012 Niklas von Hertzen
    * Licensed under the MIT license.
    *
    */
    (function() {
        "use strict";

        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

        // Use a lookup table to find the index.
        var lookup = new Uint8Array(256);
        for (var i = 0; i < chars.length; i++) {
            lookup[chars.charCodeAt(i)] = i;
        }

        var encode = function(arraybuffer) {
            var bytes = new Uint8Array(arraybuffer),
            i, len = bytes.length, base64 = "";

            for (i = 0; i < len; i+=3) {
                base64 += chars[bytes[i] >> 2];
                base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                base64 += chars[bytes[i + 2] & 63];
            }

            if ((len % 3) === 2) {
                base64 = base64.substring(0, base64.length - 1);
            } else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2);
            }

            return base64;
        };

        var decode = function(base64) {
            var bufferLength = base64.length * 0.75,
            len = base64.length, i, p = 0,
            encoded1, encoded2, encoded3, encoded4;

            var arraybuffer = new ArrayBuffer(bufferLength),
            bytes = new Uint8Array(arraybuffer);

            for (i = 0; i < len; i+=4) {
                encoded1 = lookup[base64.charCodeAt(i)];
                encoded2 = lookup[base64.charCodeAt(i+1)];
                encoded3 = lookup[base64.charCodeAt(i+2)];
                encoded4 = lookup[base64.charCodeAt(i+3)];

                bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            }

            return arraybuffer;
        };

        /**
         * Exporting and stuff
         */
        if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
            module.exports = {
                'encode': encode,
                'decode': decode
            }

        } else {
            if (typeof define === 'function' && define.amd) {
                define([], function() {
                    return {
                        'encode': encode,
                        'decode': decode
                    }
                });
            } else {
                window.base64url = {
                    'encode': encode,
                    'decode': decode
                }
            }
        }
    })();
    ```
    </details>

    Adapt FIDO2 Registration Client Javascript as you see fit, particularly check and adapt error handling and the options properties: [residentKey](https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-residentkey), [authenticatorAttachment](https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-authenticatorattachment), [userVerification](https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-userverification), [attestation](https://www.w3.org/TR/webauthn-2/#enum-attestation-convey). If undecided, we recommend leaving everything on default, which requires the client-side to create a discoverable platform credential with the user's explicit verification.

    Call `register(username, displayName)` from your own scripts as you see fit, this method executes FIDO2 Registration against Nevis.
    1. `username`: the nature of this property *must* match to `credential-repository.user-attribute` in the nevisFIDO configuration. For example, if `credential-repository.user-attribute = loginId` is configured, the `username` property must contain the `loginId` of the user, as known by nevisIDM.
    2. `displayName`: this property *should* match to the `displayName` property the [SCIM API List of Users](./../../../../nevisidm/Developer-Guide/REST-Interface/SCIM-REST-Service/REST-Endpoints#list-of-users) returns from nevisIDM.

2. Configure nevisProxy.

    The FIDO2 calls of the FIDO2 Registration Client Javascript now must come through nevisProxy, where the SecToken is delegated into the request, so nevisFIDO can authorize the requests properly. If there is none yet, create a connector in nevisProxy towards nevisFIDO.

    <details>
    <summary>Create the nevisFIDO connector with AutoRewrite off</summary>

    ```xml title='/var/opt/nevisproxy/default/work/WEB-INF/web.xml'
    <servlet>
        <servlet-name>FidoConnector</servlet-name>
        <servlet-class>ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet</servlet-class>
        <init-param>
            <param-name>InetAddress</param-name>
            <param-value>localhost:9443</param-value>
        </init-param>
        <init-param>
            <param-name>AutoRewrite</param-name>
            <param-value>off</param-value>
        </init-param>
        <init-param>
            <param-name>SSLClientCertificateFile</param-name>
            <param-value>/var/opt/keybox/default/node_keystore.pem</param-value>
        </init-param>
        <init-param>
            <param-name>SSLCACertificateFile</param-name>
            <param-value>/var/opt/keybox/default/truststore.pem</param-value>
        </init-param>
    </servlet>
    ```
    </details>

    Replace `localhost:9443` with the endpoint nevisFIDO is accessible at in your network.

    <details>
    <summary>nevisFIDO FIDO2 connector mappings</summary>

    ```xml title='/var/opt/nevisproxy/default/work/WEB-INF/web.xml'
        <servlet-mapping>
            <servlet-name>FidoConnector</servlet-name>
            <url-pattern>/nevisfido/fido2/attestation/options</url-pattern>
        </servlet-mapping>

        <servlet-mapping>
            <servlet-name>FidoConnector</servlet-name>
            <url-pattern>/nevisfido/fido2/attestation/result</url-pattern>
        </servlet-mapping>

        <servlet-mapping>
            <servlet-name>FidoConnector</servlet-name>
            <url-pattern>/nevisfido/fido2/status</url-pattern>
        </servlet-mapping>
    ```
    </details>

    <details>
    <summary>Delegate the SecToken and the UserId for the Options endpoint</summary>

    ```xml title='/var/opt/nevisproxy/default/work/WEB-INF/web.xml'
        <filter>
            <filter-name>SecTokenDelegationFilter</filter-name>
            <filter-class>::ch::nevis::isiweb4::filter::delegation::DelegationFilter</filter-class>
            <init-param>
                <param-name>DelegateBasicAuth</param-name>
                <param-value>
                    AUTH:user.auth.UserId
                    AUTH:user.auth.SecToken
                </param-value>
            </init-param>
        </filter>

        <filter-mapping>
            <filter-name>SecTokenDelegationFilter</filter-name>
            <url-pattern>/nevisfido/fido2/attestation/options</url-pattern>
        </filter-mapping>
    ```
    </details>

3. [Configure FIDO2 at nevisFIDO](/configurationguide/fido2-concept-and-integration-guide/configuration/nevisfido-configuration).
4. [Configure nevisIDM](/configurationguide/fido2-concept-and-integration-guide/configuration/nevisidm-configuration).
5. Restart the instances, FIDO2 Registration should be operational!
--------------------------------------------------------------------------------
Section: ### registration-nevisauth.md
---
sidebar_position: 6
---

# Registration with nevisAuth

In this use-case, the FIDO2 Registration is implemented with ScriptStates in nevisAuth. For a generic description and prerequisits, please see [Registration](/configurationguide/fido2-concept-and-integration-guide/use-cases/registration).

:::note

The presented example solution simplifies nevisAuth configuration by hiding most of the logic in the Groovy ScriptState including the HTTP API calls to nevisFIDO.

The Nevis Identity Suite provides an nevisAdmin4 pattern named *nevisFIDO FIDO2 Self-Admin App* which contains a FIDO2 / WebAuthn capable client JavaScript. Use it or build upon it, but note that it is considered to be experimental, we might change it or remove it in the future.

:::

## Technical Flow

The initial authentication depends on the custom integration as well as the existing means of authentication the end user possesses. Thus, the initial authentication steps are not explained in detail but only referenced.

:::note
The following flow is a simple compact example. Depending on requirements, changes or different approaches might be required.
The key fix points are:

* WebAuthn API in the browser.
* FIDO2 HTTP API in nevisFIDO.
* nevisAuth must be aware of the status of the FIDO2 registration.
:::

```plantuml
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  BorderColor #CDD2D4
  BackgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

skinparam database {
   BorderColor #12677C
   BackgroundColor #168CA9
}

title FIDO2 Registration

actor User as User

box "Client Device"
 participant "Browser" as BR #499985
 participant "FIDO2 Javascript Client" as JS #499985
end box

box "Relying Party Backend" #CDD2D4
    participant nevisProxy as P
    participant nevisAuth as A
    participant nevisLogRend as L
    participant nevisFIDO as F
    database nevisIDM as I
    participant "Relying Party\nWeb Application" as relyingPartyWebApp #SteelBlue
end box

User -> BR: Open browser


== Registration Precondition check ==

activate BR
BR -> P: Login using existing credential

P -> A: Authentication required
activate A
    rnote over A #ECECEC
        IdmPasswordVerifyState
    end note

    A --> P: Username + password gui
deactivate A

P -> L
activate L
    hnote over L
        Render gui with username + password input
    end note
L --> P
deactivate L

P --> BR: (<color:red>""new cookie""</color>)

BR -> P: username + password
P -> A
activate A
    rnote over A #ECECEC
        IdmPasswordVerifyState
    end note
    A -> I
    activate I
    I --> A
    deactivate I

    rnote over A #ECECEC
        IdmGetPropertiesState
    end note
    A -> I: get mobile, email, extId
    activate I
    I --> A
    deactivate I
deactivate A
A --> P
P --> BR

autonumber
 
BR -> P: Register FIDO2 credential
autonumber stop
P -> A:
autonumber resume
    rnote over A #ECECEC
        ScriptState
    end note

A --> P: GuiDescriptor configuring JS client

autonumber stop
deactivate A
P -> L
activate L
    hnote over L
        Load JS client based on gui name
    end note
L --> P
deactivate L
P --> BR
autonumber resume

== Initialise Registration ==

autonumber stop
BR -> JS: JS client runs automatically\n(<color:red>""cookie""</color>)
autonumber resume
activate JS


JS -> P: empty POST /nevisfido/fido2/attestation/options
autonumber stop
P -> A
autonumber resume

group HTTP API: Registration Options Service
activate A
    rnote over A #ECECEC
        ScriptState
    end note
A -> F: ""ServerPublicKeyCredentialCreationOptionsRequest""

activate F
end group

F -> I: get Fido2 credentials\n based on username
activate I
autonumber stop
I --> F:
autonumber resume
deactivate I
    hnote over F
        FIDO2 config in nevisfido.yml <size:20><&file></size>
    end note
F -> F: Generate challenge
autonumber stop
F --> A: ""ServerPublicKeyCredentialCreationOptionsResponse""
autonumber resume
deactivate F

A --> P
deactivate A
P --> JS: ""ServerPublicKeyCredentialCreationOptionsResponse""

== Registration ==

JS -> BR: ""navigator.credentials.create()""
BR -> User: Confirm
activate User
User --> BR: Authorize
deactivate User
    hnote over BR
        Generate key material
        private <size:20><color:#BF3666><&key></color></size>
        public <size:20><color:#499985><&key></color></size>
    end note
BR -> JS: Attestation object containing <size:20><color:#499985><&key></color></size>

JS -> P: form POST attestation data to /nevisfido/fido2/attestation/result
autonumber stop
P-> A
autonumber resume
    activate A
    rnote over A #ECECEC
        ScriptState
    end note
group HTTP API: Registration Service
A -> F: ""ServerPublicKeyCredentialForRegistration""
end group


activate F
F -> F: Get session using challenge
F -> F: Validate registration
hnote over F
    public <size:20><color:#499985><&key></color></size>
    session <size:20><&hard-drive></size>
    rp config <size:20><&file></size>
end note
F -> I: Store <size:20><color:#499985><&key></color></size> as FIDO2Credential
activate I
autonumber stop
I --> F: response
autonumber resume
deactivate I
F -> F: Update session status
F --> A: ""ServerResponse""
deactivate F
A --> A: Error handling / Custom flow
autonumber stop
A --> P
deactivate A
deactivate JS

P --> BR: Configured next step

@enduml
```

1. The user initiates the FIDO2 registration.
2. The ScriptState returns a GuiDescriptor configuring the nevisLogRend template to include the JS client.
3. The JS client submits an empty form POST to get the `ServerPublicKeyCredentialCreationOptionsResponse`. In this example implementation the `ServerPublicKeyCredentialCreationOptionsRequest` is generated by the Groovy ScriptSate.
4. The `ServerPublicKeyCredentialCreationOptionsRequest` is created by `ScriptState` and calls the nevisFIDO Options endpoint.

   **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/fido2/attestation/options`

   **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/authentication-services/authentication-options-service)

5. nevisFIDO queries the FIDO2 credentials from nevisIdm.
6. Challenge is generated and the `ServerPublicKeyCredentialCreationOptionsResponse` is built.
7. A direct response is prepared using the `ServerPublicKeyCredentialCreationOptionsResponse`.
8. JS client receives the `ServerPublicKeyCredentialCreationOptionsResponse`.
9. JS client initiates a registration using the received Options response via the WebAuthn API.
10. Dialog presented to the user by the browser to confirm the credential creation.
11. The user approves the credential creation.
12. The WebAuthn API generates the keys and returns an attestation to the JS client.
13. JS client submits attestation to the backend.
14. The `ScriptState` in nevisAuth assembles a `ServerPublicKeyCredentialForRegistration` JSON payload from the form submit and calls the nevisFIDO REST API.

    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/fido2/attestation/result`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/registration-services/registration-service)

15. nevisFIDO session lookup. (This session is independent of the nevisAuth session)
16. Incoming request validated according to the WebAuthn specification.
17. nevisFIDO stores the FIDO2 credential in nevisIDM, such that it is related to the username.
18. FIDO2 session is updated to reflect the current status.
19. ServerResponse is returned stating the status of the FIDO2 authentication. At this point the FIDO2 registration is completed.
20. `ScriptState` transitions to `ok`.

## Integration
--------------------------------------------------------------------------------
Section: ### The web application
Registration can be integrated into the customer web application where the FIDO2 credentials will be eventually used at.

See [Registration with Web Application](registration-webapp).
--------------------------------------------------------------------------------
Section: ### integration-prerequisites.md
---
sidebar_position: 2
---

# Integration prerequisites

A relying party represents a web application that you wish to secure using WebAuthn to register and authenticate users.
Before you can integrate WebAuthn, you need to collect information about your web application, the relying party:

**Relying party name**: The name of your choosing, for example: `Siven Chocolate Factory`.

**Relying party ID**: The root domain or part of the domains of your web applications that you plan to register and authenticate users on, for example: siven.ch.

**Origins**: The list of the origins of your web application. Each origin has to be explicitly allowed, for example:

* `https://www.siven.ch`
* `https://login.siven.ch:9443`
* `https://sso.login.siven.ch`

As WebAuthn can only be used from a [secure context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts), the origins have to be one of the following:

* A local address: `http://localhost`.
* An `https://` address on condition that the application provides a valid SSL certificate.

:::info

Make sure that you choose a **Relying party ID**, which is a subset of all the origins you intend to use.

For example, the `siven.ch` **Relying party ID** matches the `http://login.siven.ch:9443` origin, but not the https//bank.ch/ origin.

:::
--------------------------------------------------------------------------------
Section: ### Out-of-band authentication and transaction confirmation
In the *out-of-band* scenario, a user uses one application but requires another, separate mobile application to do authentication or transaction confirmation.

<img className="boxed" src={require('../assets/mobile-auth/oob-auth.png').default} alt=""/>

An example of an *out-of-band* scenario is a user who visits a web application via the browser installed on his personal computer (no.1 and no.2). If required, the web application triggers an authentication or transaction confirmation for the user, by sending a push message to the mobile device associated with this user (l co.3). The user authenticates in the device (for example using fingerprint) and the device signs the authenticationl cequest or transaction information and returns the result to the server (no.4). After successfe server-side, the user is considered to be authenticated or the transaction to be confirmed. The
figure illustrates this scenario.

## Nevis Mobile Authentication based on FIDO UAF

To implement the aforementioned features, Nevis Mobile Authentication is based on the FIDO UAF 1.1 standard. FIDO is a set of specifications for strong authentication. The FIDO Alliance was launched in 2013 to address the lack of interoperability among strong authentication devices and the problems users face creating and remembering multiple usernames and passwords. There were more than 260 alliance members by the end of September 2016, including leading internet companies such as Google and Microsoft.

FIDO supports the *Universal Authentication Framework* (UAF) and the *Universal Second Factor* (U2F) protocols.

:::info

U2F is not in the scope of Nevis Mobile Authentication.
:::

<img className="boxed" src={require('../assets/mobile-auth/fido-uaf.png').default} alt=""/>

The UAF protocol consists of a client component, installed on the user's mobile device, and a server component,
connected with the online service. Upon registration of the user with the online service, the client on the user's device creates a new public and private key pair. The private key is stored on the user's device. The public key is registered with the online service and associated with the user's profile. During the authentication process, the client component on the user device proves the ownership of the private key to the service by signing a challenge. This involves a simple user action only, such as providing a fingerprint, entering a PIN code, using voice recognition or even iris scanning.
--------------------------------------------------------------------------------
Section: ### glossary.md
---
sidebar_position: 36
---

# Glossary

| Term                            | Description                                                                                                                                                                                                                                                                                                                                                                            | Example                                                                                                                                                                                                                                                                                                                                                                                                       |
|---------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| In-band communication           | Using the current channel.                                                                                                                                                                                                                                                                                                                                                             | A message is delivered through an already established and currently used HTTP communication channel.                                                                                                                                                                                                                                                                                                          |
| Out-of-band (OOB) communication | Using a channel other than the main communication channel.                                                                                                                                                                                                                                                                                                                             | A message is delivered via a dispatching channel (for example, as push notification, QR code, or link) instead of a currently used HTTP communication channel.                                                                                                                                                                                                                                                |
| Out-of-band authentication      | Authentication done in an application separated from the application that requires it with no direct communication between the two applications.                                                                                                                                                                                                                                       | A web application for banking is accessed from a browser on a laptop. The web application handles the banking-related business logic but requires authentication by a distinguished Access App which is installed on a mobile device.                                                                                                                                                                         |
| In-band authentication          | Authentication done within the same application that requires it.                                                                                                                                                                                                                                                                                                                      | A mobile banking application which does not require the installation of another application to handle the authentication. All required functionality is built into one application.                                                                                                                                                                                                                           |
| Transaction confirmation        | An operation in the FIDO protocol that allows a relying party to request that a FIDO Client displays some information to the end user, and requires the user to authenticate locally to their FIDO Authenticator to confirm the information. This provides proof-of-possession of previously registered key material and an attestation of the confirmation back to the relying party. | A mobile banking application has among its capabilities bank transfers. If the amount of the transfer exceeds a threshold, the user must confirm the transaction after authenticating. In the confirmation message presented to the user, the amount of the transaction is included. When the user confirms the transaction, the contents of the message (and thus the amount) are proven by the FIDO server. |
| Access App                      | Dedicated native mobile app built to implement the FIDO UAF authentication, registration and deregistration capabilities. Optionally also implements transaction confirmation capabilities.                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Business App                    | A business application end users interact with to conduct business with Nevis customers.                                                                                                                                                                                                                                                                                               | A mobile banking application which can be used to make payments.                                                                                                                                                                                                                                                                                                                                              |
| Relying Party                   | *"A web site or other entity that uses a FIDO protocol to directly authenticate users                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO                            | Fast Identity Online                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Client                 | A FIDO UAF Client implements the client side of the FIDO UAF protocols.                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Server                 | A FIDO UAF server implements the server side of the FIDO UAF protocols.                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Protocol               | The FIDO UAF protocols carry FIDO UAF messages between user devices and Relying Parties.                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO Authenticator              | A FIDO Authenticator is responsible for user verification, and maintaining the cryptographic material required for the relying party authentication.                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Authenticator          | A FIDO UAF Authenticator is a secure entity, connected to or housed within FIDO user devices, that can create key material associated to a Relying Party. The key can then be used to participate in FIDO UAF strong authentication protocols.                                                                                                                                         |
| UAF                             | The FIDO Protocol and family of authenticators which enable a service to offer its users flexible and interoperable authentication. This protocol allows triggering the authentication before the server knows the user                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Client TLS                      | A two way TLS connection where the client also needs a valid certificate. (Also known as two way SSL)                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Dispatch Target                 | Client identifier used in out-of-band message transmission.                                                                                                                                                                                                                                                                                                                            | A unique id identifying a physical mobile device of an end user                                                                                                                                                                                                                                                                                                                                               |
| Dispatch Channel                | Means of which the message is transmitted to the client.                                                                                                                                                                                                                                                                                                                               | Push (message), E-Mail, ...                                                                                                                                                                                                                                                                                                                                                                                   |
| Dispatcher                      | Concrete implemented component tasked with sending an out-of-band message.                                                                                                                                                                                                                                                                                                             | The Firebase Cloud Messaging Dispatcher (bound to the 3rd party Firebase Cloud Messaging Service)                                                                                                                                                                                                                                                                                                             |
| Channel Linking                 | Channel linking describes the concept where a user is requested to visually confirm an out-of-band authentication. The user does so by comparing information shown in a web browser and in the authentication client application.The purpose of channel linking is verifying the current channel/operation to prevent login attempts by a malicious second party (e.g., another user). | During authentication, the browser shows the characters "6A". The same characters are shown in the mobile application, allowing the user to "link" these two channels.                                                                                                                                                                                                                                        |
--------------------------------------------------------------------------------
Section: ### In-Band Registration
In the **in-band registration scenario**, nevisProxy is responsible for protecting the endpoint of nevisFIDO's Registration Service. This is typically realized by configuring an `IdentityCreationFilter` in nevisProxy and the associated connectors. If a non-authenticated HTTP client tries to access the protected resource (the Registration Service endpoint), nevisProxy will redirect the HTTP client to nevisAuth for authentication.

The following nevisProxy configuration snippets (in `web.xml`) redirect non-authenticated access via `https://<proxy host>/nevisfido/uaf/1.1/request/registration` to the locally installed nevisAuth instance. The nevisAuth instance is configured with port `8991`, and nevisFIDO with port `8443`. The name of the realm for the in-band registration operation is `"PASSWORD_AUTHENTICATION"`.

:::info

The properties `InterceptionRedirect` and `StoreInterceptedRequest` **must** be set to `"never"` and `"false"`,
respectively. These settings are relevant for JSON clients, and must prevent the proxy from interfering with the requests. For details, see the nevisProxy Technical Documentation.
:::

To provide an authentication endpoint for a mobile authentication client, nevisProxy exposes the `/auth/pwd` path. A client can perform a password login via nevisAuth using this endpoint.

```xml title="nevisProxy - Password authentication configuration"
<!-- Authentication filter to protect the nevisFIDO Registration Service -->
<filter>
    <filter-name>PasswordAuthenticationFilter</filter-name>
    <filter-class>ch::nevis::isiweb4::filter::auth::IdentityCreationFilter</filter-class>
    <init-param>
        <param-name>AuthenticationServlet</param-name>
        <param-value>NevisAuthConnector</param-value>
        <description>The configured name of the authentication servlet</description>
    </init-param>
    <init-param>
        <param-name>LoginRendererServlet</param-name>
        <param-value>NevisLoginRenderer</param-value>
        <description>The configured name of the login renderer servlet</description>
    </init-param>
    <init-param>
        <param-name>Realm</param-name>
        <param-value>PASSWORD_AUTHENTICATION</param-value>
        <description>The realm of the authentication</description>
    </init-param>
    <init-param>
        <param-name>InactiveInterval</param-name>
        <param-value>7200</param-value>
        <description>The maximum interval between two request associated to the same session
                (if deleted or 0, value is taken from nevisAuth 'Domain' element)</description>
    </init-param>
    <init-param>
        <param-name>EntryPointID</param-name>
        <param-value>localhost</param-value>
        <description>The entry point id (will be part of the sectoken)</description>
    </init-param>
    <init-param>
        <param-name>InterceptionRedirect</param-name>
        <param-value>never</param-value>
    </init-param>
    <init-param>
        <param-name>StoreInterceptedRequest</param-name>
        <param-value>false</param-value>
    </init-param>
</filter>


<!-- URL Mapping for the nevisFIDO Registration Request Service, the filter mapping includes the SecToken and the servlet mapping associates the servlet with a path. -->
<filter-mapping>
    <filter-name>PasswordAuthenticationFilter</filter-name>
    <url-pattern>/nevisfido/uaf/1.1/request/registration/*</url-pattern>
</filter-mapping>
```

If an already authenticated user tries to access the `auth/pwd` endpoint, the system returns a 404 error by default. You can define a LUA filter to avoid this. The LUA filter will return a 204 HTTP status code.

```xml title="LUA filter for authentication endpoints"
<!-- This filter is invoked *only* if the user is already authenticated: if the user is not
     authenticated, nevisAuth (through PasswordAuthenticationFilter or FidoUafAuthenticationFilter)
     is invoked, and nevisAuth returns a direct response in those cases.
     This filter just returns an HTTP response with status code 204. -->
<filter>
    <filter-name>AlreadyAuthenticatedFilter</filter-name>
    <filter-class>ch::nevis::isiweb4::filter::lua::LuaFilter</filter-class>
    <init-param>
        <param-name>Script.InputHeaderFunctionName</param-name>
        <param-value>rewriteResponse</param-value>
    </init-param>
    <init-param>
        <param-name>Script</param-name>
        <param-value>
          function rewriteResponse(request, response)
              response:send(204)
          end
       </param-value>
    </init-param>
</filter>
```

nevisProxy introduces an additional filter mapping to `auth/pwd`. This creates a _singular endpoint_, against which client applications can perform (password) authentication. This allows clients to authenticate with legacy credentials,
which is required before starting the registration process.

```xml title="Password authentication filter mapping"
<!-- The /auth/pwd filter provides and endpoint for doing "legacy" username/password authentication -->
<filter-mapping>
    <filter-name>PasswordAuthenticationFilter</filter-name>
    <url-pattern>/auth/pwd</url-pattern>
</filter-mapping>
<filter-mapping>
    <filter-name>AlreadyAuthenticatedFilter</filter-name>
    <url-pattern>/auth/pwd</url-pattern>
</filter-mapping>
```

To forward all incoming requests to nevisFIDO, the respective connector is mapped to the nevisFIDO base path:

```xml title="nevisFIDO connector servlet mapping"
<!-- Servlet forwarding every incoming request to /nevisfido/* to nevisFIDO -->
<servlet-mapping>
    <servlet-name>FidoHttpApiConnector</servlet-name>
    <url-pattern>/nevisfido/*</url-pattern>
</servlet-mapping>
```

In the in-band registration use case, nevisAuth creates a SecToken once the client application is authenticated. The SecToken is used to guarantee that the authentication was successful and to transmit the username. The username must be transmitted to nevisFIDO when the client accesses the Registration Request endpoint. nevisFIDO will validate the *
UserId*provided in the `BasicAuth` header against the user ID encoded in the SecToken. Therefore, the `UserId` must be exposed as the first information in the `BasicAuth` header.

Furthermore, the delegation filter must be mapped to the nevisFIDO base URL.

```xml title="nevisProxy - Delegation filter"
<!-- Delegation filter for transmitting the Sectoken. -->
<filter>
    <filter-name>NinjaBasicAuthDelegationFilter</filter-name>
    <filter-class>::ch::nevis::isiweb4::filter::delegation::DelegationFilter</filter-class>
    <init-param>
        <param-name>DelegateBasicAuth</param-name>
        <param-value>
            AUTH:user.auth.UserId
            AUTH:user.auth.SecToken
        </param-value>
    </init-param>
</filter>

<filter-mapping>
    <filter-name>NinjaBasicAuthDelegationFilter</filter-name>
    <url-pattern>/nevisfido/*</url-pattern>
</filter-mapping>
```

:::info

In the in-band registration use case, only nevisAuth needs access to the nevisFIDO endpoints. This allows you to block all other nevisFIDO endpoints (notably the Authentication Request endpoint) for external HTTP clients in this scenario.
:::
--------------------------------------------------------------------------------
Section: ### out-of-band-registration-client-code-examples.md
---
sidebar_position: 40
---

# Out-of-Band Registration Client Code Examples

As mentioned in [Out-of-Band Registration](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-registration), one way of performing an out-of-band registration is by using a QR code.
Information, such as a token, is transmitted from a laptop to a mobile device by scanning a QR code.

This section describes how to build a web application that uses a QR code for registration. It is assumed that the registration application is protected in the same realm/domain as the nevisFIDO Dispatch Registration Token service.e rurthermore, Nevis is configured to transmit the SecToken to the registration application once the user is
authenticated. The JavaScript snippets below use the [jQuery](https://jquery.com/) library.

The application works as follows (the numbers in the description below correspond with the numbers in the next figure:

1. The client authenticates using a web browser and a laptop. Note that this is a legacy login, *not* the Nevis Mobile
   Authentication login.
2. The client accesses the registration application. In terms of the HTTP protocol, this typically is a GET operation.
   The HTTP request to the registration application contains a SecToken. The registration application parses the
   SecToken to extract the username to authenticate.
3. The registration application returns an HTML page containing:

    1. the username,
    2. the dispatch registration token URL,
    3. the status service URL, and
    4. JavaScript code.
4. After loading the HTML page, the JavaScript sends a Dispatch Registration Token request. The dispatcher used is the
   QR Code Dispatcher, which returns the contents to be scanned inside a QR code. For this, it uses the dispatch
   registration token URL and the username from the HTML page.

5. Nevis returns the Dispatch Registration Token response with the QR code.
6. The JavaScript parses the response with the token and renders the QR code returned by nevisFIDO.

7. The user uses a FIDO enabled application in the mobile phone to scan the QR code, redeem the token and proceed with
   the registration.

Note that after sending the Dispatch Registration Token request, the JavaScript can invoke the Status Service for information on the registration status. The Status Service helps finding out whether the user redeemed the token by scanning the QR code, and whether the registration was completed successfully.

<img className="boxed" src={require('../../assets/mobile-auth/registration-application-with-qr-code.png').default} alt="
Out-of-band registration with QR code"/>

```html title="HTML Page"
<html>
  <!-- ... -->
  <body>
    <form>
      <!-- ... -->
      <input id="dispatchTokenUrl" type="hidden" value="https://www.siven.ch/nevisfido/token/dispatch/registration"/>
      <input id="statusUrl" type="hidden" value="https://www.siven.ch/nevisfido/status"/>
      <input id="username" type="hidden" value="jeff"/>

      <div id="qrCode" style="height:300px"></div>
    </form>
    <!-- ... -->
    <script th:src="@{/webjars/jquery/3.3.1/jquery.min.js}"></script>
    <script type="application/javascript">
    /**
     * Start the registration process after the document is loaded
     */
    $( document ).ready(function () {
      sendDispatchRegistrationTokenRequest();
    });
    <!-- ... -->
    </script>
  </body>
</html>
```

```javascript title="Send Dispatch Registration Token Request"
function sendDispatchRegistrationTokenRequest() {
    var username = $('#username').val();
    var getUafRequest = {
        op: "Reg",
        context: JSON.stringify({username: username})
    };
    var dispatchTokenRequest = {
        dispatcher: "png-qr-code",
        getUafRequest: getUafRequest,
        dispatchInformation: {
            encodingParameters: {
                width: 300,
                height: 300,
                foregroundColor: "rgb(4, 125, 130)",
                backgroundColor: "rgb(255, 255, 255)"
            }
        }
    };
    var dispatchTokenUrl = $('#dispatchTokenUrl').val();

    var stringifiedBody = JSON.stringify(dispatchTokenRequest);
    jQuery.ajax({
        'type': 'POST',
        'url': dispatchTokenUrl,
        headers: {
            'Accept' : 'application/json; charset=utf-8',
            'Content-Type': 'application/json; charset=utf-8'
        },
        'data': stringifiedBody,
    }).done(function (data) {
        dispatchRegistrationTokenCallback(data);
    }).fail(function () {
        // Handle the error
    });
    return status;
}


function dispatchRegistrationTokenCallback(data) {
    var pngQrCode = data['dispatcherInformation']['response'];
    renderQrCode(pngQrCode);
}
```

```javascript title="QR Code Generation"
function renderQrCode(pngQrCode) {
    let imageAsHtml = '<img src="data:image/png;base64,' + pngQrCode +
        '" alt="Scan the QR code to trigger the registration process in your mobile device." />';
    $('#qrCode').html(imageAsHtml);
}
```

```javascript title="Status Query"
function queryRegistrationStatus(sessionId) {
    var stringifiedBody = JSON.stringify({sessionId: sessionId});
    jQuery.ajax({
        'type': 'POST',
        'url': $('#statusUrl').val(),
        headers: {
            'Accept' : 'application/json; charset=utf-8',
            'Content-Type': 'application/json; charset=utf-8'
        },
        'data': stringifiedBody,
    }).done(function (data) {
        statusResponseCallback(data);
    })
    .fail(function () {
        // Handle error
    });
    return status;
}


function statusResponseCallback(data) {
    var status = data['status']
    if (status == 'succeeded') {
        // Registration was successful
    } else if (status == 'clientRegistering') {
        // The token was redeemed
    } else if (status == 'failed') {
        // Registration failed
    } else if (status == 'tokenCreated') {
        // Waiting for token to be redeemed (has the user scanned it?)
    }
}
```
--------------------------------------------------------------------------------
Section: ### Authentication
Once the FIDO credentials have been created, the private key is stored in the FIDO Authenticator and the public key is registered in the FIDO Server, the FIDO Client can authenticate. The authentication process is the following one:

1. The Relying Party client application tries to access the web application (Relying Party).
2. Since the application is not authenticated, the Relying Party sends a _GetUAFRequest_ to the FIDO Server asking to
   authenticate.
3. The FIDO Server returns a _ReturnUAFRequest_ contaning
   an [AuthenticationRequest](https://fidoalliance.org/specs/fido-uaf-v1.1-ps-20170202/fido-uaf-protocol-v1.1-ps-20170202.html#authentication-request-message)
   to the Relying Party. In this _AuthenticationRequest_ the server includes the policy. The Relying Party forwards
   the _AuthenticationRequest_ to the application. The embedded FIDO Client in the application handles this _
   AuthenticationRequest_.
4. The user authenticates using the FIDO Authenticators required by the policy of the FIDO Server.
5. The FIDO Client generates a _SendUAFResponse_ containing
   an [AuthenticationResponse](https://fidoalliance.org/specs/fido-uaf-v1.1-ps-20170202/fido-uaf-protocol-v1.1-ps-20170202.html#authenticationresponse-dictionary)
   that is sent from the Relying
   Party client to the Relying Party server. This message consists mainly of the signed challenge sent by the client
   using the private keys generated in the registration operation. The _AuthenticationResponse_ is forwarded to the FIDO
   Server.
6. The FIDO Server validates the received _AuthenticationResponse_. The validation consists mainly on verifying that:
    * The private keys used to sign the challenge correspond to FIDO Authenticators that comply with the policy.
    * The signature of the challenge is valid. To validate the signature, the FIDO credentials of the user stored during
      the registration operation are used.
7. The FIDO Server returns a _ServerResponse_ informing that the authentication was successful. The Relying Party
   detects that the client application is successfully authenticated and notifies the application.

<img className="boxed" src={require('../../assets/mobile-auth/uaf-authentication.png').default} alt=""/>
--------------------------------------------------------------------------------
Section: ### Transaction Confirmation
The FIDO UAF Protocol defines an special case of authentication known as transaction confirmation. The transaction confirmation is used when in addition to perform authentication, the user must validate some information (this information is referred to as transaction message). A typical use case would be a banking transaction: the user authenticates to execute the transaction but in addition to that the amount of the transaction must be verified by the end user to avoid tampering (this is the case represented in the diagram below). Other examples: a web shop asking the user to confirm a purchase by showing the product and amount, a public institution mobile application asking the user for confirmation when submitting a tax declaration, etc.

The information to be validated can be either a text or an image. In this scenario, the FIDO Client is not the one that generates the message to be validated by the end user, but the web application (in the FIDO UAF Specification, this entity is referenced as Relying Party). The transaction confirmation process is the following:

1. The Relying Party application contacts the Relying Party to execute a transaction (this might imply or not sending
   a _GetUAFRequest_ to the Relying Party).
2. The Relying Party sends a _GetUafRequest_ to the FIDO Server with the transaction information.
3. The FIDO Server returns an _AuthenticationRequest_ to the FIDO Client, with the policy and the transaction message.
   The transaction message is usually generated by the Relying Party.
4. The transaction message is presented to the user who confirms it.
5. The user authenticates in the FIDO Client using the authenticators required by the policy of the FIDO Server.
6. The FIDO Client sends a _SendUAFResponse_ containing an _AuthenticationResponse_ to the Relying Party server. This
   message consists mainly of the signed challenge sent by the client and a signed hash of the transaction message. Both
   elements are signed using the private keys generated during the registration operation. The _AuthenticationResponse_
   is forwarded to the FIDO Server.
7. The FIDO Server validates the received _AuthenticationResponse_. The validation consists mainly of verifying that:
    * The private keys used to sign the challenge correspond to FIDO Authenticators that comply with the policy.
    * The signature of the challenge is valid. To validate the signature, the FIDO credentials of the user stored during
      the registration operation are used.
    * The signed hash of the transaction message is valid. To validate the signature, the FIDO credentials of the user
      stored during the registration operation are used.
8. The FIDO Server returns a _ServerResponse_ informing that the transaction confirmation was successful. The Relying
   Party (bank application) is informed about this and the transaction is executed. The Relying Party notifies the
   application that the transaction was successful.

<img className="boxed" src={require('../../assets/mobile-auth/uaf-transaction-confirmation.png').default} alt=""/>
--------------------------------------------------------------------------------
Section: ### nevis-mobile-authentication.md
---
sidebar_position: 6
---

# Nevis Mobile Authentication

Nevis Mobile Authentication builds up on top of [the FIDO UAF 1.1 protocol](https://fidoalliance.org/specs/fido-uaf-v1.1-ps-20170202/fido-uaf-protocol-v1.1-ps-20170202.html)
and supports the registration, authentication, transaction confirmation and deregistration operations of FIDO UAF 1.1.
It enables secure and convenient authentication for relying applications by letting users verify their identity via their mobile device. This is achieved by integrating the relying web applications with the Nevis Security Suite and implementing Nevis Mobile Authentication client-capabilities in a mobile application.

<img className="boxed" src={require('../../assets/mobile-auth/mobile-auth-high-level-architecture.png').default} alt="
High-level Architecture of Nevis Mobile Authentication"/>

The Nevis Mobile Authentication server-side is based on Nevis components including nevisIDM as the Identity Management System. This ensures end-to-end compatibility and decreases integration efforts with third-party components. For more details on the server-side architecture, see the [High-Level Architecture](/configurationguide/mobile-auth-concept-and-integration-guide/technical-architecture/high-level-architecture).

## Mobile Authentication Devices

Nevis Mobile Authentication focuses on mobile devices with FIDO Client capabilities and FIDO Authenticators. To connect the FIDO Clients and the FIDO Authenticators with the server-side of Nevis Mobile Authentication, a small communication layer must be implemented in the Relying Party client application. This abstraction layer is referred to as Nevis Mobile Authentication client. The Nevis Mobile Authentication client is responsible to communicate FIDO UAF protocol messages received by the mobile application to the FIDO Client and from the FIDO Client to the Relying Party.

The FIDO UAF architecture anticipates that devices and operating systems are shipped with FIDO UAF Clients and Authenticators. In such cases, the Nevis Mobile Authentication client may build up on that as depicted in the following figure.

<img className="boxed" src={require('../../assets/mobile-auth/external-fido.png').default} alt="External FIDO Client and Authenticators"/>

<img className="boxed" src={require('../../assets/mobile-auth/in-app-fido.png').default} alt="Embedded FIDO Client and Authenticator"/>

:::info Nevis Mobile Authentication Client SDK

To allow quick and easy development of mobile applications with support of Nevis Mobile Authentication, a Nevis Mobile Authentication Client SDK for Android and iOS is available.
:::

Nevis Mobile Authentication anticipates two integration scenarios for the Nevis Mobile Authentication client on the mobile device:

* A Nevis Mobile Authentication client built into a mobile Business Application which requires authentication (built-in)
  .
* A Nevis Mobile Authentication client built into a dedicated native mobile application solely built to implement
  authentication, transaction confirmation, registration and deregistration scenarios (Access App).

<img className="boxed" src={require('../../assets/mobile-auth/in-app-integration.png').default} alt="In-App integration"
/>

<img className="boxed" src={require('../../assets/mobile-auth/access-app-integration.png').default} alt="Access App"/>

If Nevis Mobile Authentication client capabilities are built into a Business Application, FIDO protocol messages between the server-side and the client-side may be directly transferred through established communication channels. If Nevis Mobile Authentication Client capabilities are built into a separate dedicated application for authentication,n tut-of-band push notifications must be used to establish a new communication channel between the server-side and the
Access Application.

Based on the client-side integration type, Nevis Mobile Authentication thus supports two authentication concepts.

## Mobile Authentication Concepts

In Nevis Mobile Authentication, we distinguish between the basic usage scenarios [out-of-band authentication](/configurationguide/mobile-auth-concept-and-integration-guide/glossary) and [in-band authentication](/configurationguide/mobile-auth-concept-and-integration-guide/glossary).e sn _in-band_ authentication, authentication is done within the same application that requires it. In _out-of-band_e suthentication, authentication is done in an application separated from the application that requires it. There is no
direct communication between the two applications.
--------------------------------------------------------------------------------
Section: ### Out-of-Band Authentication
:::info Example

* A mobile banking application handles the banking-related business logic but requires the presence of another
  application (Access App) on the same or a different mobile device to handle the authentication.
* A web application for banking is accessed from a browser on a laptop. The web application handles the banking-related
  business logic but requires authentication by a distinguished Access App which is installed on a mobile device.
  :::

In _out-of-band_ authentication, there is no direct communication between the application that requires authentication and the application that conducts the authentication. That is, FIDO Protocol messages must be transferred through another channel than the channel used by the Business Application. This is called _out-of-band_ communication. In Nevis Mobile Authentication, an _out-of-band_ channel is established by delivering a message to the Access Application via push notification.

_Out-of-band_ authentication can take place on the same physical device with two logically separated and isolated applications as depicted in the figure. One application handles the business logic, whilst the other handles authentication.

<img className="boxed" src={require('../../assets/mobile-auth/out-of-band-authentication.png').default} alt="Out-of-band authentication on same device"/>

Once an application is required to log in to access protected resources on the initial _in-band_ communication channel (
1), the server-side sends a push notification to the end user's associated Access App, containing a reference to an *
AuthenticationRequest*. This triggers the Access App to request the referred-to _AuthenticationRequest_ through a newly established _out-of-band_ channel (3). The end user locally verifies his identity and cryptographically signs the challenge contained in the _AuthenticationRequest_ (4). An _AuthenticationResponse_ is then returned to the server-side (5), which verifies the signature (6) and returns an access token to the application that initially requested login (7).

Due to the fact that there is no direct communication between the application that requires authentication and the application that conducts the authentication, authentication can also take place on a separate device. The following figure illustrates this use case.

<img className="boxed" src={require('../../assets/mobile-auth/out-of-band-authentication-multiple-devices.png').default}
alt="Out-of-band authentication with multiple devices"/>
--------------------------------------------------------------------------------
Section: #### Execution
The following figure illustrates the flow when using end-to-end encryption. The dispatcher in use has no impact on the encryption feature, because it is transparent to any dispatch service.

```plantuml title="E2E Encryption Execution"
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #047D82
    LifeLineBorderColor #047D82

    ParticipantBorderColor #047D82
    ParticipantBackgroundColor #69B1B4

    ParticipantFontName Frutiger
    ParticipantFontColor white


    GroupBorderColor #047D82
    GroupBorderThickness 1

    DividerBackgroundColor #69B1B4
    DividerBorderColor #047D82
    DividerBorderThickness 1
    DividerFontColor white
    DividerFontName Frutiger

    BoxBorderColor #A6BFE0
    BoxBackgroundColor #ECECEC

}

skinparam note {
    FontName Frutiger
    BorderColor #047D82
    BackgroundColor #CCE5E5
}

skinparam database {
   BorderColor #047D82
   BackgroundColor #69B1B4
}

box "Mobile Client Device" #LightSteelBlue
 participant "Mobile Client Application" as app #SteelBlue
end box

box "Relying Party Backend"
    participant "Relying Party\nWeb Application" as RPA #SteelBlue
    participant NEVIS
end box

participant "3rd Party Dispatching Service" as DISP

autonumber

RPA -> NEVIS: initiate out of band dispatching
activate NEVIS
NEVIS -> NEVIS: load dispatching channel <size:20><color:blue><&key></color></size> public key
NEVIS -> NEVIS: encrypt message content using <size:20><color:blue><&key></color></size>
NEVIS -> DISP: send message to dispatch
activate DISP
DISP -> NEVIS: response
deactivate DISP

NEVIS --> RPA: token
deactivate NEVIS
RPA --> RPA: display "token" for visual verification

DISP --> app: message encrypted with <size:20><color:blue><&key></color></size>
activate app
app -> app: load dispatching channel <size:20><color:green><&key></color></size> private key
app -> app: decrypt message content using <size:20><color:green><&key></color></size> private key
deactivate app

@enduml

```

The following list describes the steps of the end-to-end encryption flow. The numbers correspond with the steps in the previous figure.

1. The relying party web application initiates an out-of-band operation.
2. Nevis loads the public key of the dispatch channel of the user.
3. The message content is encrypted with the public key.
4. The encrypted message is sent to the 3rd party dispatch service.
5. The response of the 3rd party dispatch service is handled by Nevis to detect dispatching errors early.
6. The token created during the dispatch operation is forwarded to the application that initiated the out-of-band
   operation.
7. A visual representation of the token is rendered and shown to the user to allow visual verification of the dispatched
   message.
8. The mobile client application receives the message out-of-band.
9. The mobile client application loads the matching private key for the encrypted message.
10. The mobile client application decrypts the message content with the private key.
--------------------------------------------------------------------------------
Section: ### Example with Push Notification
This section describes the transaction confirmation process on the basis od the second scenario.

The numbers in the description below correspond with the numbers in the next figure.

1. The user completes his online shopping by performing a credit card checkout and supplying his credit card information.
2. The online shop contacts the payment backend to initiate the payment.
3. The payment backend contacts Nevis Mobile Authentication to initiate a transaction confirmation. The payment backend is responsible for determining the relying party backend username based on the provided payment information (e.g., the user's credit card information).
4. Nevis sends a push notification to the mobile device. If the user registered more than one mobile device, the backend must either:
    1. Decide which device should receive the push message, or.
    2. Send multiple messages to all devices registered to the user.
5. The mobile device receives the push notification and shows it in the notification bar. User interaction with the
   notification will open the mobile application, which is required to handle the push message data content.
6. The mobile application decrypts the push message and uses the contained data to contact Nevis to proceed
   with the FIDO transaction confirmation.
7. Nevis sends back the transaction content to the mobile application and requests the user to confirm the transaction.
8. The user confirms (or rejects) the transaction using the fingerprint-based FIDO Authenticator in the mobile device.
9. The transaction confirmation process on the mobile device is completed. The mobile application sends the confirmation
   result to Nevis.
10. The Nevis Authentication Backend informs the payment backend about the successfully signed transaction.
11. The payment backend confirms the payment to the online shop.
12. The online shop shows the payment as completed.

<img className="boxed" src={require('../../assets/mobile-auth/uc-oob-transaction-confirmation-flow.drawio.png').default} alt="Out-of-Band Transaction Confirmation Example"/>

## Technical Flow

:::info

The technical flow in the next figure explains the component interaction in detail. The step numbers in the figure do not correlate with the simplified example above.
:::

In regard to the UAF protocol and flow, the steps in the transaction confirmation process and the [Out-of-Band Authentication](out-of-band-authentication) processes are the same. The authentication and transaction confirmation processes differ in the payload that accompanies the transaction confirmation process. This payload contains the transaction information; it is (usually) absent in authentication scenarios. The following technical flow therefore only contains the steps specific for the transaction confirmation process.

```plantuml title="Out-of-band transaction confirmation flow"
@startuml

skinparam shadowing false
skinparam BoxPadding 10
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #047D82
    ParticipantBorderColor #168CA9
    ParticipantBackgroundColor #168CA9
    ParticipantFontName Frutiger
    ParticipantFontColor white
    ActorBackgroundColor #168CA9
    ActorBorderColor #168CA9
    ActorFontName Frutiger
    GroupBorderColor #168CA9
    GroupBorderThickness 1
    DividerBackgroundColor #168CA9
    DividerBorderColor #168CA9
    DividerBorderThickness 1
    DividerFontColor white
    DividerFontName Frutiger
    BoxBorderColor #168CA9
    BoxBackgroundColor #ECECEC
}
skinparam note {
    FontName Frutiger
    BorderColor #168CA9
    BackgroundColor #F5F5F5
}

title Out-of-Band Transaction Confirmation

actor User

box "Desktop Device"  #F5F5F5
    participant "Browser" as browser #75C3D7
end box

box "Mobile Client Device"  #F5F5F5
 participant "FIDO UAF \nAuthenticator" as Authenticator #75C3D7
 participant "Nevis Access App" as app #75C3D7
end box

box "3rd Party Backend" 
    participant "Web Application" as WebApp #75C3D7
end box

box "Relying Party Backend"
    participant nevisProxy
    participant nevisAuth
    participant nevisFIDO
    participant nevisIDM
end box

participant "Customer Backend" as backend #75C3D7
participant "Firebase Cloud Messaging\n(FCM)" as FCM #75C3D7


User -> browser ++ : Open browser app
browser -> WebApp ++ : Access 3rd party web application
ref over browser, WebApp
    Web application interaction leading to transaction confirmation
end ref

autonumber

WebApp -> nevisProxy: Transaction information
nevisProxy -> backend ++: Forward transaction information
backend -> backend: Resolve ""username"", ""dispatchTargetId""

== Dispatch Token ==

backend -> backend: Create ""GetUafRequest""\n(""username"")

group HTTP API: Dispatch Token Service
    backend -> nevisFIDO ++ : Dispatch token request\n(""dispatchTargetId,""\n""GetUafRequest"")
end group

autonumber stop

nevisFIDO -> nevisFIDO: Generate ""token"" and\nstore ""GetUafRequest""
nevisFIDO -> nevisIDM ++ : Fetch dispatch target\n(""dispatchTargetId"")

nevisFIDO <-- nevisIDM -- : Dispatch target
hnote over nevisFIDO
    dispatch target
    public <size:20><color:green><&key></color></size>
end note

nevisFIDO -> nevisFIDO: Encrypt data using JWE\n(""token,redeemUrl"")
FCM <- nevisFIDO ++ : Transmit push message
FCM --> nevisFIDO --
backend <-- nevisFIDO --: Dispatch token response\n(sessionId)

autonumber resume

loop status == succeeded OR status == failed

    group HTTP API: Status Service
        backend -> nevisFIDO ++ : Query status \n(""sessionId"")
        nevisFIDO -> backend --: Status response
    end group

end

autonumber stop

== Receive and Handle Dispatched Token ==

app <- FCM ++ : Push message
hnote over app
    dispatch target
    private <size:20><color:red><&key></color></size>
end note
app -> app: Decrypt JWE


== Redeem Authentication Token for Transaction Confirmation==

group HTTP API: Redeem Token Service
    app -> nevisProxy: Redeem authentication token\n(""token"")
    nevisProxy -> nevisFIDO ++: Foward redeem authentication token\n(""token"")
end group

nevisFIDO -> nevisFIDO: Fetch ""GetUafRequest""\nfrom session
hnote over nevisFIDO
    policy <size:20><&document></size>
end note
app <-- nevisFIDO --: ""ReturnUAFRequest""\n(""AuthenticationRequest"")

== Trusted facets ==

group HTTP API: Facets Service
    app -> nevisProxy: Fetch trusted facets
    nevisProxy -> nevisFIDO ++: Forward trusted facets request
end group
app <-- nevisFIDO --: Trusted facets

== Out-of-Band Transaction Confirmation ==

autonumber resume
app -> app: Show transaction content

autonumber stop

Authenticator <- app ++ : Trigger user authentication
User <- Authenticator ++ : Authenticate

User --> Authenticator -- : Unlock private key
hnote over Authenticator
    private <size:20><color:red><&key></color></size>
end note
Authenticator --> app -- : ""Assertion""

group HTTP API: Authentication Response Service
    app -> nevisProxy: ""SendUAFResponse""\n(""AuthenticationResponse"")
    nevisProxy -> nevisFIDO: Forward ""SendUAFResponse""\n(""AuthenticationResponse"")
end group

nevisFIDO -> nevisIDM ++: Fetch FIDO credential

nevisFIDO <-- nevisIDM --: Credential
hnote over nevisFIDO
    public <size:20><color:green><&key></color></size>
    policy <size:20><&document></size>
    metadata <size:20><&document></size>
end note
app <-- nevisFIDO: ""ServerResponse""
deactivate app

== Finalize Transaction Confirmation ==
autonumber resume

backend -> nevisProxy --: Status response
nevisProxy -> WebApp: Forward status response
WebApp -> WebApp: Handle transaction based on status response
WebApp -> browser--: Show transaction result
browser -> User--: Show transaction result

|||
@enduml

```

The numbers in the list correlate with the step numbers in the previous figure.

1. The user interacts with a third party web application which leads to a transaction, such as buying a book with this credit card in an online shop. The web application sends the transaction information to a relying party backend application. This backend application is capable of retrieving the missing required information to issue a transaction.
2. nevisProxy forwards the request to the relying party backend application.
3. The relying party backend application uses the provided transaction information (for example the credit card number) to resolve both the corresponding user stored in nevisIDM and the dispatch target ID of the user's mobile device.

   How the information is retrieved depends on the respective use case, the available information provided by the third party web application as well as the custom implementation of the relying party backend application.
4. The relying party backend application creates a GetUafRequest for the given username.

   **References:**

    * [Authentication Request Service](/nevisfido/reference-guide/uaf-http-api/authentication-services/authentication-request-service)
    * [GetUAFRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-client-api-transport-v1.0-ps-20141208.html#getuafrequest-dictionary)
5. The relying party backend application calls the nevisFIDO endpoint to dispatch a token request, and supplies the
   `GetUafRequest` together with the ID of the previously selected dispatch target (`dispatchTargetId`).

   **Endpoint:** `https://<nevisFIDO-host>/nevisfido/token/dispatch/authentication`

   **References:**

    * [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service)
6. The relying party application uses the sessionId to query the status of the transaction confirmation operation. This
   `sessionId` has been provided as response in a previous, not described step.

   **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/status`

   **References:**

    * [Status Service](/nevisfido/reference-guide/uaf-http-api/status-service)
7. The status service returns the status result for the current ongoing transaction confirmation operation.

   This operation is looped until the status response indicates success or failure of the transaction operation.
8. The relying party mobile application receives the `AuthenticationRequest` containing the transaction information, which it shows to the user on the mobile. The transaction information is either text- or image-based. It is up to the mobile application to choose the most suitable representation.

   The user has to decide whether to accept the transaction during the authentication process. The relying party mobile client application always returns an `AuthenticationResponse` to the server, even if the user rejected the transaction. In the latter case, the response contains the client error code indicating the user cancellation, instead of the signed transaction assertion.
9. The relying party backend application forwards the status response obtained from the nevisFIDO status service to the third party web application. The status response is most likely defined by the third party web application and must be mapped accordingly by the relying party backend application.
10. nevisProxy forwards the status response to the third party web application.
11. The third party web application that initiated the transaction confirmation processes the transaction according to the status response. That is, it marks the transaction as either confirmed or failed, depending on whether the user confirmed the transaction on his/her mobile device.
12. The transaction result is represented in the browser.
13. The user sees the transaction result (for example, a successful credit card payment).

The above technical flow applies to both scenarios described at the start of the chapter. In scenario 1 as well as scenario 2, the relying party backend application needs to access protected endpoints of the nevisFIDO component. Access can be granted in two ways:

* If the nevisFIDO instance is _not_ using client-TLS, access is granted by providing a SecToken issued to the user who wants to initiate a transaction confirmation. In scenario 1, the SecToken is directly available as the user authenticated first. In scenario 2, the payment backend must be able to request a SecToken from Nevis in the name of the user.
* If the nevisFIDO instance is using client-TLS, access is granted implicitly, based on a valid client certificate (for more information, see [Security Considerations](../security-considerations)).

The SecToken _can_ be used in both scenarios, but user impersonation based on the SecToken is only easily available in scenario 1. For scenario 2, client-TLS based user impersonation is recommended.

## Configuration Snippets

You will find example configuration snippets for all involved components in [Nevis Component Configuration Examples](/configurationguide/mobile-auth-concept-and-integration-guide/appendixes/nevis-component-configuration-examples).

Note that the described scenario of transaction confirmation does _not_ involve nevisAuth. Therefore, map the required endpoints only in nevisProxy.
--------------------------------------------------------------------------------
Section: ### Example
1. The user launches the e-banking application on the mobile device.
2. The mobile client application tries to access the e-banking web server to retrieve the account statement of the user.
3. Nevis detects that the mobile client application is not authenticated. It asks the user to provide authentication that meets the security policy of the e-banking application. In this example, this is a fingerprint-based authentication.
4. The user authenticates using the fingerprint-based FIDO Authenticator in the mobile device.
5. The mobile client application can now access the e-banking web server. The account statement is displayed in the mobile application.

<img className="boxed" src={require('../../assets/mobile-auth/uc-in-band-authentication.png').default} alt="In-Band Authentication"/>

## Technical Flow

:::info

The technical flow in the following figure explains the component interaction in detail. The numbers of the steps in the next figure do not correlate with the simplified example above.
:::

It is assumed that the user has already registered FIDO credentials. These FIDO credentials are located in the nevisFIDO server on the mobile device containing the e-banking mobile application. See the [In-Band Registration](in-band-registration) use case for details regarding registration. It is also assumed that only one user is using the application on the mobile device, that is, the device is not shared between different users. Another assumption is that the policy requires the use of a fingerprint-based authenticator.

```plantuml title="In-Band Authentication Flow"
@startuml

skinparam shadowing false
skinparam BoxPadding 10
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #047D82
    ParticipantBorderColor #168CA9
    ParticipantBackgroundColor #168CA9
    ParticipantFontName Frutiger
    ParticipantFontColor white
    ActorBackgroundColor #168CA9
    ActorBorderColor #168CA9
    ActorFontName Frutiger
    GroupBorderColor #168CA9
    GroupBorderThickness 1
    DividerBackgroundColor #168CA9
    DividerBorderColor #168CA9
    DividerBorderThickness 1
    DividerFontColor white
    DividerFontName Frutiger
    BoxBorderColor #168CA9
    BoxBackgroundColor #ECECEC
}
skinparam note {
    FontName Frutiger
    BorderColor #168CA9
    BackgroundColor #F5F5F5
}

title In-Band Authentication

actor User as user

box "Mobile Device" #F5F5F5
 participant "FIDO UAF \n Authenticator" as authenticator #75C3D7
 participant "Nevis Access App" as app #75C3D7
end box

box "Nevis Backend"
    participant nevisProxy as proxy
    participant nevisAuth as auth
    participant nevisFIDO as fido
    participant nevisIDM as idm
end box

participant "Customer Application" as backend #75C3D7

autonumber
user -> app++: Open and use Mobile App

== Initialise Authentication ==

app -> proxy++: Access /auth/fidouaf
proxy -> auth--++: Authentication required

rnote over auth #ECECEC
    FidoUafAuthState
end note

group HTTP API: Authentication Request Service
    auth -> fido++: ""GetUAFRequest""
end group

hnote over fido
    policy <size:20><&document></size>
end note
fido --> auth--: ""ReturnUAFRequest""\n(""AuthenticationRequest"")
auth --> app--: Forward ""ReturnUAFRequest""\n(""AuthenticationRequest"")

== Trusted Facets ==

group HTTP API: Facets Service
    app -> proxy++: Fetch trusted facets
    proxy -> fido--++: Forward trusted facets request
end group
fido --> app--: ""TrustedFacets""

== Client processing ==

app -> authenticator++: Trigger user authentication
authenticator -> user++: Authenticate
user --> authenticator--: Unlock private key
 
hnote over authenticator
    private <size:20><color:red><&key></color></size>
end note
authenticator --> app--: Assertion

== Authentication Response ==

group HTTP API: Authentication Response Service
    app -> proxy++: ""SendUAFResponse""\n(""AuthenticationResponse"")
    proxy -> fido--++: Forward ""SendUAFResponse""\n(""AuthenticationResponse"")
end group

fido -> idm++: Fetch FIDO credential
idm --> fido--: Credential
hnote over fido
    public <size:20><color:green><&key></color></size>
    policy <size:20><&document></size>
    metadata <size:20><&document></size>
end note
fido --> app--: ""ServerResponse""

== Finalise Authentication ==

app -> proxy++: Check authentication status \n(""fidoUafSessionId"")
proxy -> auth++: Check authentication status \n(""fidoUafSessionId"")

rnote over auth #ECECEC
    FidoUafAuthState
end note

group HTTP API: Status Service
 auth -> fido++: Query authentication status
end group

fido --> auth--: Authentication Status\n(""StatusResponse"")  """succeeded"""

note right
 The flow will fail if one of the following two statuses is reported:
 - failed
 - unknown
end note

auth --> proxy--: Authentication Status\n(""StatusResponse"")  """succeeded"""
proxy --> app--: Authentication Status\n(""StatusResponse"")  """succeeded"""

== Generate SecToken ==

app -> proxy++: Check authentication status \n(""fidoUafSessionId"")
proxy -> auth++: Check authentication status \n(""fidoUafSessionId"")

rnote over auth #ECECEC
    FidoUafAuthState
end note
auth -> auth: Transition """ok"""

rnote over auth #ECECEC
    DirectResponseState
end note

auth -> auth: Set response payload JSON: \n""{"status":"completed"}""
auth -> auth: Set response to AUTH_DONE

auth --> proxy--: ""{"status":"completed"}"" + ""SecToken""
proxy --> app--: ""{"status":"completed"}""\n(<color:red>""cookie""</color>)

== Access Relying Party Services ==

app -> proxy++: Access Relying Party service\n(<color:red>""cookie""</color>)
autonumber stop
proxy -> backend--++: Providing access to Relying Party service
backend --> app--
app --> user--
|||

@enduml
```

The numbers in the list correlate with the step numbers in the previous figure.

1. The user opens the e-banking application on the mobile device to see her actual account statement.

2. The mobile application initiates the in-band authentication by accessing the respective endpoint

   As the perimeter component of Nevis Mobile Authentication, nevisProxy receives the incoming request.

   **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/auth/fidouaf`

   **References:**

    * [HTTP APIs and Client Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/configuration/http-apis-and-client-authentication)

3. nevisProxy detects that the mobile client application is not authenticated.

   nevisProxy redirects the client to nevisAuth to ask for authentication.

4. nevisAuth is configured for authentication with FIDO UAF. To achieve this, nevisFIDO provides an own AuthState named `FidoUafAuthState`.

   The `FidoUafAuthState` assembles a `GetUAFRequest` (with the operation header set to `Auth`). nevisAuth sends the `GetUAFRequest` to nevisFIDO, to trigger a FIDO UAF authentication.

   **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/uaf/1.1/request/authentication`

   **References:**

    * [FidoUafAuthState](/nevisfido/reference-guide/config-nevis-components/nevisauth-fido-authstates/fido-uaf/fidouafauthstate)
    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/authentication-services/authentication-request-service)
    * [GetUAFRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-client-api-transport-v1.1-id-20170202.html#getuafrequest-dictionary)

5. nevisFIDO sends a `ReturnUAFRequest` to nevisAuth. The `ReturnUAFRequest` contains an `AuthenticationRequest` message including the authentication policy.

   nevisFIDO also returns a FIDO UAF session identifier. For more information, see [Authentication Request Service](/nevisfido/reference-guide/uaf-http-api/authentication-services/authentication-request-service) in the nevisFIDO Reference Guide, in particular the "Example Response" part. This part describes the proprietary extension containing the FIDO UAF session ID.

   :::info

   Placing the `fidoUafSessionId` in the extension part of the `AuthenticationRequest` makes synchronisation between nevisAuth and nevisFIDO possible: It links the FIDO session maintained in nevisFIDO to the session maintained by nevisAuth.
   :::

   **References:**

    * [ReturnUAFRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-client-api-transport-v1.1-id-20170202.html#returnuafrequest-dictionary)
    * [AuthenticationRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticationrequest-dictionary)
    * [Extensions Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#extension-dictionary)

6. nevisAuth forwards the `ReturnUAFRequest` to the mobile device through nevisProxy. It is assumed that the mobile device includes an embedded FIDO Client.

   While forwarding the `ReturnUAFRequest`, nevisAuth looks into the contained `AuthenticationRequest` message and stores the found FIDO UAF session identifier. However, nevisAuth does not change the content of the message.

   **References:**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/config-nevis-components/nevisauth-fido-authstates/fido-uaf/fidouafauthstate#restarting-the-fido-uaf-authentication)
    * [ReturnUAFRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-client-api-transport-v1.1-id-20170202.html#returnuafrequest-dictionary)
    * [AuthenticationRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticationrequest-dictionary)

7. The embedded FIDO Client fetches the trusted facets.

   The request will be sent to nevisProxy.

   The information accessible at the Facets Service endpoint helps the e-banking mobile application to identify whether it is an authorized facet of the e-banking web application.

   **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/uaf/1.1/facets`

   :::info

   This endpoint is an example of mapping nevisProxy to the nevisFIDO Facets Service endpoint
   :::

8. nevisProxy forwards the request to nevisFIDO.

   **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/uaf/1.1/facets`

   **References:**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/facets-service)
    * [Facets Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-appid-and-facets-v1.1-id-20170202.html#determining-if-a-caller-s-facetid-is-authorized-for-an-appid)

9. nevisFIDO returns the trusted facets it maintains. nevisProxy forwards them to the FIDO Client.

   **References:**

    * [Trusted Facets Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-appid-and-facets-v1.1-id-20170202.html#trustedfacets-structure)

10. The FIDO Client triggers the user authentication at the matching FIDO Authenticator.

    The FIDO Client can find a matching FIDO Authenticator on the mobile device by using the policy received via the AuthenticationRequest message in step 6.

11. The fingerprint-based FIDO Authenticator initiates the client-side authentication of the user.

    The GUI of the mobile platform informs the user to authenticate by tapping the fingerprint sensor of the mobile device.

12. With a successful fingerprint-based authentication the user enables the usage of the private key. This private key matches the formerly registered FIDO credentials of the e-banking web application. The private key is now unlocked inside the FIDO Authenticator for signing purposes.

13. As the outcome of the user authentication, the FIDO Authenticator assembles and returns an AuthenticatorSignAssertion to the FIDO Client. The assertion is signed by the private key of the user, as proof of the successful client-side authentication.

    :::info

    The private key that is used to sign the assertion never leaves the FIDO Authenticator. This means that neither the embedded FIDO Client nor the Relying Party mobile app can access it directly (not even in an unlocked state).

    Because the `AuthenticatorSignAssertion` is digitally signed, none of the involved parties in the communication chain can change the assertion without violating any upcoming integrity checks.
    :::

    **References:**

    * [Authentication Request Processing Rules for FIDO Authenticator Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authentication-request-processing-rules-for-fido-authenticator)
    * [Authentication Response Generation Rules for FIDO UAF Client Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authentication-response-generation-rules-for-fido-uaf-client)
    * [AuthenticatorSignAssertion Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticatorsignassertion-dictionary)

14. The Relying Party mobile app sends a `SendUAFResponse` to the Authentication Response Service endpoint defined in nevisProxy.

    The `SendUAFResponse` contains an `AuthenticationResponse` message including the `AuthenticatorSignAssertion`provided by the FIDO Authenticator in the previous step (13).

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/auth/fidouaf/authenticationresponse/`

    :::info

    Since this endpoint is not a direct match to the nevisFIDO Authentication Response Service endpoint, it should be mapped with a custom connector servlet and servlet-mapping in nevisProxy:

    ```xml title="Authentication Response custom servlet and mapping"
    <servlet>
        <servlet-name>Connector_AuthenticationResponse</servlet-name>
        <servlet-class>ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet</servlet-class>
        <init-param>
            <param-name>AutoRewrite</param-name>
            <param-value>off</param-value>
        </init-param>
        <init-param>
            <param-name>InetAddress</param-name>
            <param-value>localhost:9443</param-value>
        </init-param>
        <init-param>
            <param-name>MappingType</param-name>
            <param-value>pathinfo</param-value>
        </init-param>
        <init-param>
            <param-name>URIPrefix</param-name>
            <param-value>/nevisfido/uaf/1.1/authentication</param-value>
        </init-param>
    </servlet>

    <servlet-mapping>
        <servlet-name>Connector_AuthenticationResponse</servlet-name>
        <url-pattern>/auth/fidouaf/authenticationresponse/</url-pattern>
    </servlet-mapping>
    ```

    :::
    **References:**

    * [SendUAFResponse Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-client-api-transport-v1.1-id-20170202.html#senduafresponse-dictionary)
    * [AuthenticationResponse Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticationresponse-dictionary)

15. nevisProxy forwards the SendUAFResponse to nevisFIDO.

    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/uaf/1.1/authentication`

    **References:**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/authentication-services/authentication-response-service)

16. nevisFIDO fetches the user's FIDO credential from nevisIDM. The credential contains the public key material that the FIDO Authenticator generated exclusively for this e-banking application and user during the registration.

    You can uniquely identify and fetch the credential by the "username/AppId/AAID/KeyId" quadruple.

17. nevisIDM returns the FIDO credential to nevisFIDO.

    nevisFIDO validates the AuthenticationResponse, including the `AuthenticatorSignAssertion`.

    nevisFIDO verifies the signature - and thus the integrity - of the `AuthenticatorSignAssertion`, with the public key from the related FIDO credential.

    In addition to the policy, nevisFIDO also uses the metadata stored locally on the server to validate the response. The metadata information must contain a descriptor of the FIDO Authenticator model used to perform the authentication.

    **References:**

    * [Authentication Response Processing Rules for FIDO Authenticator Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticationresponse-dictionary)

18. nevisFIDO returns a `ServerResponse` to the Relying Party mobile app through nevisProxy, informing that the authentication was successful.

    :::info

    When nevisFIDO returns the `ServerResponse`, you can consider the FIDO operation as completed. For authenticating purposes, however, Nevis Mobile Authentication must further consult nevisAuth.
    :::

    **References**

    * [ServerResponse Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-ps-20170202/fido-uaf-client-api-transport-v1.1-ps-20170202.html#serverresponse-interface)

19. The mobile application provides the FIDO UAF session ID generated in step 5. This is required to trigger a
    synchronisation between nevisAuth and nevisFIDO.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/auth/fidouaf`

20. nevisProxy detects that the mobile application is not yet authenticated.

    nevisProxy forwards the request with the FIDO UAF session ID to nevisAuth.

    **Endpoint:** `https://<nevisAuth-host>:<nevisAuth-port>/nevisauth/services/AuthenticationService`

    **References**

    * [FidoUafAuthState](/nevisfido/reference-guide/config-nevis-components/nevisauth-fido-authstates/fido-uaf/fidouafauthstate)

21. nevisAuth queries nevisFIDO regarding the authentication status.

    nevisAuth verifies that the FIDO UAF session ID is the one stored in step 6. It sends the FIDO UAF session ID to the status service of nevisFIDO.

    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/status`

    **References**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/status-service)

22. nevisFIDO confirms to nevisAuth that the authentication for the provided FIDO UAF session ID was successful.

    **References**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/status-service)

23. nevisAuth forwards the `statusResponse` obtained from nevisFIDO to nevisProxy.
24. nevisProxy forwards the `statusResponse` to the mobile application.

    Although the authentication is considered completed, the session has not yet been marked as authenticated. This is because the nevisAuth flow is not completed yet.

25. To complete the authentication flow, the mobile application re-sends the request containing the FIDO UAF session ID.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/auth/fidouaf`
26. nevisProxy forwards the request with the FIDO UAF session ID to nevisAuth.
27. Since the authentication was successful, nevisAuth will transition to the next configured AuthState with the "ok" transition.

    Here, the `DirectResponseState` is configured as the next AuthState after the `FidoUafAuthState`.
28. The next AuthState `DirectResponseState` sets the direct response payload to a static JSON containing:

    ```json
    {"status":"completed"}
    ```

29. The next AuthState, `DirectResponseState`, also sets the response to `AUTH_DONE`. It thus marks the authentication flow as complete.
30. With the result set to `AUTH_DONE`, a SecToken is generated. Furthermore, the session is marked as authenticated.
31. The mobile application receives the static JSON payload alongside a cookie. Both indicate that the session is now authenticated.
32. The mobile application can now access the services of the e-banking web server and display the account statement of the user.

    The cookie is used by nevisProxy to check that the application is authenticated.
--------------------------------------------------------------------------------
Section: ### Multiple Users in Device
In some cases, the device used to access the web application might be shared between different users. This may be the case, for example, for a company using proprietary hardware with an embedded FIDO Authenticator and a limited number of devices. In this scenario, it is useful to identify the user trying to authenticate beforehand. You can achieve this with [FIDO step-up authentication](/configurationguide/mobile-auth-concept-and-integration-guide/concept-description/fido-uaf-universal-authentication-framework#fido-uaf-step-up-authentication).

In this use case, nevisFIDO is aware of the user trying to authenticate. This allows nevisFIDO to limit the allowed FIDO UAF Authenticators to those registered by this user, and to send a list with only those authenticators to the FIDO UAF client. The client can then determine which FIDO Authenticators to use for authentication without interacting with the user.

It is possible to configure the `FidoUafAuthState` in nevisAuth to define the username (if any) to be sent to nevisFIDO.
You do this with the `fidoUafUsername` property:

```xml

<AuthState name="FidoUafAuthState" class="ch.nevis.auth.fido.uaf.authstate.FidoUafAuthState" final="false"
           resumeState="false">
    <ResultCond name="ok" next="AuthDone"/>
    <ResultCond name="error" next="AuthError"/>
    <ResultCond name="failed" next="AuthError"/>
    <property name="fidoUafServerUrl" value="https://localhost:8443"/>
    <property name="httpclient.tls.truststoreRef" value="DefaultKeyStore"/>
    <property name="fidoUafUsername" value="${notes:username}"/>
</AuthState>
```

In the example above, the username is retrieved from the notes stored in the nevisAuth session. The notes can be stored by a previously executed AuthState. nevisFIDO uses nevisIDM to store FIDO credentials, and the _extId_ of the user is the username. The previously executed AuthState could interact with the user to retrieve an identifier; the main task of the AuthState would be to retrieve the username (_extId_) from nevisIDM using this identifier. The following diagram describes this process:

<img className="boxed" src={require('../../assets/mobile-auth/uc-in-band-authentication-multiple-users.png').default}
alt="FidoUafAuthState Username Retrieval"/>

Another possibility is to retrieve the username at the client level. The application could send the username in the request. For example, if the `fidoUafUserName` property of the `FidoUafAuthState` is configured as follows:

```xml

<property name="fidoUafUsername" value="${inargs:o.username.v}"/>
```

The mobile client could send the username (again the _extId_ of the user in nevisIDM) in the first step of the authentication using JSON:

```json
{
  "username": "the_user_name"
}
```

If the application has an identifier of the user other than the _extId_, you could use the same approach as above.
However, you do not need to interact with the user, because in this case the identifier is provided by the application.

## Configuration Snippets

You will find example configuration snippets for all involved components in [Nevis Component Configuration Examples](/configurationguide/mobile-auth-concept-and-integration-guide/appendixes/nevis-component-configuration-examples).
--------------------------------------------------------------------------------
Section: ### dispatching-for-out-of-band-operations-push-notification-fallback.md
---
sidebar_position: 30
---

# Dispatching for Out-of-Band Operations - Push Notification Fallback

## Description

In the context of [out-of-band authentication](out-of-band-authentication), a user-friendly approach is to send the information with the Firebase Cloud Messaging service (short FCM service). The user must only click the push message that he/she receives on his mobile phone to open the application and proceed with the authentication.

But sometimes push service notifications do not work. In case of an outage in the provider network, for example, or when there are problems with the coverage. For these situations, Nevis Mobile Authentication provides two fallback authentication mechanisms. This chapter explains how the end user application interacts with the backend to trigger the fallback authentication mechanisms.

## Fallback Mechanisms

Nevis Mobile Authentication provides two different out-of-the-box fallback authentication mechanisms:

* **QR codes** The QR Code fallback mechanism is useful if the user accesses the protected web application via a desktop PC or laptop. Instead of sending a push notification to the user's mobile device, Nevis Mobile Authentication displays a QR code on the PC or laptop. The user must then scan this QR code with his mobile device to trigger the authentication.
* **Deep links** QR codes will not work if the user accesses the protected web application on the same mobile device used for mobile authentication - you cannot scan a QR code with the device displaying the code. In this case, it is possible to use deep links. When the user clicks on such a link, the authentication mobile application opens.

:::info

For more information, see the nevisFIDO Reference Guide ([QR Code Dispatcher](/nevisfido/reference-guide/dispatchers/qr-code-dispatcher)e Gnd [Link Dispatcher](/nevisfido/reference-guide/dispatchers/link-dispatcher)).The interaction with the backend is the same in both cases. The section below explains how this interaction works.
:::

## Fallback in Out-of-Band Authentication

To be able to understand how the fallback authentication works, you first need to understand the out-of-band authentication on the relying party level.

A relying party is for example a nevisAuth instance in case of an application protected by Nevis, or a credit card transaction web application in case of a payment. The relying party asks nevisFIDO whether a user has been authenticated. For this, the relying party uses the nevisFIDO session ID. When the user has been authenticated, the relying party gives the user access to the application that required authentication. So nevisFIDO does the *authentication*, and the relying party performs the *authorization*.

Now suppose it is necessary to use a fallback authentication mechanism. In this case, the relying party requests a new authentication, based on the respective fallback authentication mechanism (QR code or deep link). For this new authentication request, nevisFIDO will generate a new session ID, here referred to as *sessionID2.*The relying party will then check whether the user authenticated successfully for the session *sessionID2*.

:::info

It is up to the relying party whether to grant the user access to the requested application as soon as authentication is completed for the initial session ID, or only if the user has authenticated for the last session ID, *sessionID2*.s cuppose, for example, that the initial out-of-band mechanism is push notification, and the fallback mechanism is QRs code. Should the displaying of the QR code then invalidate the authentication with the push notification (which might only arrive a bit late)? The choice may depend on the desired user experience.

If nevisAuth is the relying party, it only uses the authentication triggered last to check whether nevisFIDO authenticated the user (the authentication that was triggered last is the one with session ID *sessionID2)*. This means that even if the user authenticates successfully with the initial request, nevisAuth will not use this to grant access to the protected application; nevisAuth only considers the user as authenticated when the latest generated authentication (with *sessionID2*) is completed. This makes the approach of nevisAuth in the fallback case very similar to its approach in the standard case.
:::

The fallback process consists of the following steps:

1. The web browser connects with the relying party asking for a service (access to a protected resource, do a credit card purchase, etc.). The relying party notes that the user must authenticate.
2. The relying party sends a request to nevisFIDO asking to authenticate the user. This is done by invoking a dispatcher, such as the Firebase Cloud Messaging dispatcher.
3. nevisFIDO returns a dispatch response to the relying party. This response contains a nevisFIDO session ID (*sessionID1*). The relying party uses the returned nevisFIDO session ID to determine whether the user authenticated in nevisFIDO.
4. The relying party forwards the nevisFIDO response to the web browser.
5. The web application running in the web browser decides that a fallback authentication is required. Multiple criteria can lead to this decision: Too much time has passed since the triggering of the initial authentication, the user wants to use an alternative authentication mechanism, etc. The web browser connects with the relying party asking for a new authentication with a fallback authentication method.
6. The relying party sends a request to nevisFIDO asking to authenticate the user with the fallback mechanism. If the fallback mechanism is QR code, nevisFIDO invokes the QR Code dispatcher. If the fallback mechanism is deep link, nevisFIDO invokes the Link dispatcher.
7. nevisFIDO returns the dispatch response to the relying party. This response contains a nevisFIDO session ID (*sessionID2*). The relying party uses the returned nevisFIDO session ID to determine whether the user authenticated in nevisFIDO.
8. The relying party forwards the nevisFIDO response to the web browser.
9. The web browser receives the nevisFIDO response. If QR code is used, the user scans the rendered QR code with the mobile authentication application. If a deep link is used, the user clicks the link to open the mobile authentication application. In both cases, the information is transmitted from the web browser to the authentication application.
10. The user authenticates using the mobile device.
11. The relying party checks with nevisFIDO whether the user has been authenticated. For this, the relying party uses the relevant session ID. The check can be triggered either by the relying party itself or indirectly by the web browser (by asking the relying party to do the check). If the user has been authenticated, the relying party gives access to the requested service. In case of a transaction confirmation, like a credit card payment, the relying party must guarantee that the payment is done only once. If the relying party allows authentication with the initial nevisFIDO session (*sessionID1*), either *sessionID1* or *sessionID2* should result in a single payment (for more information, see the info box above).

The following figure shows the fallback scenario if a user wants to access an e-banking application via the web browser in a desktop:

<img className="boxed" src={require('../../assets/mobile-auth/uc-oob-authentication-fallback-desktop.drawio.png').default} alt="Fallback Out-of-Band Authentication Using Desktop"/>

The figure below shows the fallback scenario if a user wants to access the e-banking application via his/her mobile device:

<img className="boxed" src={require('../../assets/mobile-auth/uc-oob-authentication-fallback-mobile.drawio.png').default} alt="Fallback Out-of-Band Authentication Using Mobile Only"/>

:::info

In the Nevis Mobile Authentication solution, it is the web application (the client) that decides whether to trigger a fallback authentication. Theoretically, it is also possible to decide this at the relying party level (the backend). However, this should be avoided:

* Using a fallback mechanism has an impact on the user interaction. This means that the client application is necessarily impacted anyway. Leaving most of the fallback logic at the client level keeps things simple at the backend.
* Some relying parties (such as nevisAuth) can only determine limited fallback criteria. Leaving this decision at the client level makes the mechanism more flexible and thus allows for a better user experience.

:::
--------------------------------------------------------------------------------
Section: ### high-level-architecture.md
---
sidebar_position: 11
---

# High-Level Architecture

To provide mobile authentication, Nevis Mobile Authentication relies on several Nevis components which contribute to the overall mobile authentication solution. The central components use are depicted in the following figure.

<img className="boxed" src={require('../../assets/mobile-auth/nevis-mobile-authentication-architecture.png').default}
alt="Nevis Mobile Authentication architecture"/>

Within the Nevis architecture, nevisFIDO acts as a service to implement the FIDO UAF 1.1 specification standard.

The nevisFIDO component tightly integrates with other Nevis components to deliver the complete mobile authentication feature. In the sections that follow, we highlight briefly the functions of the subsystems that work together to ultimately deliver mobile authentication to the client device in the hands of a user.

## Client Device

The client device represents the physical device owned by a user, e.g. a mobile phone. To use and benefit from Nevis Mobile Authentication, the client device requires a Relying Party mobile client to interact and authenticate against a Relying Party backend. The Relying Party mobile client consists of a Client (Business)
Application and the FIDO Client.

## Relying Party Backend

The relying party backend characterizes the **group of components** which in combination act together as the Relying Party backend of a FIDO Relying Party client. In the context of FIDO, communication between a FIDO Client and a FIDO Server *always* occur via the Relying Party client and Relying Party backend. In Nevis Mobile Authentication, it not only includes the necessary Nevis components described below but also the protected backend entity named *Web application* in the above figure.
--------------------------------------------------------------------------------
Section: #### nevisProxy
Towards the client-facing edge of the system, the **nevisProxy** component serves as the perimeter server. It's able to protect web applications from unauthenticated access and ensures that authentication takes place before requests are passed to those web applications. In Nevis Mobile Authentication, nevisProxy is configured to accept requests according to the FIDO UAF 1.1 protocol and forwards them to the authentication subsystem. As in all Nevis setups, additional functions of nevisProxy are web application firewall, session management (single sign-on), and reverse proxy functionality like routing and rerouting of requests to downstream components. In Nevis Mobile Authentication,o pevisProxy will route HTTP requests to the communication endpoints of nevisFIDO and nevisAuth, which in combination form
the authentication subsystem.
--------------------------------------------------------------------------------
Section: ### reference-deployment.md
---
sidebar_position: 18
---

# Reference Deployment

## Minimal Recommended Physical Deployment Infrastructure

The figure shows a typical, minimal deployment of the Nevis Mobile Authentication solution. The perimeter infrastructure consists of a Linux Server environment running *nevisProxy*to protect access to the internal application environment.
This in term is split into two servers, one running the relying party application,
the other one running the authentication environment consisting of *nevisAuth* and *nevisFIDO* and the identity management environment, consisting of *nevisIDM.*

:::info

Note that this solution outline does *not* provide load balancing capabilities.
:::

<img className="boxed" src={require('../../assets/mobile-auth/reference-deployment-diagram.png').default} alt="Nevis Mobile Authentication Reference Deployment Diagram"/>

## Scaling

Performance related scaling of the infrastructure can be achieved by vertical or horizontal scaling. Vertical scaling refers to increasing the hardware resources of the involved components (CPU, RAM). For more information regarding hardware and software requirements, see the [System Requirements](system-requirements) chapter.
--------------------------------------------------------------------------------
Section: ### Horizontal Scaling
Horizontal scaling can be achieved by using a shared, database backed session and token storage.

Multiple scaling setups are possible, the following figure outlines the two most likely ones:

<img className="boxed" src={require('../../assets/mobile-auth/horizontal-scaling.png').default} alt="Horizontal scaling examples"/>

* In the *instance based round robin* approach, one nevisAuth instance is configured to connect to two nevisFIDO
  instances using round robin.
* In the *"vertical line" load balancing*approach, a dedicated load balancer is used to balance the incoming requests
  between two (or more) complete Nevis authentication suite setups. In this example, the load balancer is placed in
  front of *nevisProxy,*however it can potentially be placed at different levels as well.
--------------------------------------------------------------------------------
Section: ### nevisadmin-plugin-authcloud.md
---
sidebar_position: 60
---
# nevisadmin-plugin-authcloud

## Authentication Cloud Login

Connects to the Nevis [Authentication Cloud](https://docs.nevis.net/authcloud/).

This step adds mobile authentication to your authentication flow.

You need an access app use this step.

The user must be registered in your Authentication Cloud instance. 
You can use the `Authentication Cloud Onboarding` pattern for that.

When the user exists, login confirmation is requested.
By default, a push notification is sent to trigger the Nevis Access App.

However, you can also show a QR code instead (see `Authentication Type`).

If the user is not registered or has no active authenticator,
the `On User Not Exists` exit will be taken and no screen will be shown.

Your authentication flow should include any of the following patterns in front of this pattern:

- `nevisIDM Password Login`: use when mobile authentication shall be a second factor
- `nevisIDM User Lookup`: use for passwordless login

nevisAuth will connect to your Authentication Cloud instance using TLS, so the CA certificate of the endpoint needs to be trusted.

If you get an `unable to find valid certification path to requested target` 
error in the nevisAuth log, then you have to import the CA certificate of the Authentication Cloud
endpoint into the `Default Backend Trust Store` of the `nevisAuth Instance`.
--------------------------------------------------------------------------------
Section: ### Proxy Server
If you have to go through a forward proxy for the outbound connection to firebase
enter the hostname:port here.

At the moment only HTTP proxy is supported.

## Authentication Cloud Onboarding

Connects to the Nevis [Authentication Cloud](https://docs.nevis.net/authcloud/).

This step can be used to enroll users. 

You need an access app use this step.

A QR code is shown which has be scanned with the app.

If the user is already registered and has an active authenticator,
the `On User Exists` exit will be taken and no screen will be shown.

Your flow should include any of the following patterns in front of this pattern:

- `nevisIDM Password Login`: use when Auth Cloud shall be used as second factor
- `nevisIDM User Lookup`: use for passwordless login

nevisAuth will connect to your Authentication Cloud instance using TLS
and thus the CA certificate of the endpoint needs to be trusted.

If you get an `unable to find valid certification path to requested target` error
in the nevisAuth log, then you have to import the CA certificate of the Authentication Cloud
endpoint into the `Default Backend Trust Store` of the `nevisAuth Instance`.
--------------------------------------------------------------------------------
Section: ### AuthState Class
Select one of the available implementations.

When `ScriptState` is selected, all requests sent by JavaScript are directed towards nevisAuth.
The script takes care of the communication with the nevisFIDO component, and thus you can restrict access to nevisFIDO. 
There is no need to expose any nevisFIDO APIs on the nevisProxy `Virtual Host`.

When `Fido2AuthState` is selected, configuration for `Fido2AuthState` is generated.
FIDO2 related requests are sent to nevisFIDO instead. This requires that the following nevisFIDO APIs 
are exposed on the nevisProxy `Virtual Host`:

- `/nevisfido/fido2/attestation/options`
- `/nevisfido/fido2/assertion/result`
- `/nevisfido/fido2/status`

The easiest way to ensure this is to add a `nevisFIDO FIDO2 REST Service` pattern to your project.

It is recommended to select the `Fido2AuthState` implementation as it is a more pragmatic solution whereas
the `ScriptState` is likely to be decommissioned.

This pattern is experimental and likely to change in future releases.
--------------------------------------------------------------------------------
Section: ### Authentication Level
Authentication level that is set on success.


## FIDO2 Management Demo

#*DEMO/TESTING ONLY - NOT FOR PRODUCTION USE*

Serves a simple HTML page with JavaScript to register a FIDO2 authenticator.

This is a simple and bare-bone example for demonstration and testing purposes and not intended for production use. 
It works only when the extId is used as username.
Provide your own version adapted to your integration scenario.

For instance, use `Hosting Service` to deploy your HTML and JavaScript on a nevisProxy `Virtual Host` 
or `Generic Authentication Step` when the registration shall be done within an authentication flow.

Visit the official [WebAuthn Guide](https://webauthn.guide/) for further information 
on how to do FIDO2-based registration and authentication.

The `nevisFIDO FIDO2 Instance` must be exposed on the same `Virtual Host`
using `nevisFIDO FIDO2 REST Service` pattern.

In the `nevisFIDO FIDO2 Instance` pattern `Relying Party ID` and `Relying Party Origins` must be set correctly, 
to allow AJAX calls from the JavaScript.

The client certificate used by `nevisFIDO FIDO2 Instance` must be uploaded as a certificate credential
for the `nevisfido` technical user. This should be done automatically in Kubernetes deployments but best double-check.

The credential type 23 must be allowed in the nevisIDM unit policy so that a FIDO2 Authenticator credential
can be created for the authenticated user.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Frontend Path
Enter the path where this example shall be exposed on the nevisProxy `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store provider for the HTTPs endpoint.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for SecToken verification.
--------------------------------------------------------------------------------
Section: ### Key Store
Assign a key store to be used for the 2-way TLS connection to nevisIDM.

If no pattern is assigned an automatic key store will be generated. 
This requires automatic key management to be enabled in the inventory.
Further, the pattern assigned to `nevisIDM` must be a `nevisIDM Instance`
which uses an automatic trust store for the `Frontend Trust Store`.

Note that it is required that the certificate used by nevisFIDO to connect to nevisIDM
is uploaded as a certificate credential for the `nevisfido` technical user.
This is done automatically when deploying to Kubernetes and using automatic key management 
on both sides. In any other case, this step has to be done manually.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the trust store for validating the nevisIDM endpoint.

The trust store should contain the certificate of the CA that
has issued the server certificate.

If no pattern is assigned an automatic trust store will be generated.
This requires automatic key management to be enabled in the inventory.

In that case the pattern assigned to `nevisIDM` must be a `nevisIDM Instance` pattern
which uses an automatic key store for the `Frontend Key Store`.
--------------------------------------------------------------------------------
Section: ### Syslog Host
Defines where to send logs to via syslog.

This configuration is used only when syslog forwarding is enabled (see `Log Targets`).

The syslog facility is `localhost3` and the threshold is `INFO`.

## nevisFIDO FIDO2 REST Service

Set up access to a `nevisFIDO FIDO2 Instance` on a nevisProxy `Virtual Host`.

This pattern will be adapted depending on the requirements of 
upcoming FIDO 2 use case patterns.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used by this pattern to establish a connection with the nevisAdapt component.
This trust store must trust the `nevisAdapt Instance`'s key store. Please reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin automatic key management.
--------------------------------------------------------------------------------
Section: ### TLS Encryption
If `enabled` the query parameter `useSSL=true` will be added to enable 1-way TLS.

If no `Trust Store` is assigned then `trustServerCertificate=true` will be added to the connection string.

Assignment of a `Trust Store` is recommended for production use.

**Note:** `PostgresSQL` database connection configuration doesn't support TLS connection yet.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### nevisAuth Instance
Add nevisAuth Instance reference pattern(s) to enable session termination in connected components. 
If the session store is shared, it is enough to add one instance per database.

Please make sure that all involved nevisAuth Instances have ManagementService enabled.
Add or extend a `Generic nevisAuth REST Service` for each with the following configuration:

```
<RESTService name="ManagementService" class="ch.nevis.esauth.rest.service.session.ManagementService" />
```
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for verifying the NEVIS SecToken. If no pattern is assigned the signer key will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### Syslog Host
Defines where to send logs to via syslog.

This configuration is used only when syslog forwarding is enabled (see `Log Targets`).

The syslog facility is `localhost3` and the threshold is `INFO`.

## nevisAdapt REST API

The pattern exposes the nevisAdapt REST API on a nevisProxy `Virtual Host`.

The nevisAdapt REST API is available via `/nevisadapt/api`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the trust store for outbound TLS connections.

If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisAdapt Instance`
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### CSRF Protection
_Cross-Site Request Forgery_ (_CSRF_) is an attack to force an authenticated user to send unwanted requests.

- `off (default)` - no CSRF protection. Recommended for applications which may be called from other sites.
- `header-based` - `GET` and `HEAD` requests are allowed (assumption: these methods must not manipulate server-side state). 
For other requests the `Referer` and `Origin` headers must match the `Host` header.

## nevisAdapt Remember Me Step

Using the pattern, you can integrate nevisAdapt as a remember-me service in nevisAuth.

If the provided token is found and still valid, the authentication process is cut shorter.

If no remember-me token is provided or it's no longer valid, the step generates a new one
then initiates the original full authentication process. If all the authentication steps
complete successfully, nevisAdapt persists the new token so that it can be used for quick
entry later. Keep `On Success` empty in order to shortcut the authentication flow.

CAUTION: if `On Success` and `Original Authentication Flow` are set to the same step, it disables
the remember-me functionality.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used by this pattern to establish a connection with the nevisAdapt component.
This trust store must trust the `nevisAdapt Instance`'s key store. Please reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin automatic key management.
--------------------------------------------------------------------------------
Section: ### Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for verifying the NEVIS SecToken. If no pattern is assigned the signer key will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign an add-on pattern to customize the configuration.

## nevisDetect Administration GUI

The pattern exposes the nevisDetect Frontend GUIs on a nevisProxy `Virtual Host`.

The Administration GUI is available on `/nevisdetect/admin`.
--------------------------------------------------------------------------------
Section: ### nevisDetect Admin
Reference for the pattern with the details of the web application.

Supported patterns:
- nevisDetect Admin Instance
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the trust store for outbound TLS connections.

If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisDetect Admin`
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### TLS Encryption
If `enabled` the query parameter `useSSL=true` will be added to enable 1-way TLS.

If no `Trust Store` is assigned then `trustServerCertificate=true` will be added to the connection string.

Assignment of a `Trust Store` is recommended for production use.

**Note:** `PostgresSQL` database connection configuration doesn't support TLS connection yet.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Sub-path Restriction
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for verifying the NEVIS SecToken. If no pattern is assigned the signer key will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign an add-on pattern to customize the configuration.

## nevisDetect Persistency REST API

The pattern exposes the nevisDetect Frontend GUIs on a nevisProxy `Virtual Host`.

The nevisDetect Persistency REST API is available on `/nevisdetect/persistency`.
--------------------------------------------------------------------------------
Section: ### nevisDetect Persistency
Reference for the pattern with the details of the web application.

Supported patterns:
- nevisDetect Persistency Instance
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the trust store for outbound TLS connections.

If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisDetect Persistency`
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which shall be used for outbound TLS connections to nevisIDM.
If no pattern is assigned no trust store will be generated.

For nevisDataPorter to use the trust store,
the following expressions should be used inside the `dataporter.xml` file:

```
${idm.truststore}
${idm.truststore.password}
```

Example configuration:

```xml
<object type="NevisIDMConnectionPool" name="adminService">
    <dp:paraVal name="endpoint" value="${cfg.idmEndpoint}"/>
    <dp:paraVal name="loginMode" value="proxyCert"/>
    <dp:paraMap name="sslSettings">
        <value name="javax.net.ssl.trustStore" value="${idm.truststore}"/>
        <value name="javax.net.ssl.trustStorePassword" value="${idm.truststore.password}"/>
        ...
    </dp:paraMap>
</object>
```
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.


## OAuth 2.0 / OpenID Connect Metadata Endpoint

Sets up a Metadata endpoint for OAuth 2.0 / OpenID Connect.
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.


## OAuth 2.0 / OpenID Connect Pushed Authorization Request Endpoint

Sets up a Pushed Authorization Request endpoint for OAuth 2.0 / OpenID Connect.
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### OpenID Connect Issuer
Enter the _issuer_ for OpenID Connect.

The value must be a case-sensitive URL using the https scheme that contains at least scheme and host.
The port number and path component are optional. No query or fragment components are allowed.

If not set the issuer will be calculated based on:

- the first `Frontend Address` with scheme `https` of the assigned `Virtual Host`
- the first `Frontend Path`
--------------------------------------------------------------------------------
Section: ### JWK Set Endpoint Trust Store
Assign a trust store for the outbound TLS connection to JWK Set endpoint for ID Token encryption.

Import the CA certificate of the `JWK Set endpoint` into this trust store.

Since version 4.38 nevisAuth trusts CA certificates included in the JDK.

Thus, it is not required to configure this.

However, you can still configure a trust store here to be as strict as possible.
--------------------------------------------------------------------------------
Section: ### On Success
The step executed after a successful authentication.
If no step is configured here the process ends with `AUTH_DONE`.

**Note**: In order to have profile selection in case account have multiple profiles, you need to use the User Lookup pattern.

## nevisMeta Connector

Use to connect to an existing nevisMeta instance.

Use the pattern only when the instance is not set up by this project.

Ensure that the SecToken trust store of the instance allows the 
SecToken signers used in this project.
--------------------------------------------------------------------------------
Section: ### TLS Encryption
If `enabled` the query parameter `useSSL=true` will be added to enable 1-way TLS.

If no `Trust Store` is assigned then `trustServerCertificate=true` will be added to the connection string.

Assignment of a `Trust Store` is recommended for production use.

**Note:** `PostgresSQL` database connection configuration doesn't support TLS connection yet.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store for the HTTPs endpoint.

If no pattern is assigned a Trust Store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign a Trust Store which is used to validate the signature of a received NEVIS SecToken.

There are 2 use cases which require validation:

- when a user accesses the `nevisMeta Web Console` the SecToken is signed using `NEVIS SecToken` / `Key Store`.
- when nevisAuth calls nevisMeta the SecToken is signed using `nevisAuth Instance` / `Internal SecToken Signer`.

If no pattern is assigned the trust store will be provided by nevisAdmin 4 automatic key management. 
However, this requires that automatic key management is used in the `NEVIS SecToken` and `nevisAuth Instance` patterns.
--------------------------------------------------------------------------------
Section: ### Client Authentication
Setting for 2-way TLS on the nevisMeta HTTPs endpoint. There are 3 options will
affect the callers (e.g. nevisProxy or technical clients accessing nevisAuth REST APIs)

* required: Callers **must** present a client certificate.
* requested: Callers **can** present a client certificate.
* disabled: Callers **must not** use a client certificate.

The `Frontend Trust Store` must contain the issuing CA.
--------------------------------------------------------------------------------
Section: ### Syslog Host
Defines where to send logs to via syslog.
 
This configuration is used only when syslog forwarding is enabled (see `Log Targets`).

The syslog facility is `localhost3` and the threshold is `INFO`.

## nevisMeta REST Service

The pattern exposes the nevisMeta REST API on a nevisProxy `Virtual Host`.

The REST API is exposed on the path `/nevismeta/rest`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign add-on patterns to customize the behaviour of this service.

Example use cases:

- `Authorization Policy` to enforce roles or an authentication level.
- `URL Handling` to redirect or forward requests.
- `HTTP Header Customization` to add, replace, or remove HTTP headers in requests or responses.


## nevisMeta Web Console

Sets up the [nevisMeta Web Console](https://docs.nevis.net/nevismeta/Concept-Description-and-Technical-Architecture/Architecture-overview#web-console), 
which is a component supporting the setup of OAuth2 and OpenID Connect for nevisAuth.

You can access the Web console on the assigned Virtual Host.

For instance, let's say your domain is example.com, and you have entered https://example.com as a Frontend Addresses in the Virtual Host pattern. This means that you can access the Web console on https://example.com/nevismeta/.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the Trust Store provider for outbound TLS connections.
If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisMeta`
--------------------------------------------------------------------------------
Section: ### On Entry
Point to the first step of the authentication process.

## Authentication Done

Completes an authentication flow.

The pattern may only be used as the last step within an authentication flow.

Use as explicit follow-up for patterns such as `Generic Authentication Step` and `User Information`
which do not add follow-up steps automatically.

## Authentication Failed

Shows a GUI with the error message `error_99`.
When the GUI is shown, the session is terminated.

If `HTTP Error Code` is configured and the configured code is handled on the nevisProxy `Virtual Host`
then the GUI is not shown, and a static error page is presented instead.

The pattern may only be used as the last step within an authentication flow.

Use as explicit follow-up for patterns such as `Generic Authentication Step` and `User Information`
which do not add follow-up steps automatically.
--------------------------------------------------------------------------------
Section: ### HTTP Error Code
Enter a status code for error page produced by nevisAuth.
If not set the status code will be `200`.

Note that the error page from nevisAuth will not be shown, 
when error handling is applied by nevisProxy.

nevisProxy replaces the body of the HTTP response, when there is a page for this status code, 
uploaded to `Hosted Resources` of the `Virtual Host`, or to a `HTTP Error Handling` pattern.

## Authentication Realm

This pattern defines how to authenticate access to applications.

You can assign this pattern to your applications as `Authentication Realm`,
or expose it as a `SAML IDP` or `OAuth 2.0 Authorization Server / OpenID Provider`.

Examples how to authenticate your users can be found in the [Concept & Configuration Guide](https://docs.nevis.net/configurationguide/use-cases/Authentication/).

The authentication processes are provided by a `nevisAuth Instance` which has to be assigned.
For rendering the pages during authentication, nevisLogrend is used.
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.

If no pattern is assigned automatic key management is used to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses 
for validating the signature of the NEVIS SecToken issued by nevisAuth. 

If no pattern is assigned automatic key management is asked to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter` generated by this pattern.

Most realms generate only 1 `IdentityCreationFilter` named `Authentication_<name>`, 
which is used to protect the application.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                 |
|----------------------|---------------------------------------|
| BodyReadSize         | 64000                                 |
| InterceptionRedirect | Condition:ENV:HTTP_USER_AGENT:mozilla\|Mozilla\ninitial\nnever |
| ClientCert           | want                                  |
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### nevisProxy: Simple Template
nevisProxy provides a simple login page renderer which can be used instead of nevisLogrend.
See `Login Renderer` for details.

For each enabled language (e.g. `en`) upload a file named `<lang>_template.html`.
The template must contain the placeholder `NEVIS_AUTH_FORM`. 

If your templates require additional resources (e.g. CSS, images)
upload them as `Hosted Resources` on the nevisProxy virtual host.
--------------------------------------------------------------------------------
Section: ### Language Cookie Domain
Enter a domain for the cookie that nevisLogrend issues 
to remember the language of the user.

This setting should only be used when you want to issue a _wildcard cookie_
to share the language with other sub-domains (e.g. across multiple `Virtual Host`).

For instance, if you enter `.example.com` then 
the cookie will also be sent to `subdomain.example.com`.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.

If no pattern is assigned automatic key management is used to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses 
for validating the signature of the NEVIS SecToken issued by nevisAuth. 

If no pattern is assigned automatic key management is asked to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter` generated by this pattern.

Most realms generate only 1 `IdentityCreationFilter` named `Authentication_<name>`, 
which is used to protect the application.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                 |
|----------------------|---------------------------------------|
| BodyReadSize         | 64000                                 |
| InterceptionRedirect | Condition:ENV:HTTP_USER_AGENT:mozilla\|Mozilla\ninitial\nnever |
| ClientCert           | want                                  |
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### nevisProxy: Simple Template
nevisProxy provides a simple login page renderer which can be used instead of nevisLogrend.
See `Login Renderer` for details.

For each enabled language (e.g. `en`) upload a file named `<lang>_template.html`.
The template must contain the placeholder `NEVIS_AUTH_FORM`. 

If your templates require additional resources (e.g. CSS, images)
upload them as `Hosted Resources` on the nevisProxy virtual host.
--------------------------------------------------------------------------------
Section: ### Custom Dependencies
In case your `AuthState` elements use custom classes upload the required JAR file(s) here.

Files uploaded here will be deployed into the `lib` directory of the nevisAuth instance.

## Generic Authentication Service

Defines an authentication service which is exposed 
on the given `Frontend Path` on the assigned `Virtual Host`.

Requests received on this path are forwarded to nevisAuth.

Use to import an existing configuration.

We recommend you implement complex self-service and registration processes in a dedicated application, 
for example, using the SOAP or REST API of nevisIDM.

The pattern can also provide authentication for applications exposed on nevisProxy,
see `Generic Authentication Realm` for details.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve
as entry point for this authentication service.
--------------------------------------------------------------------------------
Section: ### Frontend Path
Define a path to be mapped on the assigned virtual host.

Requests sent to this path will be forwarded to nevisAuth
so that they can be handled by this authentication service.
--------------------------------------------------------------------------------
Section: ### Configuration
Enter `AuthState` elements as XML.

The `Domain` element is optional.

- If missing the element will be created. The `Entry` methods 
`authenticate` and `stepup` will be set to the first provided `AuthState`. 
The method `logout` is not set and thus the nevisAuth default behaviour applies.

- If provided the `Domain` must come before all `AuthState` elements. 
The attributes `name` and `default` are not supported and should be omitted.
Attributes are sorted by name. The `Entry` elements are sorted by `method`.

The `AuthState` linked to `stepup` should be able to dispatch the request.
For instance, you may have assigned an `Authorization Policy` to your application(s)
and thus you need a state which decides based on the request variable `requiredRoles`.

The following example dispatches level `2` into an `AuthState` named `TAN`
which provides authentication via mTAN:

```
<AuthState name="EntryDispatcher" class="ch.nevis.esauth.auth.states.standard.ConditionalDispatcherState" final="false">
    <ResultCond name="nomatch" next="Authentication_Done"/>
    <ResultCond name="level2" next="TAN"/> <!-- TAN state is expected to set authLevel="2" -->
    <Response value="AUTH_ERROR">
        <Arg name="ch.nevis.isiweb4.response.status" value="403"/>
    </Response>
    <property name="condition:level2" value="${request:requiredRoles:^2.*$:true}"/>
</AuthState>
```

The following expressions are supported:

- `${instance}`: name of the nevisAuth instance
- `${request_url}`: generates a nevisAuth expression which returns the URL of the current request
- `${realm}`: name of the Realm (see below)
- `${service_url}`: generates a nevisAuth expression which evaluates to true for requests received on the configured `Frontend Path`
- `${service.postfix}`: in Kubernetes side-by-side deployment a postfix is added to service names. Use this expression when connecting to a service deployed against the same inventory.
- `${keystore}`: name of the `KeyStore` element provided by this pattern. Assign a pattern to `Key Objects` to add a `KeyObject` into this `KeyStore`. 

The `name` of `AuthState` elements is prefixed 
with the sanitized name of the Realm (referred to as `${realm}`).

The realm prefix must be added when using `propertyRef` to reference AuthStates
generated by other patterns (e.g. `<propertyRef name="${realm}_SomeState"/>`).

An exception is the AuthState which defines the nevisIDM connection 
(as generated by `nevisIdm Password Login` or `nevisIDM Connector for Generic Authentication`).
Here the `propertyRef` must be defined as follows: 

`<propertyRef name="nevisIDM_Connector"/>`

This pattern does not validate that labels are translated.
Translations can be provided on the `Authentication Realm` pattern.
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.

If no pattern is assigned automatic key management is used to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses 
for validating the signature of the NEVIS SecToken issued by nevisAuth. 

If no pattern is assigned automatic key management is asked to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter` generated by this pattern.

Most realms generate only 1 `IdentityCreationFilter` named `Authentication_<name>`, 
which is used to protect the application.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                 |
|----------------------|---------------------------------------|
| BodyReadSize         | 64000                                 |
| InterceptionRedirect | Condition:ENV:HTTP_USER_AGENT:mozilla\|Mozilla\ninitial\nnever |
| ClientCert           | want                                  |
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### nevisProxy: Simple Template
nevisProxy provides a simple login page renderer which can be used instead of nevisLogrend.
See `Login Renderer` for details.

For each enabled language (e.g. `en`) upload a file named `<lang>_template.html`.
The template must contain the placeholder `NEVIS_AUTH_FORM`. 

If your templates require additional resources (e.g. CSS, images)
upload them as `Hosted Resources` on the nevisProxy virtual host.
--------------------------------------------------------------------------------
Section: ### Frontend Path Settings
Assign add-on patterns to customize the `Frontend Path`.

## Generic Authentication Step

Define an `authentication step` using XML elements as described in the nevisAuth reference guide. 

An `authentication step` consists of one or multiple `AuthState` elements which belong together, 
for example, username / password login against LDAP with enforced password change.
--------------------------------------------------------------------------------
Section: ### Authentication Application
Optionally assign an application which provides the authentication service
and shall be exposed on the same virtual host as the applications.

Not required for federation-based authentication 
where the authentication service is hosted on another domain.
--------------------------------------------------------------------------------
Section: ### Environment Variables
Add additional environment variables to the nevisAuth `env.conf`.

The standard environment variables `RTENV_SECURITY_CHECK` and `JAVA_OPTS`
will always be present in `env.conf` and can't be overwritten using this setting.


## Generic nevisAuth REST Service

Configures a nevisAuth REST service 
using the XML syntax described in the [nevisAuth Technical Documentation](https://docs.nevis.net/nevisauth/setup-and-configuration/components/rest-service-api).

The service is not exposed on a nevisProxy `Virtual Host`, 
it is accessible on the assigned `nevisAuth` only.

The XML attribute `path` defines which requests are handled.
--------------------------------------------------------------------------------
Section: ### Template Parameters
Define _Template Parameters_.

Examples:

```yaml
smtp: smtp.siven.ch
sender: noreply@siven.ch
```

These parameters can be used in your `Configuration`.

The expression formats are:

`${param.<name>}`:

- `name` found: parameter value is used.
- `name` missing: expression is **not** replaced.

`${param.<name>:<default value>}`:

- `name` found: parameter value is used.
- `name` missing: default value will be used.

In `<default value>` the character `}` must be escaped as `\}`.

## Generic nevisAuth Web Service

Configures a nevisAuth Web service 
using the XML syntax described in the [nevisAuth Technical Documentation](https://docs.nevis.net/nevisauth/setup-and-configuration/components/soap-web-services).

The service is not exposed on a nevisProxy `Virtual Host`, 
it is accessible on the assigned `nevisAuth` only.

The XML attribute `uri` defines which requests are handled.
--------------------------------------------------------------------------------
Section: ### Parameters
Define _Parameters_ to be used in the `JSON Response`.

Examples:

```yaml
backend-host: backend.siven.ch
```

The expression formats are:

`${param.<name>}`:

- `name` found: parameter value is used.
- `name` missing: expression is **not** replaced.

`${param.<name>:<default value>}`:

- `name` found: parameter value is used.
- `name` missing: default value will be used.

In `<default value>` the character `}` must be escaped as `\}`.


## JWT Token

Assign to a realm using `Application Access Tokens` 
to allow the realm to produce a JWT token.

To issue a JWT token and propagate it to applications you also have to assign the pattern to
the corresponding `Web Application`, `REST Service`, or `SOAP Service` 
using `Application Access Token`.

The JWT token is sent in an HTTP header (default: `Authorization`) 
in the format `Bearer <token>`.
--------------------------------------------------------------------------------
Section: ### Frontend Addresses
Enter the `Frontend Addresses` of the nevisProxy `Virtual Host` patterns 
for which this pattern provides authentication.

Example:

- `www.siven.ch`

In case multiple values are configured you can define which `Keytab File` or `Keytab File Path` 
to use by referencing its file name.

Example:

- `www.siven.ch -> kerberos_ch.keytab`
- `www.siven.de -> kerberos_de.keytab`
--------------------------------------------------------------------------------
Section: ### Frontend Addresses
Enter the `Frontend Addresses` of the nevisProxy `Virtual Host` patterns 
for which this pattern provides authentication.

Example:

- `www.siven.ch`

In case multiple values are configured you can define which `Keytab File` or `Keytab File Path` 
to use by referencing its file name.

Example:

- `www.siven.ch -> kerberos_ch.keytab`
- `www.siven.de -> kerberos_de.keytab`
--------------------------------------------------------------------------------
Section: ### On Failure
Assign authentication step that is processed if Kerberos authentication fails.

If no step is assigned an AuthState `Authentication_Failed`
will be created automatically.

## LDAP Login

Username / password login for LDAP.

For `Web Application`, an initial redirect (to `?login`) is performed and a login GUI is shown.

Basic authentication may be used to call a REST or SOAP service.

Double-check the URL you are calling as 
nevisProxy responds with a redirect if no servlet could be found otherwise (`trailingSlashRedirect`).
--------------------------------------------------------------------------------
Section: ### LDAP Endpoints
Configure the LDAP endpoint.
The URL must start with `ldap://` or `ldaps://`

In case of `ldaps://` you may have to import the certificate of the CA which has issued the certificate of the LDAP server into the `Backend Trust Store` on the `nevisAuth Instance`.
--------------------------------------------------------------------------------
Section: ### Gui Title
Change the Gui title.

We recommend to enter a label here and provide translations for this label in the `Authentication Realm`.


## NEVIS SecToken

Assign to a realm using `Application Access Tokens`.
This enables the realm to produce a Nevis SecToken.

To issue a SecToken and propagate it to applications 
also assign the pattern to the corresponding `Web Application`, 
`REST Application`, or `SOAP Application` using `Additional Settings`.

On the application server you may use Ninja to extract the SecToken 
from the `Authorization` header. It is transferred as the Basic Auth password.

As Ninja validates the signature of the SecToken,
you have import the signer certificate into the Ninja truststore.
--------------------------------------------------------------------------------
Section: ### None Found
Assign a step to continue with when the user has **none** of the configured roles.

If no step is assigned, error code `403` will be returned in this case.


## SAML IDP

Sets up a SAML Identity Provider (_IDP_).

The `Authentication Realm` provides Single-Sign-On.

By default, only SP-initiated authentication is allowed. This method is most secure and standard.

Service providers (_SP_) may initiate authentication by sending an `AuthnRequest`
to any of the configured `Frontend Path(s)`.

You can enable IDP-initiated authentication via the `Authentication Type` drop-down.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
Define paths for the following cases.

- **SP-initiated authentication**

Service providers may send a parameter `SAMLRequest` containing an `AuthnRequest` (using POST or redirect binding) 
to request authentication. On successful authentication the IDP returns a SAML `Response`.

On entry an initial session will be created.
The session may expire during authentication due to timeout. 

When this happens an error page (name: `saml_dispatcher`) with title `title.saml.failed` 
and error message `error.saml.failed `will be rendered.

- **SP-initiated logout**

Service providers may send a `LogoutRequest` (POST or redirect binding)
to logout from this IDP and other service providers.

- **IDP-initiated logout**

Applications may have a link pointing to the IDP to trigger a global logout. 

This link may point to:

- `<path>/logout`: to show a logout confirmation page (GUI name: `saml_logout_confirm`, label: `info.logout.confirmation`)
- `<path>/?logout`: to skip the logout confirmation page.

If a `Referer` header has been sent by the browser, the logout confirmation page will have a `cancel` button which redirects to the referer.
Note that if the SP is NEVIS you may have to adapt the `Security Response Headers` of the `Virtual Host`.
By default, the header `Referrer-Policy: strict-origin-when-cross-origin` is set and this will prevent the path being sent so the `cancel` button will redirect to `/`.

During SAML logout the IDP renders a GUI named `saml_logout`
with the following hidden fields:

- `saml.logoutURLs`: the URL of the SPs including `LogoutRequest` message as query parameter
- `saml.logoutURL`: the URL to redirect to after successful logout

The default nevisLogrend template contains Javascript to invoke all `saml.logoutURLs`
and redirect to `saml.logoutURL` after all requests have been sent. This is a best effort operation 
which means that the JavaScript does not check if the logout was successful.

- **IDP-initiated authentication**

Requests to the base path without `SAMLRequest` will trigger IDP-initiated authentication.

In this case the following parameters must be sent: 

- `Issuer`: as entered for a `SAML SP Connector`
- `RelayState`: this parameter is returned to the SAML SP together with the `Response`
--------------------------------------------------------------------------------
Section: ### Metadata Service Path
Enter a path where the _SAML Metadata Service_ shall be exposed
on the assigned `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### IDP Issuer
Enter the `Issuer` of the IDP.

Example: `https://idp.example.org/SAML2`

The `Issuer` is used to look up the trust store 
containing the signer certificate of the IDP.

For this purpose a `KeyObject` element will be configured
in the nevisAuth `esauth4.xml` using the `Issuer` 
for the attribute `id`.
--------------------------------------------------------------------------------
Section: ### IDP URL
Enter the `Location` of the SAML `SingleSignOnService`.
This may be a URL or a path on the same virtual host.

nevisAuth will send an `AuthnRequest` to this location
to delegate the authentication or session upgrade process 
to the IDP.

By default, the `AuthnRequest` contains a `RequestedAuthnContext` 
which specifies the required authentication level.
You can disable this feature via `Custom Properties`.
--------------------------------------------------------------------------------
Section: ### IDP Signer Trust Store
Assign a pattern to configure the signer certificate of the identity provider.
--------------------------------------------------------------------------------
Section: ### Custom Follow-up Steps
Assign follow-up steps.
 
The order of steps is relevant. 
The first step in this list has index `1`. 
 
You may reference a step in the configuration
via the `Custom Transitions`.

## SAML Response Consumer

The pattern exposes an authentication service on the assigned `Virtual Host`.

The service can consume incoming SAML Response or SAML artifact messages,
and can execute an optional post-processing flow.

The overall process may work as follows:

- Consume a SAML `Response` and `RelayState` on the `Frontend Path`. The `RelayState` must contain the URL of an application.
- If configured, execute the `Post-Processing Flow`.
- The authentication is now done.
- Redirect to the `RelayState` parameter pointing to the application.
- Assuming the application is protected by the realm assigned to this pattern, the caller is allowed access.
--------------------------------------------------------------------------------
Section: ### Frontend Paths
Enter a path where SAML `Response` messages sent by an external IDP shall be consumed.

The external IDP may send messages using POST or redirect binding.
--------------------------------------------------------------------------------
Section: ##### SAML Artifact Binding
To use SAML Artifact Binding with a certain IDP,
the `Artifact Resolution Service` must be configured in the `SAML IDP Connector`.

The flow begins with the IDP sending an `ArtifactResponse` message to any of the configured frontend paths.

Now an `ArtifactResolve` message will be created and signed using this certificate.
The message will then be sent to the IDP via a server-to-server call.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Define custom `init-params` for the nevisProxy `DelegationFilter`
which propagates the SAML Response to the backend.

This setting is experimental and may be adapted in future releases.

Examples:

- `DelegatePostPolicy: override` - create a new POST request and send it to the `Assertion Consumer Service Path`. 
The response is returned to the client which means that the original (GET) request is lost. However, the SP can redirect to the application. This mode should be preferred for proper SP integration.

- `DelegatePostPolicy: sidecall` - send a POST request to the `Assertion Consumer Service Path` but do not return the response to the client. 
Afterwards, the original (GET) request is sent. This mode may be required in case the response of the POST request does not redirect to the application.

## SAML SP Connector

The pattern defines the connection to a SAML Service Provider (_SP_).

Assign the pattern to a `SAML IDP`.
--------------------------------------------------------------------------------
Section: ### SP URL - Assertion Consumer Service(s)
Enter the _Assertion Consumer Service URL_ of the SP.

Enter multiple values if the same SP can be accessed via multiple URLs.

If the SP is provided by a `SAML SP Realm` the URLs are structured as follows:

- scheme, host and port: `Frontend Addresses` of each `Virtual Host` where the `SAML SP Realm` is used.
- path component: `Assertion Consumer Service` of the `SAML SP Realm`.

The URLs are used during SP-initiated SAML authentication to validate incoming SAML requests.
The `assertionConsumerServiceURL` attribute of received SAML `AuthnRequest` messages must match one of these URLs.

The first URL is also used for IDP-initiated authentication (property `spURL` of the `IdentityProviderState`).

IDP-initiated authentication may be triggered by sending a request 
to any of the `Frontend Path(s)` of the `SAML IDP`.
The following parameters must be provided either in the query or as `POST` parameters:

- `Issuer` - the unique name used by the SP (also called `entityID` in the SAML metadata).
- `RelayState` - will be sent back to the SP together with the SAML `Response` when authentication is done. 
In case the SP is setup by a `SAML SP Realm` this should a URL of an application protected by this realm.
--------------------------------------------------------------------------------
Section: ### SP Signer Trust Store
Configure the trust store used to validate incoming SAML messages
(e.g. `AuthnRequest`, `LogoutRequest`) which are sent by this SP.
--------------------------------------------------------------------------------
Section: ### Message Encryption Trust Store
Assign a pattern to configure the certificate to encrypt the outgoing message to the service provider.
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.

If no pattern is assigned automatic key management is used to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses 
for validating the signature of the NEVIS SecToken issued by nevisAuth. 

If no pattern is assigned automatic key management is asked to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter`
generated by this pattern.

This pattern generates 2 `IdentityCreationFilter` elements:

1. `Authentication_<name>`: enforces authentication for applications.
2. `SAML_<name>`: provides the `Assertion Consumer Service` and `Session Upgrade Path`

If you want to patch only one of these filters 
consider using `Generic Application Settings` instead.

Note that the parameter `InterceptionRedirect` of the `SAML_<name>` filter
is forced to `never`. If you configure `InterceptionRedirect` here
it will be ignored for this filter as leads to message loss in SAML POST binding.

Examples:

- `BodyReadSize = 64000`
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### nevisProxy: Simple Template
nevisProxy also provides a simple login page renderer.

For each enabled language (e.g. `en`) upload a file named `<lang>_template.html`.
The template must contain the placeholder `NEVIS_AUTH_FORM`. 

If your templates require additional resources (e.g. CSS, images)
upload them as `Hosted Resources` on the nevisProxy virtual host.
--------------------------------------------------------------------------------
Section: ### Custom Properties
Enter custom properties for the nevisAuth `IdentityProviderState`
which issues the SAML `Response` (or `Assertion`).

Please check the technical documentation for details.

Common use cases are:

- `out.issuer`: sets the `Issuer` element (By default, the sanitized name of the pattern is used)
- `out.audienceRestriction`: some recipients require this to be set to decide if they accept the token
- `out.signatureKeyInfo`: add information about the signer certificate

Examples:

```
out.authnContextClassRef = urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
out.sessionIndex = ${notes:saml.assertionId}
out.signatureKeyInfo = Certificate
out.subject.format = urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified
out.ttl = 10
relayState = ${request:currentResource}
```

## SAP Logon Ticket

Assign to a realm using `Application Access Tokens` 
to allow the realm to produce an SAP Logon Ticket.

To issue an SAP Logon Ticket and propagate it to applications you also have to assign the pattern to
the corresponding `Web Application`, `REST Service`, or `SOAP Service` 
using `Application Access Token`.

The issued SAP Logon Ticket may either be propagated to the client as a cookie (for pseudo-federated scenarios 
based on shared cookie domain spaces) or propagated to a backend application behind a nevisProxy instance.
--------------------------------------------------------------------------------
Section: ### API Key
API key to connect to Sendgrid.

## Standalone Authentication Flow

Use this pattern to build custom self-admin use cases,
for example, user registration, password reset, mobile change.

The authentication flow is exposed on the assigned `Virtual Host`.
Requests received on the configured `Frontend Path` are dispatched into an authentication step.

The flow is always executed, even when the user already has an authenticated session.

Be aware that on successful execution of the flow,
the caller may be authenticated in the assigned `Authentication Realm`,
and thus will be able to access any applications protected by that realm.

For use cases which do not require an authenticated session
it is therefore recommended to use a separate realm.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
Enter frontend path(s) which should be handled.
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the allowed HTTP methods. 

If not configured, all HTTP methods are allowed.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store for the outbound TLS connection to SwissPhone.

Import the CA certificate of the `Portal Server` into this trust store.

Since version 4.38 nevisAuth trusts CA certificates included in the JDK.

Thus, it is not required to configure this. 

However, you can still configure a trust store here to be as strict as possible.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Database
By default, nevisAuth stores sessions and out of context data in memory.

In most setups you should use a database instead, and you should assign a `nevisAuth Database` pattern here.

In memory should be used only when there is only 1 line / pod of nevisAuth,
or in a classic deployment where nevisProxy can ensure session-sticky load balancing towards nevisAuth.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store provider for the HTTPs endpoint.
If no pattern is assigned the Trust Store will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### Client Authentication
Enable to enforce 2-way TLS on the nevisAuth HTTPs endpoint. 

This means that callers (e.g. nevisProxy or technical clients accessing nevisAuth REST APIs) must present a client certificate.

The `Frontend Trust Store` must contain the issuing CA.
--------------------------------------------------------------------------------
Section: ### Default Backend Trust Store
Assign the Trust Store provider for outbound TLS connections.
If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Signer Trust Store
Assign a trust store to validate the signature of the **internal** NEVIS SecToken.

This is an advanced setting and it is usually not required to configure this.

If no pattern, an `Automatic Key Store` pattern, or a `PEM Key Store`, 
is assigned to `Internal SecToken Signer Key Store`, then you **do not** have to configure this. 
The configuration of nevisAuth will be generated correctly, based on the deployment type and scaling.

Configuration is required in **classic VM deployment**, when this instance is deployed to multiple hosts,
**and** the hosts have **different** key material in the `Internal SecToken Signer Key Store`.
--------------------------------------------------------------------------------
Section: ### Line Preference
This setting (together with the inventory) defines the order of nevisAuth endpoints in the connection string from nevisProxy.

nevisAuth stores unauthenticated sessions in memory.
In a classic deployment to VMs, even when a `nevisAuth MariaDB Remote Session Store` is configured, 
sessions are synced to the DB only after successful authentication.
Thus, multi-step login flows require that requests for the same session are routed to the same nevisAuth endpoint.

nevisProxy uses a simple fail-over strategy. The first URL in the connection string for nevisAuth is always used,
unless this instance is not available. This strategy works well when:

* there is only 1 nevisProxy instance
* there are 2 lines of nevisProxy but line 1 is active and line 2 is standby
* there is a session-sticky load-balancer in front of nevisProxy is session-sticky

The order of the connection string depends on the inventory. See also:
[Defining Lines and Fail-over Association](https://docs.nevis.net/nevisadmin4/User-Guide/Infrastructure-Inventories/Working-with-Inventory-Files/Defining-Lines-and-Failover-Association)

This strategy may fail in active / active setups when line groups are defined in the inventory.
In such setups you can set this drop-down to `disabled` to ensure that the order in the connection string is the same on all nevisProxy lines.
--------------------------------------------------------------------------------
Section: ### Type
Select `key store` when a private key is needed.
Select `trust store` for providing trusted certificate (e.g. for signature validation).
--------------------------------------------------------------------------------
Section: ### Trust Store
Reference a trust store provider pattern or leave empty to let nevisAdmin establish a trust store.
This reference property is considered when type `trust store` is selected.

## nevisAuth Log Settings

Configure log levels and retention of nevisAuth logs.

Assign to a `nevisAuth Instance` via `Log Settings`.

In classic VM deployment nevisAdmin 4 does *not* restart the nevisAuth instance
when only log configuration is changed. New log configuration is reloaded within 60 seconds after deployment.
--------------------------------------------------------------------------------
Section: ### HTTPs
Choose between plain HTTP, normal HTTPs and mutual (2-way) HTTPs.
If `enabled` a `Key Store` is required.
If set to `mutual`, a `Trust Store` is required as well.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Used when mutual (2-way) HTTPs is configured.
If no pattern is assigned here automatic key management will provide the trust store.
--------------------------------------------------------------------------------
Section: ### Base Path
Set a custom path for nevisLogrend resources (e.g. CSS).
The path will be made accessible in nevisProxy.

You must change the path when using multiple nevisLogrend instances 
on the same virtual host.
--------------------------------------------------------------------------------
Section: ### Syslog Host
Defines where to send logs to via syslog.

This configuration is used only when syslog forwarding is enabled (see `Log Targets`).

The syslog facility is `localhost3` and the threshold is `INFO`.

## nevisProxy Login Renderer

Set up nevisProxy to use its own, internal renderer instead of nevisLogrend.

Assign the pattern to your realm using `GUI Rendering` / `Login Renderer`.

The nevisProxy Login Renderer is less powerful.
It simply translates GUI descriptors received from nevisAuth into an HTML form,
and puts them in a HTML template.

Upload the HTML templates to the realm pattern using `Login Templates`.

Upload a `<lang>_template.html` for each language that is enabled 
in the `nevisAuth Instance`.

The template files must contain the placeholder `\_NEVIS_AUTH_FORM\_`.

Resources referenced by these HTML template files, for example images, CSS,
should be uploaded on the `Virtual Host` using `Hosted Resources`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the `Microsoft Azure TLS Issuing CA 01` certificate.

You can access the `Host name` with your browser by adding `https://` in front, 
download the CA certificate, and then use a `PEM Trust Store` to provide it. 

## Azure Service Bus Remote Queue

Configures an Azure Service Bus connection-string for Azure Service Bus pattern to use.
--------------------------------------------------------------------------------
Section: ### On Failure
Configure the step to execute after the authentication failed.

If no step is configured here the process ends.

## nevisIDM Administration GUI

The pattern exposes the nevisIDM Administration GUI on a nevisProxy `Virtual Host`.

The Administration GUI is exposed on `/nevisidm/admin`.

You can enable the nevisIDM Self Admin GUI under `Advanced Settings`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store if you want to validate the server certificate used by nevisIDM.
If this not set, the connection is 1-way TLS.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisIDM`
--------------------------------------------------------------------------------
Section: ### Request Validation (ModSecurity)
- `off` - no request validation
- `standard` - uses ModSecurity OWASP Core Rule Set (CRS) with default paranoia level 1 - Basic security
- `custom` - configure `Request Validation Settings` via `Additional Settings`
- `log only` - uses `standard` in log only mode
--------------------------------------------------------------------------------
Section: ### REST API Access
Enables REST API access for the NevisIDM web application. As of 2022 May it is only needed by the Terms & Conditions
functionality. If Terms & Conditions is not used, then this can be disabled safely.

- `enabled` - the REST API will be exposed on the path `/nevisidm/api/*`.
- `disabled` - access to the path `/nevisidm/api/*` will be blocked.

If the REST API is enabled here, then the use of the `nevisIDM REST Service` pattern is not needed.

**WARNING: if the `nevisIDM REST Service` pattern is also used, and has different realms or SecToken patterns assigned, then the
configuration may lead to a requirement clash or a similar issue**
--------------------------------------------------------------------------------
Section: ### On Success
Assign an optional step to execute after successful authentication.

## nevisIDM Connector

Use to connect to an existing nevisIDM instance.

Use the pattern only when the instance is not set up by the project.

Ensure that the SecToken trust store of the instance allows the 
SecToken signers used in this project.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store provider for the HTTPs endpoint.
If no pattern is assigned the Trust Store will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### SecToken Trust Store
Assign a Trust Store provider pattern to use for setting up trust between nevisIDM and nevisAuth. If no pattern is assigned the signer key will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### SMTP SSL/TLS Mode
Choose between:

- `disabled` - SSL/TLS is disabled. The `SMTP Trust Store` is not used.
- `STARTTLS` - uses the `STARTTLS` command (see RFC 2487) to switch to SSL/TLS if supported by the SMTP server.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a Trust Store provider pattern to use for setting up trust between nevisIDM and the SMTP server.
--------------------------------------------------------------------------------
Section: ### Trust Store
You should add a CA certificate, and then use a `PEM Trust Store` to provide it. 

## nevisIDM Log Settings

Change log configuration for nevisIDM.
--------------------------------------------------------------------------------
Section: ### Show Policy Violations
If set to `enabled` then after failed credential creation displays violated policies.

## nevisIDM Password Login

Login to nevisIDM with username and password.

The step is intended to be used as a first factor 
in the `Initial Authentication Flow` of an `Authentication Realm`.

To support login using email, store the email in the `Login ID` field of the user.

Authentication is based on the default password policy of the selected client.
See the nevisIDM Technical Documentation on how to adapt the policy.

On successful authentication, the `UserId` of the session 
is set to the `Ext ID` of the nevisIDM user.

For `Web Application`, an initial redirect (to `?login`) is performed and a login GUI is shown.
Technical clients calling a `REST Service` or `SOAP Service` may use basic authentication and send the credential upfront.

Double-check the URL you are calling as nevisProxy also responds with a redirect 
if no servlet can be found otherwise (`trailingSlashRedirect`).

The step also supports enforced password change, for expired passwords,
and provides password reset, for users who forgot their password.
--------------------------------------------------------------------------------
Section: ### Entry Path
The path prefix of the links for the password forgotten process.

Example: given a domain `www.adnovum.ch` and the value `/pwreset/`, all password forgotten steps will
use the base path `www.adnovum.ch/pwreset/`.
--------------------------------------------------------------------------------
Section: ### Email Sent Redirect
Where to redirect to once the password reset ticket has been generated.

- `root`: to the domain root (`/`) on this `Virtual Host`
- `referrer`: to the initial URL requested by the client
- `custom`: to a custom path or URL as configured by `Custom Email Sent Redirect`

Note that the `referrer` will always be a page requiring authentication, hence
it will basically redirect to the login page.
--------------------------------------------------------------------------------
Section: ### Skip List
Comma-separated list of versioned tables (which are used to provide history data) to be ignored by the prune history job and left with their original content.

Possible values (Any combination of the following):

* `tidma_application_v`
* `tidma_authorization_appl_v`
* `tidma_authorization_client_v`
* `tidma_authorization_erole_v`
* `tidma_authorization_unit_v`
* `tidma_authorization_v`
* `tidma_cert_info_v`
* `tidma_client_application_v`
* `tidma_client_v`
* `tidma_consent_v`
* `tidma_cred_login_info_v`
* `tidma_credential_v`
* `tidma_dict_entry_v`
* `tidma_dict_entry_value_v`
* `tidma_enterprise_auth_v`
* `tidma_enterprise_role_v`
* `tidma_erole_member_v`
* `tidma_fido2_v`
* `tidma_fido_uaf_v`
* `tidma_mobile_signature_v`
* `tidma_oath_v`
* `tidma_personal_answer_v`
* `tidma_personal_question_v`
* `tidma_policy_configuration_v`
* `tidma_policy_parameter_v`
* `tidma_profile_v`
* `tidma_property_allowed_val_v`
* `tidma_property_v`
* `tidma_property_value_v`
* `tidma_role_v`
* `tidma_saml_federation_v`
* `tidma_template_collection_v`
* `tidma_template_text_v`
* `tidma_template_v`
* `tidma_terms_application_v`
* `tidma_terms_url_v`
* `tidma_terms_v`
* `tidma_unit_cred_policy_v`
* `tidma_unit_v`
* `tidma_user_login_info_v`
* `tidma_user_v`

For further information about historical tables visit [Versioned DB tables
](https://docs.nevis.net/nevisidm/Configuration/Data-Model/Database-tables-and-the-nevisIDM-data-model/Versioned-DB-tables).

## nevisIDM REST Service

Set up access to nevisIDM REST service on a nevisProxy `Virtual Host`.

The nevisIDM REST Service is exposed as: `/nevisidm/api`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store if you want to validate the server certificate used by nevisIDM.
If this not set, the connection is 1-way TLS.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisIDM`
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign add-on patterns to customize the behaviour of this service.

Example use cases:

- `Authorization Policy` to enforce roles or an authentication level.
- `URL Handling` to redirect or forward requests.
- `HTTP Header Customization` to add, replace, or remove HTTP headers in requests or responses.


## nevisIDM SOAP Service

Using the pattern, you can set up access to the nevisIDM SOAP APIs 
on a nevisProxy `Virtual Host`.

The nevisIDM SOAP APIs are exposed on `/nevisidm/services`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store if you want to validate the server certificate used by nevisIDM.
If this not set, the connection is 1-way TLS.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisIDM`
--------------------------------------------------------------------------------
Section: ### On Success
Configure the step to execute after the user has accepted all terms and conditions.

If no step is configured here the process ends and the user will be authenticated.

## nevisIDM URL Ticket Consume

Provides an endpoint on a `Virtual Host` to consume URL tickets.
The request has to contain a query parameter `x` containing the ticket code.

Before the ticket is validated a Gui is shown. The Gui has an info text
with label `info.url_ticket.welcome` and a continue button.

This Gui prevents that clients consume the ticket by calling the URL (e.g. to render a preview),
before the user even has a chance to click the link.

When the ticket is valid, the step assigned to `On Success` will be executed.

Note that when a `URL Ticket` credential is created for a nevisIDM user,
the associated `URLTicket` policy defines how the link is generated and communicated.

With `sendingMethod=Email` the user will receive an email.

Your support team can create URL tickets using the nevisIDM Admin GUI.
This requires that the policy sets `urlPrefix` so that the link can be generated.

URL tickets are often generated during an authentication flow.
As of Aug 2022 there is no high-level step to create URL tickets,
use `Generic Authentication Step` instead.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
Enter frontend path(s) which should be handled.
--------------------------------------------------------------------------------
Section: ### On Success
Assign an authentication step which shall be executed when the URL ticket is valid.

Note: this pattern does not provide any content on the exposed `Frontend Path(s)` and does not ensure
that the caller is redirected when the authentication flow terminates. 

Thus, please take appropriate measures at the end of the flow to avoid a `404` error.
For instance, you may trigger a redirect at the end of your flow, or
assign an `URL Handler` to `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the allowed HTTP methods. 

If not configured, all HTTP methods are allowed.
--------------------------------------------------------------------------------
Section: ### nevisadmin-plugin-nevisproxy.md
---
sidebar_position: 20
---
# nevisadmin-plugin-nevisproxy

## Access Restriction

Sets up a filter in nevisProxy to block or filter incoming
requests based on the source IP of the request.

The pattern can be assigned to applications 
or an entire `Virtual Host` using `Additional Settings`.

Blocked requests are responded to with HTTP error code `403`.

To produce a nice looking error page, ensure that 
you have configured an error page for 403 on the `Virtual Host` 
or use the `HTTP Error Handling` pattern on the same location.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Allow Override
By default, access restriction rules apply to all sub-locations.

For instance, when you assign an `Access Restriction` pattern to a `Virtual Host` 
all applications on this virtual host will be affected. 

To **replace** the rules defined on a parent location 
select `enabled` on all `Access Restriction` patterns in the hierarchy.

If `disabled` is selected anywhere in the hierarchy the rules are 
considered **additional**.

Technical Details:

This feature is implemented using a nevisProxy `LuaFilter`.
Mapped filters are inherited to sub-locations unless an `exclude-url-regex` is defined.

By selecting `enabled` the generator is informed that the mapped filter has the purpose
`access restriction`. The generator then ensures that an `exclude-url-regex` entry
 is generated when a filter with the same purpose is mapped to a sub-location.

## Automatic Key Store

Sets up a key store managed by nevisAdmin 4.

In classic deployment the private key is generated during deployment
by running a command on the target host.

nevisAdmin then downloads the CSR and issues a certificate,
which is deployed to the target host.

In Kubernetes deployment a custom resource definition (CRD) is generated 
and sent to the Nevis Operator running in the cluster.

Set the inventory variable `__nevisadmin_pki_automatic_allowed_mode` to restrict the allowed modes:

- `any` (default) - assignment of key management patterns is optional.
- `explicit` - assign patterns where-ever a key store or trust store is required.

This example illustrates how the key store looks on the target system:

```
[root@nevis /]# ls -l /var/opt/keys/own/<name>/
total 40
-rw-r----- 1 root nvbgroup 1103 Dec  1 07:05 ca-chain.pem
-rw-r----- 1 root nvbgroup 1013 Dec  1 07:05 cert.pem
-rw-r----- 1 root nvbgroup  887 Dec  1 07:05 csr.pem
-rwxr-x--- 1 root nvbgroup   40 Dec  1 07:05 keypass
-rw-r----- 1 root nvbgroup 1675 Dec  1 07:05 key_pkcs1.pem
-rw-r----- 1 root nvbgroup 1704 Dec  1 07:05 key.pem
-rw-r----- 1 root nvbgroup  451 Dec  1 07:05 key_pub.pem
-rw-r----- 1 root nvbgroup 2053 Dec  1 07:05 keystore.jks
-rw-r----- 1 root nvbgroup 2309 Dec  1 07:05 keystore.p12
-rw-r----- 1 root nvbgroup 2688 Dec  1 07:05 keystore.pem
```
--------------------------------------------------------------------------------
Section: ### Owner(s)
Select an instance pattern which defines the target hosts of this `Automatic Key Store`.
This setting is required only when this pattern is assigned to an `Automatic Trust Store`.

## Automatic Trust Store

Sets up a trust store managed by nevisAdmin 4.

In classic deployment the certificates of trusted key stores
are deployed to the target host.

In Kubernetes deployment a custom resource definition (CRD) is generated instead and sent to the Nevis Operator running in the cluster.

Set the inventory variable `__nevisadmin_pki_automatic_allowed_mode` to restrict the allowed modes:

- `any` (default) - assignment of key management patterns is optional.
- `explicit` - assign patterns where-ever a key store or trust store is required.

This example illustrates how the trust store looks on the target system:

```
[root@nevis /]# ls -l /var/opt/keys/trust/<name>/
total 16
-rwxr-x--- 1 root nvbgroup   16 Dec  1 07:05 keypass
-rw-r----- 1 root nvbgroup 1656 Dec  1 07:05 truststore.jks
-rw-r----- 1 root nvbgroup 2042 Dec  1 07:05 truststore.p12
-rw-r----- 1 root nvbgroup 2116 Dec  1 07:05 truststore.pem
```
--------------------------------------------------------------------------------
Section: ### Additional Trusted Certificates
Upload additional trusted certificates in PEM format.

The content of all files will be concatenated and added to the `truststore.*` files generated by this pattern.

You can make this a variable and upload the files in the inventory using the `Attach files` function.

## CSRF Protection Settings

Customize CSRF protection for an application, for example, `Web Application`.

You can assign the pattern to `Virtual Host` patterns as well,
to configure CSRF protection for all applications on this host.
--------------------------------------------------------------------------------
Section: ### Header-based Check
CSRF protection can be obstructive for some cross-domain use cases 
(e.g. federation or providing a public REST API).
--------------------------------------------------------------------------------
Section: ### Allowed Domains
CSRF protection can be obstructive for cross-domain use cases 
(e.g. federation or providing a public REST API).

Enter domains which should be excluded from `header-based` CSRF protection. 
There is no support for wildcards, pre- or postfix notations (sub-domains must be listed individually).

Example: 
```
www.adnovum.ch 
adnovum.ch
```

## Cookie Customization

Configure whether cookies are to be returned to the caller or stored in the user session.

You may also assign the pattern to multiple applications, and set `Shared Protected Cookies`
to share cookies between applications. 

Note that cookie sharing is supported only for applications 
using the same session in nevisProxy, that is, 
applications protected by the same authentication realm.

The default cookie handling differs based on the type of application:
 
| Type | Behaviour | 
|---|---|---| 
| Web Application (with authentication) | Cookies are stored. |
| Web Application (public) | Cookies are allowed to passthrough. |
| REST API | Cookies are dropped. |
| SOAP Service | Cookies are dropped. |
--------------------------------------------------------------------------------
Section: ### Cookie Conflict Resolution
When multiple `Cookie Customization` patterns are used it happen that 
a certain cookie is defined as both a `Client Cookie` and as a `Shared Protected Cookie` 
for the same application.

By default, this conflict is resolved by allowing the cookie to `pass-through`, treating it as a `Client Cookie`.

This behaviour is usually more robust but less secure as the cookie will be accessible in the browser.

Select `protect` to threat the cookie as a `Shared Protected Cookie` instead.

## Default Service

Makes the configured `Frontend Path(s)` accessible 
on the assigned `Virtual Host(s)` by mapping a `DefaultServlet`.

You can decorate the paths by assigning `Additional Settings`, for example, 
to provide custom services using nevisProxy filters.

Note that if your request passes through the entire filter chain without 
being responded or redirected an error code 404 is returned.

The pattern is only to be used when there is no pattern for your use case. 
Whenever possible, use the following patterns instead:

- `Web Application`, `REST Service`, `SOAP Service`: to make a backend application accessible
- `Standalone Authentication Flow`: to provide an entry point for flows implemented in nevisAuth
- `Hosting Service`: to host static resources
--------------------------------------------------------------------------------
Section: ### Virtual Host(s)
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
The path(s) which shall be accessible on the assigned `Virtual Host(s)`.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign add-on patterns to customize the behaviour of this service.

Example use cases:

- `Authorization Policy` to enforce roles or an authentication level.
- `URL Handling` to redirect or forward requests.
- `HTTP Header Customization` to add, replace, or remove HTTP headers in requests or responses.


## Generic Application Settings

Customize the `web.xml` configuration for an application
using XML constructs as described in the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy). 

Use as add-on for `Web Application`, `SOAP Service`, or `REST Service`.

The following expressions may be used for all applications:

- `${name}`: sanitized name of the pattern
- `${service.name}`: the name of the application
- `${service.id}`: the unique ID of the application
- `${host.key}`: use as `EntryPointID` when adding a custom `IdentityCreationFilter` (advanced use case)

For applications with only 1 `Frontend Path`:

- `${service.path}`: the frontend path of the application, excluding trailing slash `/` and asterisk `*`
- `${service.mapping}`: the `url-pattern` calculated for the frontend path of the application 

In case an `Authentication Realm` is assigned:

- `${realm.name}`: name of the realm (use for `StateKey` / `DelegateSource`)
- `${auth.connector}`: name of the `Esauth4ConnectorServlet` (use for `AuthenticationServlet`)
- `${logrend.renderer}`: name of the `LoginRendererServlet`
- `${logrend.connector}`: name of the `Http(s)ConnectorServlet` for nevisLogrend (if nevisLogrend is used)

When defining filters it is recommended to set `Filter Mappings` to `automatic`.
This way the filters are mapped to all frontend paths of the application.
--------------------------------------------------------------------------------
Section: ### Filters and Mappings
Configure filters and their mappings using the XML syntax described in the nevisProxy Technical Documentation. 

Filters that have the same name as other filters (even those defined by other patterns) 
will be combined: the `init-param` sets will be merged where possible.
Direct contradictions are interpreted as validation failures.

**Example 1**: Create (or patch) a filter with a fixed name

```xml
<filter>
   <filter-name>SomeName</filter-name>
   <filter-class>ch::nevis::isiweb4::filter::SomeClass</filter-class>
   <init-param>
      <param-name>...</param-name>
      <param-value>...</param-value>
   </init-param>
</filter>
```

**Example 2**: Create (or patch) a filter using an application-specific name

```xml
<filter>
   <filter-name>SomeName_${service.name}</filter-name>
   <filter-class>ch::nevis::isiweb4::filter::SomeClass</filter-class>
   ...
</filter>
```

**Example 3**: Map a filter to a sub-path of the assigned application(s).
This example works for applications which have 1 frontend path only.

```xml
<filter-mapping>
   <filter-name>SomeFilter</filter-name>
   <url-pattern>${service.path}/custom/*</url-pattern>
</filter-mapping>
```

**Example 4**: Use multi-value expressions

Multi-value expressions replicate an entire line for each associated value.

Use the expressions `*{service.path}` and `*{service.mapping}` to generate filters 
which must contain the frontend paths of all assigned applications.

The following snippet is not complete but should illustrate the concept:

```xml
<filter>
    <filter-name>FormSigning</filter-name> 
    <filter-class>ch::nevis::isiweb4::filter::validation::EncryptionFilter</filter-class>
    <init-param>
        <param-name>EntryURL</param-name>
        <param-value>
            *{service.path}/
        </param-value>
    </init-param>
    ...
</filter>
```
--------------------------------------------------------------------------------
Section: ### Filter Mappings
Choose between:

- `manual` (default): only the `filter-mapping` elements which have been configured via `Filters and Mappings` will be added.
- `automatic`: filters configured via `Filters and Mappings` will be mapped to all `Frontend Paths` of the application.
- `both`: like `automatic` but additional `filter-mapping` elements are allowed as well.
--------------------------------------------------------------------------------
Section: ### Remove Filter Mappings
Remove `<filter-mapping>` elements generated by other patterns.

The syntax is a map of `<filter-name>:<url-pattern>`, according to elements from the `web.xml`.

In the `<filter-name>` the expressions `${service.name}` and `${realm.name}` may be used.

For applications which have only 1 frontend path you may use `${service.mapping}` instead of `<url-pattern>`.

Examples:

```
ModSecurity_${service.name}:${service.mapping}
Authentication_${realm.name}:${service.mapping}
```

## Generic QoS Configuration (mod_qos)

Assign the pattern to a `Virtual Host` using `Additional Settings`.

Use to configure `mod_qos` in case the `standard` configuration is not sufficient.

`mod_qos` is quite powerful, and can cover may use cases. 
See [mod_qos documentation](http://mod-qos.sourceforge.net/) for further information.

The pattern is experimental and may change in future releases. 
The `mod_qos` directives are not validated.

The directives are applied using an `ApacheConfigFilter` (named `Qos`),
which is added to the `web.xml` of the `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Server Directives (Experimental)
Server level directives can be entered here.

These directives apply to the entire `nevisProxy Instance` 
which means that other `Virtual Host` patterns may be affected.

Examples:

```
QS_ClientEventBlockCount 200 300
QS_SetEnvIf NAVAJO_HTTPSESS_CREATED !QSNOT QS_Block=yes
QS_SrvMaxConnClose 85%
QS_SrvMaxConnPerIP 75
QS_SrvMinDataRate 75 300 250
```
--------------------------------------------------------------------------------
Section: ### Host Directives
Host level directives can be entered here.

## Generic Virtual Host Settings

Customize the `web.xml` configuration
using XML constructs as described in the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy). 

Use as add-on for the `Virtual Host` pattern. 
The following expressions are supported:

- `${name}`: sanitized name of the pattern
- `${service.name}`: the name of the virtual host
- `${service.id}`: the unique ID of the virtual host
- `${service.path}`: the base path of the virtual host (empty String) 
- `${service.mapping}`: the `url-pattern` for the virtual host `/*`
--------------------------------------------------------------------------------
Section: ### Filters and Mappings
Configure filters and their mappings using the XML syntax described in the nevisProxy Technical Documentation. 

Filters that have the same name as other filters (even those defined by other patterns) 
will be combined: the `init-param` sets will be merged where possible.
Direct contradictions are interpreted as validation failures.

**Example 1**: Create (or patch) a filter with a fixed name

```xml
<filter>
   <filter-name>SomeName</filter-name>
   <filter-class>ch::nevis::isiweb4::filter::SomeClass</filter-class>
   <init-param>
      <param-name>...</param-name>
      <param-value>...</param-value>
   </init-param>
</filter>
```

**Example 2**: Create (or patch) a filter using an application-specific name

```xml
<filter>
   <filter-name>SomeName_${service.name}</filter-name>
   <filter-class>ch::nevis::isiweb4::filter::SomeClass</filter-class>
   ...
</filter>
```

**Example 3**: Map a filter to a sub-path of the assigned application(s).
This example works for applications which have 1 frontend path only.

```xml
<filter-mapping>
   <filter-name>SomeFilter</filter-name>
   <url-pattern>${service.path}/custom/*</url-pattern>
</filter-mapping>
```

**Example 4**: Use multi-value expressions

Multi-value expressions replicate an entire line for each associated value.

Use the expressions `*{service.path}` and `*{service.mapping}` to generate filters 
which must contain the frontend paths of all assigned applications.

The following snippet is not complete but should illustrate the concept:

```xml
<filter>
    <filter-name>FormSigning</filter-name> 
    <filter-class>ch::nevis::isiweb4::filter::validation::EncryptionFilter</filter-class>
    <init-param>
        <param-name>EntryURL</param-name>
        <param-value>
            *{service.path}/
        </param-value>
    </init-param>
    ...
</filter>
```
--------------------------------------------------------------------------------
Section: ### Servlets and Mappings
Configure `servlet` and/or `servlet-mapping` elements
using the XML constructs described in the nevisProxy Technical Documentation.

You can also customize elements which have been generated by other patterns.
Elements can be referenced as follows:

- `servlet`: `servlet-name`
- `servlet-mapping`: `url-pattern`

In Kubernetes side-by-side deployment a postfix is added to service names. 
Use the expression `${service.postfix}` connecting to a service deployed against the same inventory.

Example 1: Add or overwrite an `init-param` for an existing `servlet`:

```xml
<servlet>
  <servlet-name>Hosting_Default</servlet-name>
  <init-param>
    <param-name>NoMatchFile</param-name>
    <param-value>/index.html</param-value>
  </init-param>
</servlet>
```

Example 2: Remove a `servlet-mapping`:

```xml
<servlet-mapping>
    <url-pattern>/app/*</url-pattern>
</servlet-mapping>
```

Here we left out the `servlet-name` to tell the pattern to remove the `servlet-mapping` for the given `url-pattern`.

Note that the mapping of the hosted resources is an exception and cannot be removed this way 
(see the property `Hosted resources` of the Virtual Host pattern for more information).

Removing a `servlet` element is not supported.
--------------------------------------------------------------------------------
Section: ### Mime-Mappings
Set or replace `mime-mapping` elements.

Examples:

```
<mime-mapping>
    <extension>svg</extension>
    <mime-type>image/svg+xml</mime-type>
</mime-mapping>
```

The `mime-mapping` elements affect the entire `Virtual Host`
and are used use to determine the `Content-Type` for responses.

nevisProxy always sets a `Content-Type` header 
for static resources served by the `Virtual Host`.

Further, nevisProxy can add a `Content-Type` header for resources served by applications.
To enable this advanced feature assign `Generic Application Settings` to the application
and set the parameter `ProxyPolicy` to `mime-completion`.

## Generic nevisProxy Instance Settings

You can assign the pattern to a `nevisProxy Instance` using `Additional Settings`.
 
Use to customize the main configuration files of the nevisProxy instance, including:

- `navajo.xml`
- `bc.properties`

To configure logging, use `nevisProxy Log Settings` instead.
--------------------------------------------------------------------------------
Section: ### Configuration: navajo.xml
Customize the Navajo servlet container configuration (`navajo.xml`)
using XML constructs described in the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy).

The root element `<Service>` must be provided.

Examples:

Increase number of parallel requests (worker threads):

```xml
<Service>
    <Server MaxClients="1000"/>
</Service>
```

Increase the maximum allowed request body size:

```xml
<Service>
    <Server LimitRequestBody="10485760"/>
</Service>
```

Set a `Context` attribute for `some.domain.com`:

```xml
<Service>
    <Engine>
        <Host name="some.domain.com">
            <Context additionalStatusCodes="207,210,242,422,423,424,449,456,540,541,543,544,545,456,549,552,560" />
        </Host>
    </Engine>
</Service>
```

Overrule the allowed HTTP methods for `some.domain.com`:

```xml
<Service>
    <Engine>
        <Host name="some.domain.com">
            <Context allowedMethods="ALL-HTTP" />
        </Host>
    </Engine>
</Service>
```

Overrule the server aliases for `some.domain.com`:

```xml
<Service>
    <Connector name="some.domain.com" port="*" serverAlias="*.domain.com">
    </Connector>
</Service>
```

It is possible to use the following placeholders:

- `${instance.id}`: unique ID of the `nevisProxy Instance` pattern
- `${instance.name}`: name of the nevisProxy instance. For instance, use `/var/opt/nevisproxy/${instance.name}` to refer to the instance directory.

Limitations:

- customizing `Navajo` elements is not supported
- customizing `Host` (or its child elements) requires `name`
--------------------------------------------------------------------------------
Section: ### Configuration: bc.properties
Customize the low-level configuration (`bc.properties`)
using properties described in the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy).

For instance, when request validation is enabled this requires a buffer
and this buffer has to be big enough to store the entire request.

The following example increases the maximum size of the request buffer to 10 MB:

```
ch.nevis.navajo.request.BufferSize=10485760
```

You also may have to increase the maximum allowed request size. 
See `Configuration: navajo.xml` for an example.

Note that increased buffer sizes may lead to increased demand of RAM and disk space. 

When the required buffer exceeds `ch.nevis.navajo.request.MemBufferSize` 
then nevisProxy will buffer to disk instead.

The demand caused by request buffers can be estimated as follows:

- RAM: `MaxClients` * `ch.nevis.navajo.request.MemBufferSize` 
- disk: `MaxClients` * `ch.nevis.navajo.request.BufferSize` 

See `Configuration: navajo.xml` for a description of `MaxClients`.
--------------------------------------------------------------------------------
Section: ### Template Parameters
Define _Template Parameters_.

Examples:

```yaml
backend-host: backend.siven.ch
```

These parameters can be used in:

* `Configuration: navajo.xml`
* `Configuration: bc.properties`

The expression formats are:

`${param.<name>}`:

- `name` found: parameter value is used.
- `name` missing: expression is **not** replaced.

`${param.<name>:<default value>}`:

- `name` found: parameter value is used.
- `name` missing: default value will be used.

In `<default value>` the character `}` must be escaped as `\}`.

## HTTP Error Handling

Use the pattern to handle HTTP error codes.

You can use the pattern as an add-on for `Virtual Host`
or any backend application, for example, `Web Application`, `REST Service`, or `SOAP Service`.
--------------------------------------------------------------------------------
Section: ### Error Pages
Upload HTML error pages, JSON error pages and associated resources here.

Pages must be named like the error code they are used for (e.g. `500.html`).
You can use the same page for multiple status code (e.g. `401,403,500-599.html`).

By default, the error pages are deployed to `/errorpages/<name>` but
you can set a different location via the property `Base Path` (see `Advanced Settings`).

In your error pages we recommend to use relative links to include resources.
You may also include resources deployed on the virtual host via `Hosted Resources`.

The following placeholders are supported:

- `TRANSFER_ID` for the unique ID of the request (e.g. `c0a80e52-5d04-11ac0500-16906714eee-00000003`)
- `TIMESTAMP` to show a timestamp (e.g. `Tue, 19 Feb 2019 15:48:02 GMT`)
--------------------------------------------------------------------------------
Section: ### Mode
Enable or disable the error handling.

When set to `disabled`, all settings except `Apply only to sub-paths` are ignored.
Use this setting in combination with `Apply only to sub-paths` to disable the error handling for some sub-paths only.

Usage examples (valid for `Virtual Host`s and backend applications):
- Disable the error handling: 
use an `Error Handler` pattern with `Mode` set to `disabled` and link it to the target pattern via `Additional Settings`;
- Disable the error handling for some sub-paths:
use an `Error Handler` pattern with `Mode` set to `disabled` and `Apply only to sub-paths` set to the paths where no error handling should occur, and link it to the target pattern via `Additional Settings`;
- Define a customised error handling and disable it for some sub-paths: 
use two `Error Handler` patterns, one with the custom settings, and one with `Mode` set to `disabled` and `Apply only to sub-paths` set to the paths where no error handling should occur. Link both of them to the target pattern via `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply the error handling on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Base Path
By default, the error pages are deployed to `/errorpages/<name>` but you can set a different location here.
--------------------------------------------------------------------------------
Section: ### Keep Security Headers
Configure the name of special response headers which should be kept,
regardless of the header action of the matching rule.
Useful for keeping the security response headers for the error pages.

Default:

```
Strict-Transport-Security
X-Content-Type-Options
Referrer-Policy
```


## HTTP Header Customization

Use to add, overwrite, or remove HTTP headers in requests or responses.

You can use the pattern as add-on for `Virtual Host` or applications, 
for example, `Web Application`, `REST Service`, or `SOAP Service`.

The following expressions may be used:

- `${client.ip}` - IP address of the caller
- `${request.id}` - unique ID of this request
- `${request.header.<name>}` - value of a request header (only for requests)
- `${env.<name>}` - Apache `ENV` variables
- `${auth.<name>}` - access to the `AUTH` scope (only for requests, requires an `Authentication Realm` and the `Filter Phase` is to be set to `AFTER_AUTHENTICATION` or `END`)
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply the header customization on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table illustrates the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |


## Hosting Service

Use the pattern to host static pages and related resources.

For instance, you can use this pattern to host HTML or a single-page application (SPA).

Further, you can provide CSS, images, and Javascript for error pages uploaded by a `HTTP Error Handling` pattern.

The pattern generates configuration for the nevisProxy [ch::nevis::nevisproxy::servlet::file::FileReaderServlet](https://docs.nevis.net/nevisproxy/Configuration/Servlets/FileReaderServlet).
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Frontend Path
The path at which the resources shall be accessible at the frontend.
You may use `/` to deploy root content.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply the ICAP scanning on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |

## JWT Access Restriction

Sets up a filter in nevisProxy to verify the JWT of incoming requests.

A request will be allowed to pass through if it contains a valid JWT, in
every other case (e.g. failed to verify, expired or token not present), the
request will be blocked. Blocked requests are responded to with HTTP error code `403`

The pattern can be assigned to applications 
or an entire `Virtual Host` using `Additional Settings`.
.
--------------------------------------------------------------------------------
Section: ### Lua Script
Upload a Lua script which should be invoked for requests and / or responses.
The script has to contain one or multiple of the following Lua functions:

- `function inputHeader(request, response)` - called once per request
- `function input(request, response, chunk)` - called once per request body _chunk_
- `function outputHeader(request, response)` - called once per response
- `function output(request, response, chunk)` - called once per response body _chunk_

The uploaded script will be deployed to the nevisProxy host in sub-directory `WEB-INF` using
the name of this pattern for the file name to ensure that the file name is unique.

Here is an example Lua script which replaces sensitive information in response bodies:

```
local buf = {}
function output(request, response, chunk)
  if chunk ~= nil then
    table.insert(buf, chunk)
    return nil
  else
    return string.gsub(table.concat(buf), "some-sensitive-data", "*****");
  end
end  
```

The following expressions can be used anywhere within the script:

- `${name}` - sanitized name of this pattern
- `${host}` - name of the `Virtual Host` directory
- `${instance}` - name of the `nevisProxy Instance` directory
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |

## Maintenance Page

Shows a static maintenance page
if the current date and time is within a certain interval.

Technical note: nevisProxy uses system calls to determine the current time in UTC. 
To check if UTC time is correct, run `date -u` on the nevisProxy host.

You can assign the pattern using `Additional Settings` to applications,
or an entire `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Base Path
Enter the base path under which the maintenance page will be hosted.

You usually don't have to change this configuration, unless the path clashes with any other hosted resources.

By default, `/maintenance/` is used.


## NGINX Ingress Settings

Assign this pattern to a `nevisProxy Instance` using `Additional Settings`. 

Use in Kubernetes deployments to add annotations for the NGINX Ingress 
which runs in front of nevisProxy and terminates incoming connections.
--------------------------------------------------------------------------------
Section: ### TLS Secrets
Use your own Kubernetes secrets to provide the frontend key store for a `Virtual Host`.

Syntax is a map of (primary) frontend address of the host to secret name.

```properties
www.siven.ch: customsecretname
```

Secrets must be of `type: kubernetes.io/tls`. Secrets must be prepared before deployment.
They must contain a private key (`tls.key`), a matching certificate (`tls.crt`) and should contain the CA chain (`ca.crt`).

If not set the Nevis operator request certificates from the cluster issuer
and generates a secret for each `Virtual Host` to store the required key material.
--------------------------------------------------------------------------------
Section: ### Custom Root Directory Name
Set to deploy the key store underneath a _base_ directory.
The key store will be established at:

`/var/opt/keys/own/<base>/<name>`

This configuration may be used to prevent key stores overwriting each other 
and is only required in complex setups with multiple projects or inventories.

## PEM Trust Store

Set up a trust store.

The trust store is deployed to `/var/opt/keys/trust/<name>`.

The trust store will contain the following files:

- `truststore.pem`
- `truststore.jks` - JKS format
- `truststore.p12` - PKCS12 format
- `keypass` - used by Java-based components to retrieve the password to access the JKS or PKCS12 files

All `truststore.*` files contain the same certificates.

The JKS and PKCS12 files are created during the first generation,
and then stored in a cache backed by the nevisAdmin 4 database.
--------------------------------------------------------------------------------
Section: ### Trusted Certificates
Upload trusted certificate(s) in PEM format.

If you set a _variable_, the variable should be a list of secret file references in the inventory.
Example:

```
  my-variable: 
    - inv-res-secret://147cc54a5629fadac761ec01#some-cert.pem
    - inv-res-secret://147cc54a5629fadac761ec01#some-other-cert.pem
```

Upload files for this variable by clicking `Attach files`
in the drop-down on the inventory screen.

If you are deploying to Kubernetes you may store the trust store content in a Kubernetes secret.
You can pick any name for the Kubernetes secret but the keys must be as in the following example:

```
  my-variable: 
    - k8s-secret-file://dummy-truststore:truststore.pem/
    - k8s-secret-file://dummy-truststore:truststore.jks/
    - k8s-secret-file://dummy-truststore:truststore.p12/
    - k8s-secret-file://dummy-truststore:keypass/
```

Note that nevisAdmin 4 does not notice when the content of the Kubernetes secret changes.
Manual interaction (terminating pods) is required in that case.
--------------------------------------------------------------------------------
Section: ### Custom Directory Name
Enter a name for the trust store directory 
which is used instead of the pattern name.

This configuration may be used to prevent trust stores overwriting each other 
and is only required in complex setups with multiple projects or inventories.
--------------------------------------------------------------------------------
Section: ### Custom Root Directory Name
Set to deploy the trust store underneath a _base_ directory.
The trust store will be established at:

`/var/opt/keys/trust/<base>/<name>`

This configuration may be used to prevent trust stores overwriting each other 
and is only required in complex setups with multiple projects or inventories.

## REST Service

Set up access to a backend application providing a REST API.
--------------------------------------------------------------------------------
Section: ### Virtual Hosts
Assign `Virtual Host` patterns which shall serve as entry point for this application.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
The (base) path of the application.

Examples:

- `/app/` - defines a base path. 
Any requests which have a path component starting with `/app/` will be sent to this application.
- `/` - forward all requests to this application. 
Use this only when there are no other applications or hosted resources.
- `exact:/app.html` - matches requests to `/app.html` only (query parameters are allowed). 
Use this for single-page applications which don't require any additional resources.

Note that if the frontend path is different from the path used within `Backend Addresses` 
then URL rewriting will be configured to correctly route
requests and responses between clients and backends.
--------------------------------------------------------------------------------
Section: ### Backend Addresses
Enter the complete URLs (scheme, host, port and path) of the backend services. 

Note: 

- all URLs must use the same scheme and path.
- automatic path rewriting will be performed when the path differs from the `Frontend Path`.

In case you are setting multiple addresses, use `Load Balancing` to select a request dispatching strategy.
--------------------------------------------------------------------------------
Section: ### Load Balancing
Select a request dispatching strategy when several `Backend Addresses` are configured.

- `disabled` - all requests will be sent to the first address. If this address is not available the next address is chosen;
- `round-robin` - one of the addresses will be picked up for each request using a round-robin rotation;
- `session-sticky` - one of the addresses will be picked up for each new session using a round-robin rotation, then subsequent requests for the session will be sent to the same address.


Failover strategy:

* When the selected backend cannot be accessed, nevisProxy will attempt to use another one.
* Once the said backend can be accessed again, it can be picked up for new requests if the load balancing is `round-robin`, or for new sessions if the load balancing is `disabled` or `session-sticky`. 
The requests linked to an existing session will still go to the current backend until the end of the session if the load balancing is `disabled` or `session-sticky`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Optional setting for enabling trust to HTTPS backends.

For securing production environments:

- set `Backend Addresses` starting with `https://`
- assign a `Trust Store` pattern containing the certificates required for verifying the backend certificate
- set `Hostname Validation` to `enabled`
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname configured in `Backend Addresses`
--------------------------------------------------------------------------------
Section: ### Host Header
Defines the `Host` header for requests forwarded to the application.

When `backend` is selected then nevisProxy uses the host part of the backend address that has been selected.
This is the default behaviour and similar to what a browser would do.
Therefore, this configuration should work in most cases.

When `client` is selected then nevisProxy will keep the `Host` header as received from the client.
The following `init-param` will be generated:
              
```
<init-param>
  <param-name>HostName</param-name>
  <param-value>ENV:HTTP_Host;</param-value>
</init-param>
```

The configuration is dynamic to support virtual hosts with multiple frontend addresses.
Note that this may be less secure. 
Even though browsers do not allow this clients may sent an arbitrary value for the `Host` header.
It is therefore recommended to test how your application behaves in this case.
--------------------------------------------------------------------------------
Section: ### Response Rewriting
Use this feature to replace backend hostnames in responses
or set to `custom` to configure complex rewriting use cases.

- `off` disables automatic response rewriting
- `header` enables auto rewrite for response headers (including Set-Cookie header)
- `complete` enables auto rewrite for the entire response (including body)
- `custom` configure `Response Rewriting Settings` via `Additional Settings`
--------------------------------------------------------------------------------
Section: ### CSRF Protection
_Cross-Site Request Forgery_ (_CSRF_) is an attack that forces an authenticated user to send unwanted requests.

- `off (default)` - no CSRF protection. Recommended for APIs which may be called from other sites.
- `header-based` - `GET` and `HEAD` requests are allowed. 
For other requests `Referer` and `Origin` headers must match the `Host` header.
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the HTTP methods allowed for this application. 

Methods which are listed here must also be allowed on the `Virtual Host`.

You may also use the following method groups:

* `ALL-HTTP` includes common HTTP methods.

  These are: `GET, POST, HEAD, DELETE, TRACE, CONNECT, OPTIONS, PUT, PATCH`

* `ALL-WEBDAV` includes all methods required for WebDAV.
  
  These are: `MERGE, UNCHECKOUT, MKACTIVITY, PROPPATCH, LOCK, CHECKOUT, SEARCH, COPY, MKCOL, MKWORKSPACE, PROPFIND, UPDATE, REBIND, BASELINE-CONTROL, UNBIND, CHECKIN, VERSION-CONTROL, UNLOCK, LABEL, MOVE, ACL, BIND, REPORT` 

To remove methods from `ALL-HTTP` and `ALL-WEBDAV` simply add the method with a `-` sign in front of it.
--------------------------------------------------------------------------------
Section: ### Session Termination
Use this feature to terminate sessions on the backend application.

nevisProxy will send a `GET` request to this path when the nevisProxy session is terminated (due to logout or session timeout).
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param(s)` for the Http(s)ConnectorServlet. For example: ConnectionRetries=10

Please check the nevisProxy technical documentation for supported `init-params` of the servlet classes `ch::nevis::isiweb4::servlet::connector::http::HttpConnectorServlet` and `ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet`.

## Request Validation Settings (ModSecurity)

Use the pattern to customize ModSecurity rules.
Assign the same pattern to multiple applications to enforce a common configuration.

Do not use rule IDs in the range 500001-500999 
as they are reserved for Nevis internal purposes. 

Deploying changes to an existing pattern triggers a restart of nevisProxy 
if the `RestartPolicy` is set to `eager`.

Restarting the instance better suits large and highly customised ModSecurity setups.

If you prefer to let nevisProxy reload the ModSecurity configuration on-the-fly, 
set the `RestartPolicy` to `lazy` in the corresponding `nevisProxy Instance` patterns.
--------------------------------------------------------------------------------
Section: ### Validation Scope
Sets the scope of request validation:

- `all`: validation will be applied to all requests. This includes authentication.

- `backend`: validation will be applied to requests which are sent to the backend application. The authentication is excluded.

- `authentication`: validation will be applied to requests which are sent to nevisAuth.
--------------------------------------------------------------------------------
Section: ### Log Only Mode
Allows to use the request validation settings in log only mode.
--------------------------------------------------------------------------------
Section: ### Backend Host Rewriting
- `off` disables automatic response rewriting
- `header` enables auto rewrite of response headers (includes cookies)
- `complete` enables auto rewrite for response headers and body
--------------------------------------------------------------------------------
Section: ### Response Body Content Types
Enter regular expressions to match the `Content-Type`
of responses. If the expression matches, the response body is rewritten.

## Rule Bundle (ModSecurity)

Use the pattern to further customize ModSecurity rules.

Assign the same pattern to multiple `Request Validation Settings` patterns
to easily configure and maintain global or group ModSecurity rule configurations.

Do not use rule IDs in the range 500001-500999 
as they are reserved for Nevis internal purposes.
--------------------------------------------------------------------------------
Section: ### Whitelist Modifications
Configure _whitelist modifications_.

As explained in the [ModSecurity documentation](https://www.modsecurity.org/CRS/Documentation/exceptions.html#exceptions-versus-whitelist)
_whitelist modifications_ are applied **before** including the core rules.

If both the `Request Validation Settings` and the `Rule Bundle` pattern have _whitelist modifications_ configured, first
the `Rule Bundle`, then the `Request Validation Settings` whitelists will be applied.

Note that new rule may require a rule ID which has to be unique for this pattern.
Use the range 1-99,999 as it is reserved for local (internal) use. 

* Remove rule with ID `900200` for the path `/app/some.html`:

`SecRule REQUEST_URI "@streq /app/some.html" "pass,nolog,id:1000,ctl:ruleRemoveById=200002"`
--------------------------------------------------------------------------------
Section: ### Exception Modifications
Configure _exception modifications_.

As explained in the [ModSecurity documentation](https://www.modsecurity.org/CRS/Documentation/exceptions.html#exceptions-versus-whitelist)
_exception modifications_ are applied **after** including the core rules.

If both the `Request Validation Settings` and the `Rule Bundle` pattern have _exception modifications_ configured, first
the `Request Validation Settings`, then the `Rule Bundle` modifications will be applied.

Note that new rule may require a rule ID which has to be unique for this pattern.
Use the range 1-99,999 as it is reserved for local (internal) use. 

* Remove rule with ID `900200`:

`SecRuleRemoveById 900200`

* Whitelist body parameter `upload` for all rules:

`SecRuleUpdateTargetByTag ".*" "!ARGS:upload"`

* Whitelist body parameter `upload` for rule ID `123`:

`SecRuleUpdateTargetById 123 !ARGS:upload`

* Add a new rule which allows the HTTP methods used for WebDAV:

```
SecAction \
 "id:1,\
  phase:1,\
  nolog,\
  pass,\
  t:none,\
  setvar:'tx.allowed_methods=GET HEAD POST OPTIONS PUT PATCH DELETE CHECKOUT COPY DELETE LOCK MERGE MKACTIVITY MKCOL MOVE PROPFIND PROPPATCH PUT UNLOCK'"
```

## SOAP Service

The pattern sets up access to a backend application which provides a SOAP service.
--------------------------------------------------------------------------------
Section: ### Virtual Hosts
Assign `Virtual Host` patterns which shall serve as entry point for this application.
--------------------------------------------------------------------------------
Section: ### Frontend Path
The (base) path of the application.

Examples:

- `/app/` - defines a base path. 
Any requests which have a path component starting with `/app/` will be sent to this application.
- `/` - forward all requests to this application. 
Use this only when there are no other applications or hosted resources.
- `exact:/app.html` - matches requests to `/app.html` only (query parameters are allowed). 
Use this for single-page applications which don't require any additional resources.

Note that if the frontend path is different from the path used within `Backend Addresses` 
then URL rewriting will be configured to correctly route
requests and responses between clients and backends.
--------------------------------------------------------------------------------
Section: ### Backend Addresses
Enter the complete URLs (scheme, host, port and path) of the backend services. 

Note: 

- all URLs must use the same scheme and path.
- automatic path rewriting will be performed when the path differs from the `Frontend Path`.

In case you are setting multiple addresses, use `Load Balancing` to select a request dispatching strategy.
--------------------------------------------------------------------------------
Section: ### Load Balancing
Select a request dispatching strategy when several `Backend Addresses` are configured.

- `disabled` - all requests will be sent to the first address. If this address is not available the next address is chosen;
- `round-robin` - one of the addresses will be picked up for each request using a round-robin rotation;
- `session-sticky` - one of the addresses will be picked up for each new session using a round-robin rotation, then subsequent requests for the session will be sent to the same address.


Failover strategy:

* When the selected backend cannot be accessed, nevisProxy will attempt to use another one.
* Once the said backend can be accessed again, it can be picked up for new requests if the load balancing is `round-robin`, or for new sessions if the load balancing is `disabled` or `session-sticky`. 
The requests linked to an existing session will still go to the current backend until the end of the session if the load balancing is `disabled` or `session-sticky`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Optional setting for enabling trust to HTTPS backends.

For securing production environments:
- set `Backend Addresses` starting with `https://`
- assign a `Trust Store` pattern containing the certificates required for verifying the backend certificate
- set `Hostname Validation` to `enabled`
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname configured in `Backend Addresses`
--------------------------------------------------------------------------------
Section: ### Host Header
Defines the `Host` header for requests forwarded to the application.

When `backend` is selected then nevisProxy uses the host part of the backend address that has been selected.
This is the default behaviour and similar to what a browser would do.
Therefore, this configuration should work in most cases.

When `client` is selected then nevisProxy will keep the `Host` header as received from the client.
The following `init-param` will be generated:
              
```
<init-param>
  <param-name>HostName</param-name>
  <param-value>ENV:HTTP_Host;</param-value>
</init-param>
```

The configuration is dynamic to support virtual hosts with multiple frontend addresses.
Note that this may be less secure. 
Even though browsers do not allow this clients may sent an arbitrary value for the `Host` header.
It is therefore recommended to test how your application behaves in this case.
--------------------------------------------------------------------------------
Section: ### Response Rewriting
Use this feature to replace backend hostnames in responses
or set to `custom` to configure complex rewriting use cases.

- `off` disables automatic response rewriting
- `header` enables auto rewrite for response headers (including Set-Cookie header)
- `complete` enables auto rewrite for the entire response (including body)
- `custom` configure `Response Rewriting Settings` via `Additional Settings`
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the HTTP methods allowed for this application. 

Methods which are listed here must also be allowed on the `Virtual Host`.

You may also use the following method groups:

* `ALL-HTTP` includes common HTTP methods.

  These are: `GET, POST, HEAD, DELETE, TRACE, CONNECT, OPTIONS, PUT, PATCH`

* `ALL-WEBDAV` includes all methods required for WebDAV.
  
  These are: `MERGE, UNCHECKOUT, MKACTIVITY, PROPPATCH, LOCK, CHECKOUT, SEARCH, COPY, MKCOL, MKWORKSPACE, PROPFIND, UPDATE, REBIND, BASELINE-CONTROL, UNBIND, CHECKIN, VERSION-CONTROL, UNLOCK, LABEL, MOVE, ACL, BIND, REPORT` 

To remove methods from `ALL-HTTP` and `ALL-WEBDAV` simply add the method with a `-` sign in front of it.
--------------------------------------------------------------------------------
Section: ### Session Termination
Use this feature to terminate sessions on the backend application.

nevisProxy will send a `GET` request to this path when the nevisProxy session is terminated (due to logout or session timeout).
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param(s)` for the Http(s)ConnectorServlet. For example: ConnectionRetries=10

Please check the nevisProxy technical documentation for supported `init-params` of the servlet classes `ch::nevis::isiweb4::servlet::connector::http::HttpConnectorServlet` and `ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet`.

## Secret Test

#*TESTING ONLY - NOT FOR PRODUCTION USE*

Used for testing the secret-preserving in Kubernetes deployments.

Assign to a `nevisProxy Instance` using `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Secret File(s)
Set a variable and upload secret file(s) in the inventory.

The file `/var/opt/nevisproxy/<instanceName>/run/secret_files.txt` should then contain:

- classic: resolved value(s)
- Kubernetes: `inv-res-secret://` reference(s)

## Security Response Headers

Configure security headers to be set by nevisProxy on responses.
Assign the pattern to an entire `Virtual Host` or individual applications.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply the cache handling on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |

## TCP Settings

Use the pattern to customize TCP connections to backend applications.
Assign the same pattern to multiple applications to enforce a common standard.

| `DNS Caching` | `Keep-Alive` | Description |
| ------------------------------------- | ------------------------------------- | --- |
| `disabled` | `disabled` | Always works but has the biggest impact on latency. |
| `disabled` | `enabled` | DNS may resolve a new IP but Keep-Alive is enabled so some requests may still be routed to the previous IP. This may be acceptable if the previous IP is still reachable and could even be required in case sessions are bound to the TCP connection. |
| `enabled` | `disabled` | The resolved IPs are stable but for each request a new TCP connection is established. |
| `enabled` | `enabled` | The resolved IPs are stable and connections are reused. |
--------------------------------------------------------------------------------
Section: ### Lifetime
The absolute lifetime of a TCP connection. This should be configured to less than the connection lifetime allowed by the firewall between nevisProxy and the content providers. By leaving this field empty, you will be using the nevisProxy default value.


## TLS Settings

Use the add-on to customize TLS/SSL settings for nevisProxy.

Assign to a `Virtual Host` to customize settings for incoming connections.

You can customize connections to backends by assigning the pattern to your service 
(`Web Application`, `REST Application`, `SOAP Application`) using `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Protocols
The value configured here will be applied as `SSLProtocol`. 

Check the [Apache Documentation](http://httpd.apache.org/docs/current/mod/mod_ssl.html#sslprotocol) for details.

If empty and when this pattern is assigned to a `Virtual Host` the following value is used:

`-all +TLSv1.2 -TLSv1.3`

If empty and when this pattern is assigned to an application, default `SSLProtocol` from nevisProxy are applied.
Check the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy/Configuration/Servlets/HttpsConnectorServlet) for details.
--------------------------------------------------------------------------------
Section: ### Cipher Suite
The value configured here will be applied as `SSLCipherSuite`.

Check the [Apache Documentation](http://httpd.apache.org/docs/current/mod/mod_ssl.html#sslciphersuite) for details.

If empty and when this pattern is assigned to a `Virtual Host` the following value is used:

`ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES128-GCM-SHA256`

If empty and when this pattern is assigned to an application, default `SSLCipherSuites` from nevisProxy are applied.
Check the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy/Configuration/Servlets/HttpsConnectorServlet) for details.
--------------------------------------------------------------------------------
Section: ### SSL Options
The value configured here will be applied as `SSLOptions`.

It should only have value when assigned to a `Virtual Host` pattern.

Check the [Apache Documentation](http://httpd.apache.org/docs/current/mod/mod_ssl.html#ssloptions) for details.

If empty and when this pattern is assigned to a `Virtual Host` the following value is used:

`+OptRenegotiate +StdEnvVars +ExportCertData`

## Testing Service

#*TESTING ONLY - NOT FOR PRODUCTION USE*

Used for testing. This pseudo service does not configure anything but allows tweaking the validation, generation, planning and deployment processes.
--------------------------------------------------------------------------------
Section: ### On deployment
Use for testing only.

## URL Handling

Use the pattern to:

- *redirect* requests (returning status code `302` with a `Location` header)
- rewrite the path of a request, that is, *forward*.

Query parameters are always considered.

You can use the pattern as an add-on for `Virtual Host`
or any application, for example, `Web Application`, `REST Service`, `SOAP Service`.

Redirect and forward rules have the following format:

`<source> -> <destination>`

The pattern generates a nevisProxy `RewriteFilter` named `URLHandler_<name>`.
If either `source` or `destination` starts with `http://` or `https://` 
then the init-param `RequestURL` is set, otherwise `RequestURI` is used.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Filter Phase
The phase when this filter should be applied depends on your use case.

- use `START` when the redirect / rewrite should be done as early as possible.
- use `AFTER_SANITATION` to redirect / rewrite after validating the request.
- use `AFTER_AUTHENTICATION` to redirect / rewrite after authentication.

## Unauthenticated Realm

Public applications typically do not have an `Authentication Realm` assigned.
However, there are some cases where you have to assign this pattern.

1) You have a public and an authenticated application with overlapping `Frontend Paths`. 

Assign this pattern to your public application
and select `disabled` in the `Session Tracking` drop-down.

This expresses that no sessions are expected.

This pattern ensures that session tracking and authentication are excluded from 
all frontend paths of your public application.

2) You are using nevisProxy features which need a session.

For instance, the `Cookie Customization` pattern needs a nevisProxy session to store cookies
when you configure `Shared Protected Cookies` or `Protected Cookies`.

In this case, set the `Session Tracking` drop-down to `COOKIE`.

In general, we do not recommended to have a proxy session for public applications, 
as it can lead to a high sessions count. Thus, we recommend to set the `Session Timeout` as low as possible.
--------------------------------------------------------------------------------
Section: ### Update Session Timestamp Interval
Sets the minimum time interval between two updates of the session timestamp.

If the parameter is set to "0", the system will update the session timestamp each time a request accesses a session.

The `Initial Session Timeout` is used as `Update Session Timestamp Interval` if it is shorter than the duration configured here.

## Virtual Host

The pattern represents a virtual host of a `nevisProxy Instance`. 

A virtual host provides access to applications: applications are reachable on their 
`Frontend Path(s)` on all of the `Frontend Addresses` of this virtual host. 

To assign an application, add a `Web Application`, `REST Service`, or `SOAP Service` pattern,
and reference this virtual host.

The pattern supports IP-based, port-based, and name-based virtual hosting.
Name-based virtual hosting with HTTPs requires server name indication (SNI).
--------------------------------------------------------------------------------
Section: ### Name-based Virtual Hosts
With name-based virtual hosting, the server relies on the client to report the hostname
as part of the HTTP headers. Using this technique, many different hosts can share the same IP address.
 
To configure name-based virtual hosts, set the `Frontend Addresses` to the virtual
name(s) of the host and set the `Bind Addresses` to the physical addresses of the host.

For example, to set up a two virtual hosts to be reachable on the same internal address IP and port
but with different public host names, configure as follows:

```yaml
Frontend Addresses: https://www.siven.ch http://www.siven.ch
Bind Addresses: https://0.0.0.0:8443 http://0.0.0.0:8080
```

Then configure another virtual host to use the same `Bind Addresses` but different `Frontend Addresses`:

```yaml
Frontend Addresses: https://partners.siven.ch http://partners.siven.ch
Bind Addresses: https://0.0.0.0:8443 http://0.0.0.0:8080
```

Note: name-based virtual hosts using HTTPS requires all clients supporting SNI.
--------------------------------------------------------------------------------
Section: ### nevisProxy
Assign the `nevisProxy Instance` this virtual host should be assigned to.
--------------------------------------------------------------------------------
Section: ### Frontend Addresses
Define addresses (HTTPS or HTTP) at which this host will be reachable from a client perspective.

The basic syntax is:

- `<scheme>://<hostname>`
- `<scheme>://<hostname>:<port>`

A variable may be used to define different addresses for different stages (e.g. DEV, TEST, PROD).

The expression `${deployment_host}` may be used when the name of the target host is required.

Examples:

- `http://www.siven.ch`
- `https://www.siven.ch`
- `http://${deployment_host}:8080`

The `port` will, if omitted, default to `443` for HTTPS and to `80` for HTTP.

You also have to set `Bind Addresses` if:

- the addresses cannot be resolved on the target host(s)
- the port should be opened on different addresses / IPs, or ports.
- multiple virtual hosts should listen on the same endpoint (name-based virtual hosts).
--------------------------------------------------------------------------------
Section: ### Bind Addresses
The physical address(es) to bind on, with scheme HTTP or HTTPS and ports. 

Must be set when multiple virtual hosts should listen on the same endpoint
(name-based virtual hosts).

If not set the `Frontend Addresses` will be used to bind.

The host name must resolve to an IP which is bound to a network interface.

You can also use `0.0.0.0` for the host name to listen on all network interfaces.

Examples:
```yaml
https://www.siven.ch:8443
http://localhost:8080
https://192.168.1.1:443
http://0.0.0.0:80
```
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Set a trust store to validate client certificates
for incoming TLS connections.

The trust store may contain an arbitrary number of CA certificates.
Client certificates must be signed by those CAs.

**Caution**: client certificate authentication is not enabled automatically. 
As of release 4.3.1 there are no dedicated patterns but client cert authentication 
can be enforced for the entire host (e.g. using `Generic nevisProxy Settings`) 
or in the authentication process (`X509State` and `IdentityCreationFilter` init-param `ClientCert`).
--------------------------------------------------------------------------------
Section: ### Hosted Resources
Upload a ZIP to provide your own resources.

By default, the following resources are provided:

* `/favicon.ico`
* `/index.html`
* `/errorpages/403.html`
* `/errorpages/404.html`
* `/errorpages/500.html`
* `/errorpages/502.html`
* `/resources/logo.png`
* `/resources/bootstrap.min.css`
* `/resources/default.css`

This host has its own error handler (`ErrorHandler_Default`) which is assigned to the root location (`/*`).
The error handler will replace the response body when an HTTP error code occurs and an error page is available.

Error pages for HTML must be added the sub-directory `errorpages` and named `<code>.html`.

The error code is returned to the caller as this may be required by some REST clients.

If you do not want this you can assign a specific `HTTP Error Handling` pattern 
to this `Virtual Host` or to applications via `Additional Settings`.

The servlet hosting the above resources is usually mapped to the root location (`/*`), however if there is already 
another servlet mapped there, the servlet is mapped to individual root files and directories. 

If there is an undesired mapping, it can be deleted by removing the given resource from the zip file.
--------------------------------------------------------------------------------
Section: ### Require Client Certificate
Choose from:

- `disabled (default)`: No client certificate is required to connect to this virtual host.

- `enabled`: Clients must present a client certificate signed by a CA.
The CA which has issued the client certificate must be part of the `Frontend Truststore`.
When no client certificate is presented or the certificate is not valid the connection will be aborted. 
As no error page is rendered this feature is not recommended when there are browser-based clients.
Use for technical clients only.
--------------------------------------------------------------------------------
Section: ### Qos Configuration (mod_qos)
nevisProxy uses the [mod_qos](http://mod-qos.sourceforge.net/) module 
to ensure quality of service (QoS). Choose between:

- `off`: the module is disabled on this virtual host.
- `standard`: provides a default configuration which protects against common denial of service (DoS) attacks.
- `custom`: configure `Generic mod_qos Configuration` via `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the HTTP methods which are allowed on this virtual host.

The setting `default (complete)` is quite relaxed as it enables most methods. 
Only two are excluded:

- `CONNECT`: no use case of nevisProxy.
- `TRACE`: may be useful for debugging but can be a security vulnerability.

If you do not have any applications using WebDav select `basic`.

The allowed HTTP methods can be restricted further in application patterns.

For more fine-grained control you may use `Generic nevisProxy Instance Settings` 
to overwrite the `allowedMethods` (see pattern help for details).
--------------------------------------------------------------------------------
Section: ### ModSecurity Rule Set
Upload a `.zip` file containing configuration for ModSecurity.
The `.zip` must contain a configuration file called `modsecurity.conf`.

The `modsecurity.conf` file will be included for all `Web Application` patterns
which have `Request Validation` set to `standard`, `custom`, or `log only`.

Click `Download Default Configuration` to download the default configuration
which is applied when no `.zip` is uploaded.
There is one link per provided `OWASP ModSecurity CRS Version`.
--------------------------------------------------------------------------------
Section: ### HTTP/2 Support
Enables the support of HTTP/2 for incoming connections on this nevisProxy virtual host.

Note that mod_qos has limited support for HTTP/2, therefore only request level directives are supported if enabled.
--------------------------------------------------------------------------------
Section: ### Static Cache
Add a Static Content Cache pattern to the Virtual Host.

Use it to cache the early hint resources as static content in nevisProxy to further increase the performance.
Map the Static Content Cache pattern to the same paths as the Early Hints parameter.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign add-on patterns to customize the behaviour of this virtual host.


## Web Application

Using the pattern, you can set up access to a web application 
on a nevisProxy `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Virtual Hosts
Assign `Virtual Host` patterns which shall serve as entry point for this application.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
Enter the path(s) where this application shall be accessible on the assigned `Virtual Host`.

It is recommended to set only 1 path. Examples:

- `/app/` - defines a base path. 
Requests which have a path component starting with `/app/` will be sent to this application. This is the most common scenario.

- `/` - may be used when there are no other applications. 
The `Hosted Resources` of the `Virtual Host` are still accessible but all other requests will be sent to the backend application.

- `exact:/app.html` - matches requests to `/app.html` only (query parameters may also be added). 
Use for single-page applications which don't require any additional resources.
  
- `prefix:/app` - matches requests which have a path component starting with `/app`. 
Examples: `/application`, `/app/index.html`, `/app2/secure/`

In case the frontend path is different from the path used within `Backend Addresses` 
then the path will be rewritten in incoming requests. 

Note that for response by default only the headers are rewritten. See `Response Rewriting` for further options.

Note that when you enter multiple paths there are some limitations:

- Filters created by a `Realm` or `Additional Settings` will be mapped to all paths.
- The paths have to be the same on the backend server.
--------------------------------------------------------------------------------
Section: ### Backend Addresses
Enter the complete URLs (scheme, host, port and path) of the backend services. 

Note: 

- all URLs must use the same scheme and path.
- automatic path rewriting will be performed when the path differs from the `Frontend Path`.

In case you are setting multiple addresses, use `Load Balancing` to select a request dispatching strategy.
--------------------------------------------------------------------------------
Section: ### Load Balancing
Select a request dispatching strategy when several `Backend Addresses` are configured.

- `disabled` - all requests will be sent to the first address. If this address is not available the next address is chosen;
- `round-robin` - one of the addresses will be picked up for each request using a round-robin rotation;
- `session-sticky` - one of the addresses will be picked up for each new session using a round-robin rotation, then subsequent requests for the session will be sent to the same address.


Failover strategy:

* When the selected backend cannot be accessed, nevisProxy will attempt to use another one.
* Once the said backend can be accessed again, it can be picked up for new requests if the load balancing is `round-robin`, or for new sessions if the load balancing is `disabled` or `session-sticky`. 
The requests linked to an existing session will still go to the current backend until the end of the session if the load balancing is `disabled` or `session-sticky`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Optional setting for enabling trust to HTTPS backends.

For securing production environments:
- set `Backend Addresses` starting with `https://`
- assign a `Trust Store` pattern containing the certificates required for verifying the backend certificate
- set `Hostname Validation` to `enabled`
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname configured in `Backend Addresses`
--------------------------------------------------------------------------------
Section: ### Host Header
Defines the `Host` header for requests forwarded to the application.

When `backend` is selected then nevisProxy uses the host part of the backend address that has been selected.
This is the default behaviour and similar to what a browser would do.
Therefore, this configuration should work in most cases.

When `client` is selected then nevisProxy will keep the `Host` header as received from the client.
The following `init-param` will be generated:
              
```
<init-param>
  <param-name>HostName</param-name>
  <param-value>ENV:HTTP_Host;</param-value>
</init-param>
```

The configuration is dynamic to support virtual hosts with multiple frontend addresses.
Note that this may be less secure. 
Even though browsers do not allow this clients may sent an arbitrary value for the `Host` header.
It is therefore recommended to test how your application behaves in this case.
--------------------------------------------------------------------------------
Section: ### Response Rewriting
Enable to replace backend host names in responses
or set to `custom` for complex rewriting use cases.

- `off` - disables automatic response rewriting
- `header` - enables auto rewrite for response headers (including `Set-Cookie` header)
- `complete` - enables auto rewrite for the entire response (including body)
- `custom` - requires assignment of `Response Rewriting Settings` via `Additional Settings`
--------------------------------------------------------------------------------
Section: ### CSRF Protection
_Cross-Site Request Forgery_ (_CSRF_) is an attack to force an authenticated user to send unwanted requests.

- `off (default)` - no CSRF protection. Recommended for applications which may be called from other sites.
- `header-based` - `GET` and `HEAD` requests are allowed (assumption: these methods must not manipulate server-side state). 
For other requests the `Referer` and `Origin` headers must match the `Host` header.
--------------------------------------------------------------------------------
Section: ### Request Validation (ModSecurity)
- `off` - no request validation
- `standard` - uses ModSecurity OWASP Core Rule Set (CRS) with default paranoia level 1 - Basic security
- `custom` - configure `Request Validation Settings` via `Additional Settings`
- `log only` - uses `standard` in log only mode
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the HTTP methods allowed for this application. 

Methods which are listed here must also be allowed on the `Virtual Host`.

You may also use the following method groups:

* `ALL-HTTP` includes common HTTP methods.

  These are: `GET, POST, HEAD, DELETE, TRACE, CONNECT, OPTIONS, PUT, PATCH`

* `ALL-WEBDAV` includes all methods required for WebDAV.
  
  These are: `MERGE, UNCHECKOUT, MKACTIVITY, PROPPATCH, LOCK, CHECKOUT, SEARCH, COPY, MKCOL, MKWORKSPACE, PROPFIND, UPDATE, REBIND, BASELINE-CONTROL, UNBIND, CHECKIN, VERSION-CONTROL, UNLOCK, LABEL, MOVE, ACL, BIND, REPORT` 

To remove methods from `ALL-HTTP` and `ALL-WEBDAV` simply add the method with a `-` sign in front of it.
--------------------------------------------------------------------------------
Section: ### Session Termination
Use this feature to terminate sessions on the backend application.

nevisProxy will send a `GET` request to this path when the nevisProxy session is terminated (due to logout or session timeout).
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param(s)` for the Http(s)ConnectorServlet. For example: ConnectionRetries=10

Please check the nevisProxy technical documentation for supported `init-params` of the servlet classes `ch::nevis::isiweb4::servlet::connector::http::HttpConnectorServlet` and `ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet`.

## WebSocket Support for Application

The pattern enables WebSocket support for backend applications. 
Assign to your application using `Additional Settings`.

The pattern generates two additional servlets:

- a `WebSocketServlet` named `Connector_<application>_WS`
- a `ServletMappingServlet` which selects `Connector_<application>_WS` when the HTTP Header `Upgrade` contains the value `websocket`

The TCP connection is reserved for each WebSocket connection.
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param` for the WebSocket servlet. 

Please check the nevisProxy technical documentation for supported `init-params` 
of the servlet class `ch::nevis::isiweb4::servlet::connector::websocket::WebSocketServlet`.

## nevisKeybox Store

Apply the pattern to use existing key material from nevisKeybox. 
You can assign the pattern where-ever a key store or trust store is required.

The nevisKeybox instance is to be named `default`.

The pattern does not deploy any key material. 
This is the intended behavior and not a limitation.

To deploy a private key and certificate you may use `PEM Key Store` instead,
for deploying trusted certificates use `PEM Trust Store` instead.
--------------------------------------------------------------------------------
Section: ### Slot
A `Slot` is a directory of a nevisKeybox instance.

By default, nevisKeybox is located at `/var/opt/neviskeybox/default/`.
If missing please run the following command on the affected target server(s):

`neviskeybox handover`

A `Slot` may contain:

- an arbitrary number of key stores (identified by label)
- up to 1 trust store.
--------------------------------------------------------------------------------
Section: ### Validation
Allows to the validation in case the nevisKeybox is deployed by this project (e.g. using `Generic Deployment`).

## nevisProxy Instance

The pattern represents a nevisProxy instance.

Create at least one `Virtual Host` pattern and assign this pattern.
--------------------------------------------------------------------------------
Section: ### Default Virtual Host
The default virtual host of this nevisProxy instance. 

The default will be used for requests without a `Host` header
or if there is no host with a corresponding frontend address.
--------------------------------------------------------------------------------
Section: ### Server LogFormat
Allows the configuration of the `LogFormat` Apache directive in the navajo.xml file.

For more information, check the [official Apache documentation](http://httpd.apache.org/docs/current/mod/mod_log_config.html#logformat) of the directive.

## nevisProxy Observability Settings

Sets up observability with OpenTelemetry for nevisProxy.

The OpenTelemetry settings are applied to each Virtual Host of the instance.
--------------------------------------------------------------------------------
Section: ### Metrics Interval
Interval of the metrics reader to initiate metrics collection.

## nevisProxy Remote / Hybrid Session Store

Configures nevisProxy to use a MariaDB database for storing sessions.
Assign to `Virtual Host` as `Session Store`.

Use this pattern when in-memory session storage cannot be used.
Note that in-memory sessions may be sufficient in the following cases:

- classic (VM) deployment: only 1 line or load balancing towards proxy is session sticky
- Kubernetes deployment: only 1 pod (not recommended)

The session store is used only when there are filters or servlet which require a session.
In particular, this is the case when you assign an `Authentication Realm` to applications.

You can choose between _remote_, or _hybrid_ session store.
An overview about different types can be found [here](https://docs.nevis.net/nevisproxy/Use-Cases-and-Best-Practices/Session-Store-Setups/).
The _hybrid_ session store can be used in classic deployment only.

When deploying to Kubernetes, the database and connection user will be created automatically.
The database schema will be migrated automatically when upgrading Nevis on the next deployment.

In classic VM deployment you have to create the database including tables.
Setup instructions can be found in the nevisProxy Technical Documentation. 
For details see [`Configuration of MariaDB-based remote session store`](https://docs.nevis.net/nevisproxy/Configuration/Servlets/MySQLSessionStoreServlet).
--------------------------------------------------------------------------------
Section: ### TLS Encryption
If `enabled` the query parameter `useSSL=true` will be added to enable 1-way TLS.

If no `Trust Store` is assigned then `trustServerCertificate=true` will be added to the connection string.

Assignment of a `Trust Store` is recommended for production use.

**Note:** `PostgresSQL` database connection configuration doesn't support TLS connection yet.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Session Store Peer Address
The hybrid session store requires that the `nevisProxy Instance` is deployed on 2 lines.
For illustration purposes let's call the hosts where the instances are deployed `p1` and `p2`.

Enter the URL where the other nevisProxy `Virtual Host` exposes its local session store.
The URL must be reachable and should not go via a load-balancer to ensure that the request reaches the peer proxy directly.

You can use variables to ensure that the correct host name is used for the configuration on each line.
For instance, the variable may be a host variable and have the following values:

- for server `p1` use: `https://p2:443`
- for server `p2` use: `https://p1:443`

Alternatively, you can use a semantic host name and and define this name in `/etc/hosts` on both `p1` and `p2`.

Example: `https://proxy-peer:443`
--------------------------------------------------------------------------------
Section: ### Peer Servlet Strategy
Controls the used strategy of the Peer Servlet:

 * `FAILOVER`: The loadbalancer sends all requests to the same instance (instance A). If instance A goes down, the loadbalancer will send now all requests to instance B. The loadbalancer should only switch back to instance A if it has been restarted.
 * `DISTRIBUTED`: The loadbalancer assure at least 90% session stickiness to both instances, for example by using the client IP address. Once the request for a session goes to the other instance, this one will get the session information from the first instance and copy into its local session store.
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param` for the MySQL session store servlet.

Check the nevisProxy technical documentation for supported parameters
of the servlet class `ch::nevis::nevisproxy::servlet::cache::mysql::MySQLSessionStoreServlet`.
--------------------------------------------------------------------------------
Section: ### Configuration: nevisfido.yml
This setting provides a low-level way to
add or overwrite configuration in `nevisfido.yml`.

Enter the configuration as it would appear in the `nevisfido.yml` using correct indentation.

For now, the only supported case is to add additional entries to the `dispatchers` block. 
The setting will be improved in a future release to support additional cases.

Example:

```yaml
fido-uaf:  
  dispatchers:
  - type: png-qr-code
    registration-redeem-url: http://localhost:9080/nevisfido/token/redeem/registration
    authentication-redeem-url: http://localhost:9080/nevisfido/token/redeem/authentication
    deregistration-redeem-url: http://localhost:9080/nevisfido/token/redeem/deregistration
```


## In-band Mobile Authentication Realm

Sets up [In-Band Authentication](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/in-band-authentication) 
to protect REST services.

If you want to protect a web application and use mobile authentication from a web browser, use `Out-of-band Mobile Authentication` instead.

In a nutshell, the pattern configures Nevis for the following use case:

1. The user opens the mobile application and accesses a protected resource, for which they have no authorization yet.
2. The mobile application prompts the user to authenticate.
3. The mobile app sends a request to `/auth/fidouaf` to authenticate.
4. The user is now authenticated, the mobile application is able to access the protected REST service.

Before executing mobile authentication, the user has to register their mobile device. 
The required APIs can be set up using `In-band Mobile Registration Service` pattern.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a pattern which provides the trust store for nevisAuth to connect to nevisFIDO.
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses for validating the signature of the NEVIS SecToken issued by nevisAuth.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter` generated by this pattern.

Most realms generate only 1 `IdentityCreationFilter` named `Authentication_<name>`, 
which is used to protect the application.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                 |
|----------------------|---------------------------------------|
| BodyReadSize         | 64000                                 |
| InterceptionRedirect | Condition:ENV:HTTP_USER_AGENT:mozilla\|Mozilla\ninitial\nnever |
| ClientCert           | want                                  |
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Virtual Host
A virtual host assigned will be used to expose the protected services.
--------------------------------------------------------------------------------
Section: ### nevisFIDO
Assign a `nevisFIDO UAF Instance`. This instance will be responsible for providing the mobile device deregistration services.

## Out-of-band Device Management App

#*DEMO/TESTING ONLY - NOT FOR PRODUCTION USE*

Provides a simple self-service application for mobile device management.
The application is a single page app (SPA) and will be hosted on the `Virtual Host` at the `Frontend Path`.

The SPA is **not** ready for production use. We recommend to implement your own Web application.
At least you have to adapt the HTML, CSS, and JavaScript based on your requirements.

The nevisIDM `bootstrap` user (or any other user with `nevisIdm.Root` role)
can not be used to test the device management as the nevisfido technical user
is not allowed to manage credentials of root users.

The SPA sends the following AJAX calls to render a device list:

1a) Get user attributes: `GET /nevisidm/api/principal/v1/me` (authentic)
1b) Get generic credentials: `GET /nevisidm/api/core/v1/100/users/<userExtId>/generic-credentials/` (authentic)

When you then click "Enroll new device", the following API calls are sent:

2a) Generate QR-Code: `POST /nevisfido/token/dispatch/registration` (authentic)
2b) Poll for completion: `POST /nevisfido/status` (public)

Now you can scan the displayed QR code with the mobile app. This leads to the following calls:

3a) `POST /nevisfido/token/redeem/registration` (authentic)
3b) `GET /nevisfido/uaf/1.1/facets` (public)

The registration is completed with by the mobile app with:

4a) `POST /nevisfido/uaf/1.1/registration/` (authentic)

This pattern does **not** validate that the required APIs are set up!
You **must** provide these APIs by adding appropriate patterns.
For instance, you can use the following patterns:

- `nevisIDM REST Service` or `nevisIDM Administration GUI` (provides 1a, 1b)
- `Out-of-band Mobile Registration Service` (provides 2a, 2b, 3a, 3b, 4a)

The same `Authentication Realm` must be assigned in all these patterns.
--------------------------------------------------------------------------------
Section: ### Virtual Host
A virtual host assigned will be used to expose services required for ```Out-of-band Management Application```.
--------------------------------------------------------------------------------
Section: ### Frontend Path
The path at which the management app shall be accessible at the frontend.
--------------------------------------------------------------------------------
Section: ### Virtual Host
To complete the authentication, the mobile app will send a request
to `/nevisfido/token/redeem/authentication`.

The domain is coded into the mobile app and has to be communicated
when ordering the app.

We recommend to assign the `Virtual Host` which serves that domain here
so that this pattern can generate the required configuration.

The `Virtual Host` assigned here will also be considered when calculating
the `Frontend Address` in the `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Key Store
Assign a key store for the TLS connection to nevisFIDO.

If no pattern is assigned, a key store will be provided
by automatic key management.

The client certificate in the key store must be trusted by nevisFIDO.

In case both sides use automatic key management, trust can be established automatically and there is nothing to configure.

However, if you are using a different kind of key store,
then you **must** configure `Frontend Trust Store` in the associated `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used to establish a connection with the nevisFIDO component.

The trust store must contain the certificate of the CA that has issued
the certificated contained in the `Key Store` of the `nevisFIDO UAF Instance`.

In case both sides use automatic key management, 
trust can be established automatically and there is nothing to configure.
--------------------------------------------------------------------------------
Section: ### Virtual Host
To complete the authentication, the mobile app will send a request
to `/nevisfido/token/redeem/authentication`.

The domain is coded into the mobile app and has to be communicated
when ordering the app.

We recommend to assign the `Virtual Host` which serves that domain here
so that this pattern can generate the required configuration.

The `Virtual Host` assigned here will also be considered when calculating
the `Frontend Address` in the `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Key Store
Assign a key store for the TLS connection to nevisFIDO.

If no pattern is assigned, a key store will be provided
by automatic key management.

The client certificate in the key store must be trusted by nevisFIDO.

In case both sides use automatic key management, trust can be established automatically and there is nothing to configure.

However, if you are using a different kind of key store,
then you **must** configure `Frontend Trust Store` in the associated `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used to establish a connection with the nevisFIDO component.

The trust store must contain the certificate of the CA that has issued
the certificated contained in the `Key Store` of the `nevisFIDO UAF Instance`.

In case both sides use automatic key management, 
trust can be established automatically and there is nothing to configure.
--------------------------------------------------------------------------------
Section: ### Profile ID Source
Enter a variable expression for the profile ID.

The default works when this step is a follow-up of
`nevisIDM Password Login` or `nevisIDM User Lookup`.


## Out-of-band Mobile Registration Service

Provides services for [Out-of-Band Registration](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-registration).

The following paths will be exposed:

- `/nevisfido/token/dispatch/registration`
- `/nevisfido/token/redeem/registration`
- `/nevisfido/uaf/1.1/facets`
- `/nevisfido/uaf/1.1/registration/`
- `/nevisfido/status`

Out-of-band registration requires a browser and works as follows:

1. The user accesses a Web application which generates a QR code.
2. The user scans the QR code with the mobile app.
3. The mobile app creates a client-side credential.
4. The mobile app calls services provided by this pattern to establish a FIDO UAF credential in nevisIDM.

Alongside the FIDO UAF credential a Generic credential is generated which makes the mobile device a dispatch target, to which push notifications can be sent.
For more information, see [Dispatch Target Management](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/dispatch-target-management).

The Web application, which is responsible for QR code generation, is *not* provided by Nevis.
However, you can use the 'Out-of-band Device Management App' pattern to test out-of-band registration.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign the `Virtual Host` which serves the domain where the nevisFIDO services shall be exposed
so that this pattern can generate the required configuration.

The domain is coded into the mobile app and has to be communicated
when ordering the app.

The `Virtual Host` assigned here will also be considered when calculating
the `Frontend Address` in the `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` to expose the transaction confirmation services.

The following public endpoints can be invoked:

- `/nevisfido/token/dispatch/authentication`
- `/nevisfido/status`
- `/nevisfido/token/redeem/authentication`
- `/nevisfido/uaf/1.1/facets`
- `/nevisfido/uaf/1.1/authentication`
--------------------------------------------------------------------------------
Section: ### Virtual Host
To complete the authentication, the mobile app will send a request
to `/nevisfido/token/redeem/authentication`.

The domain is coded into the mobile app and has to be communicated
when ordering the app.

We recommend to assign the `Virtual Host` which serves that domain here
so that this pattern can generate the required configuration.

The `Virtual Host` assigned here will also be considered when calculating
the `Frontend Address` in the `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Key Store
Assign a key store for the TLS connection to nevisFIDO.

If no pattern is assigned, a key store will be provided
by automatic key management.

The client certificate in the key store must be trusted by nevisFIDO.

In case both sides use automatic key management, trust can be established automatically and there is nothing to configure.

However, if you are using a different kind of key store,
then you **must** configure `Frontend Trust Store` in the associated `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used to establish a connection with the nevisFIDO component.

The trust store must contain the certificate of the CA that has issued
the certificated contained in the `Key Store` of the `nevisFIDO UAF Instance`.

In case both sides use automatic key management, 
trust can be established automatically and there is nothing to configure.
--------------------------------------------------------------------------------
Section: ### Authentication Level
Set an authentication level to apply when authentication is successful. 

The level is relevant only if there are is an `Authorization Policy` assigned to applications.


## nevisFIDO UAF Connector

Use to connect to an existing nevisFIDO UAF instance.

Use the pattern only when the instance is not set up by the project.

Ensure that the SecToken trust store of the instance allows the 
SecToken signers used in this project.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Frontend Address
Enter the address of the `Virtual Host` where the services of this instance are exposed.

Enter the address without any path component.

Example:

```
https://example.com
```

If no address is provided, the pattern tries to automatically determine a value based on the `Virtual Host` patterns,
that are associated with this instance through patterns for out-of-band use-cases.

The entered value is used to calculate:

* [AppID](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-appid-and-facets-v1.1-id-20170202.html#the-appid-and-facetid-assertions)
* _Dispatch payload_

The _dispatch payload_ informs the mobile device where to access nevisFIDO for the following use cases:
- [Out-of-band Registration](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-registration)
- [Out-of-band Authentication](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication)
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store provider for the HTTPs endpoint.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for SecToken verification.
--------------------------------------------------------------------------------
Section: ### Deep Link Host
If you have uploaded any `Deep Link App Files`, then assign a `Virtual Host`.

The files will be hosted with a base path of `/.well-known/`.

The domain of the `Deep Link` must point to this `Virtual Host`.

If the user does not have the mobile app installed,
the `Deep Link` will be opened in the browser instead.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store nevisFIDO uses to connect to ```nevisIDM Instance```.
--------------------------------------------------------------------------------
Section: ### quickstart-appliance.md
---
sidebar_position: 2
---

# First steps (nevisAppliance)

This chapter helps you to get started with nevisAdmin 4.

It provides an introduction to the nevisAdmin 4 GUI, in the form of a tutorial.

The tutorial guides you through your first setup of Nevis Identity Suite and is based on classic VM deployment.

## Prerequisites

To use nevisAdmin 4 in your environment, the software has to be installed first.

It is recommended starting with one of these two variants:

* nevisAppliance installation with 2 VMs:

  * VM1 with an admin4 image, version 2019-02-20 or later.
    See [Software Installation](./Installation/Software-Installation) for image and nevisAdmin 4 installation instructions.

  * VM2 with the extended image, version 2019-02-20 or later. This image contains nevisProxy, nevisAuth, nevisIDM, and other components.
    See [Software installation](/nevisappliance/Installation/Software-installation) in the nevisAppliance documentation for image installation instructions.

 :::info
 We recommend using *remote* VMs instead of installing them on the same laptop. The reason is that it can be hard to configure the required networking/routing settings in VirtualBox or VMWare Workstation.
 :::

* RPM-based installation, all on the same VM:

  * Start with a basic RHEL 7 VM installation.
  * See "Software Installation" for RPM and nevisAdmin 4 installation instructions.
  * Install the RPM for nevisProxy 3.14.0.1 or higher.

For the tutorial below, it is assumed that:

* nevisAdmin 4 is up and running, and reachable via `http://nevisadmin4:9080/nevisadmin/`.
* nevisProxy, or the nevisAppliance *extended* image, is installed

  * The host is accessible via SSH at nevisproxy.
  * After completing the tasks below, it will host a website at `https://nevis`.

Depending on your environment, adapt the host names "nevisadmin4", "nevisproxy" and "nevis" as follows:

* nevisAppliance installation:

  * "nevisadmin4": Hostname of VM1.
  * "nevisproxy": Hostname of VM2.
  * "nevis": Hostname of VM2.
    * Or: Add "nevis" to */etc/hosts* on VM2 and on the device where the browser runs.

* RPM-based installation, all on the same VM:

  * "nevisadmin4": Hostname of the VM.
  * "nevisproxy": Hostname of the VM.
  * "nevis": Hostname of the VM.
    * Or: Add "nevis" to */etc/hosts* on the VM and on the device where the browser runs.

## Tutorial: Setting Up nevisProxy with nevisAdmin 4

The following steps will show you a basic example workflow of configuring and deploying your Nevis environment with nevisAdmin 4. It will guide you through the GUI to create your first patterns and thus configure a nevisProxy as a WAF.

The tutorial consists of the following tasks:

* Task 1: Creating Your First nevisAdmin 4 Project
* Task 2: Adding a Web Application
* Task 3: Protecting the Web Application with a nevisProxy WAF
* Task 4: Configuring the Infrastructure Components for nevisProxy
* Task 5: Deploying Your Configuration to nevisProxy
* Further Steps

:::info
Each task includes a movie that illustrates the steps to perform.
:::
--------------------------------------------------------------------------------
Section: ### Task 2: Adding a Web Application
As an example, we will protect the publicly available website [https://www.adnovum.ch](https://www.adnovum.ch/) with nevisProxy.

To create the necessary configuration with nevisAdmin 4, execute the following steps:

1. Click *New Web Application* in the *Get started with nevisAdmin 4* section.
2. Now you have a new pattern of the type *Web Application* in front of you. Each pattern comes with a *Pattern Editor* (visible in the middle part of the screen). In this editor, you configure the features of the pattern. We call the configuration options *properties*.
3. Click on the editor icon next to the pattern title on top of the *Pattern Editor*. Rename the pattern to "AdNovum Website".
4. Specify the following pattern properties in the corresponding fields:
    * In the *Basic Settings* tab:
      * *Frontend Paths*: "/adnovum-web/".
      All requests with this path will be forwarded to the application.
      * *Response Rewriting*: "complete".
      This configures nevisProxy to replace "/" in the request header and page body with "/adnovum-web/".
    * In the *Backend Connection* tab:
      * *Backend Addresses*: `http://www.adnovum.ch`.
      nevisProxy will use this URL to access the application.
      * *Trust Store*: "SwissSign CA".
      Because the backend `www.adnovum.ch` is secured with TLS, we need to add a truststore to nevisProxy with the root CA of the page's certificate. This enables nevisProxy to validate the certificate of the web application and use it as a backend. Execute the following steps:
        * Enter "SwissSign CA" in the drop-down menu of the *Trust Store* property.
        * Click *Add pattern 'SwissSign CA'*.
        * Select type *PEM Trust Store Provider*.
        * Click *Add pattern*.

5. Click *Save Changes*.

<img className="boxed" src={require('../assets/create-web-app.gif').default} alt="How to add a Web Application pattern" />

The public site `www.adnovum.ch` has an official certificate from SwissSign. nevisProxy needs to trust the certificate of this site to establish the TLS connection. Therefore, we add the CA to a PEM truststore:

1. Export the root CA of `https://www.adnovum.ch/` with your browser like shown in the movie.
2. Navigate to the newly added pattern *SwissSign CA*.
3. Attach the exported CRT file into the *Trusted Certificates: as file* field.
4. Save your modifications.

<img className="boxed" src={require('../assets/export-certificate.gif').default} alt="How to export CA and import to trust store" />

:::info
You have successfully created your first two patterns! By adding references between the patterns, you combine the various settings into one overall configuration. Our *AdNovum Website* pattern for example has a reference to the *SwissSign CA* pattern*.*
:::
--------------------------------------------------------------------------------
Section: ### Task 3: Protecting the Web Application with a nevisProxy WAF
After configuring the web application, we want to access it with nevisProxy as WAF in between, so we configure a virtual host for that:

1. Navigate back to the *AdNovum Website* pattern.
2. Enter "My nevisProxy Host" in the drop-down menu of the *Virtual Host* property.
3. Click *Add pattern 'My nevisProxy Host'*.
Click *Save changes* and follow the link to the newly added pattern "My nevisProxy Host".
4. The properties of the pattern "My nevisProxy Host" appear in the *Pattern Editor*. Specify the following properties of this pattern:

* *Frontend Addresses*: `https://nevis`.
      The property *Frontend Addresses* sets the external domain name hosted by your nevisProxy. In our example, we use `https://nevis`. Adapt this according to your Nevis setup.
* A nevisProxy host context must have a reference to a nevisProxy instance. You specify this reference in the property *nevisProxy*. Proceed as follows:
    1. Enter "My Proxy" in the drop-down menu field of the *nevisProxy* property.
    2. Click *Add pattern 'My Proxy'*.
    3. Click *Save changes* and follow the link to the newly added pattern "My Proxy".
    4. The properties of the pattern "My Proxy" appear in the *Pattern Editor*.
    Specify the following pattern property:
    *Deployment Target*: "proxies".
    This is where the proxy should run. Instead of defining a hostname, we enter a name of the hostgroup, here "proxies".
    The next section explains how to configure the host group.
    5. Click *Save changes*.

 <img className="boxed" src={require('../assets/Add-proxy.gif').default} alt="How to add a nevisProxy pattern" />
--------------------------------------------------------------------------------
Section: ### Protect-sub-application-paths.md
---
sidebar_position: 78
---

# Protect sub-application paths

This page describes two cases of protecting an application with **Frontend Path** `/app/`.

## The path /app/sub/ belongs to another application

If the path `/app/sub/` belongs to another application, that is, points to another backend server, simply add another application pattern (for example, a **Web Application**) and set **Frontend Path** to `/app/sub/`.

When a request comes in, nevisProxy first determines the most specific servlet, and then calculates the filter chain.

For filters with a known purpose (for example, authentication), nevisAdmin 4 automatically generates the required `exclude-url-regex` for filters mapped to `/app/`, thus avoiding that they are applied to `/app/sub/` as well.

Filtering inheritance may break the application isolation, and therefore nevisAdmin 4 ensures that filters are excluded for sub-paths belonging to other applications whenever possible.

## The path /app/sub/ is sensitive, and should not be accessible

Assign an **Access Restriction** pattern to the application using **Additional Settings**.

Configure it to block all IP addresses, and set the property **Apply only to sub-paths** to `sub/`.
--------------------------------------------------------------------------------
Section: ### nevisProxy Instance Pattern
The *nevisProxy Instance* pattern sets up an empty instance of nevisProxy.

You have to use the *Virtual Host* pattern to add a *web.xml* file and the required connector configuration.

Additionally, you can assign the *Generic nevisProxy Settings* add-on pattern to adapt low-level settings in the *navajo.xml* file.

Additional add-on patterns are planned for future releases (for example, for nevisProxy sizing).
--------------------------------------------------------------------------------
Section: ### Service Patterns
Patterns that implement the Service interface are used to make content accessible via nevisProxy.

The *Hosting Service* pattern facilitates the deployment of static pages on nevisProxy over a certain path.

Service access patterns support the integration of backend applications.  nevisAdmin 4 provides the following service access patterns:

* *Web Application*: Used for classic web applications (e.g., form-based) and hybrid applications. CSRF protection and ModSecurity are enabled by default.
* *REST Service*: Used for REST APIs. Basic JSON validation is enabled by default.
* *SOAP Service*: Used for SOAP APIs. Schema validation using WSDL is in development for nevisAdmin 4.2.

See [First Steps](../quickstart-appliance) on how to use these patterns to integrate an application.
--------------------------------------------------------------------------------
Section: ### Add-On Patterns
Several add-on patterns facilitate application protection. You can assign these add-on patterns to the following patterns:

* *Virtual Host* pattern - Assign an add-on to this pattern to change the behavior of the root location. This affects all services.
* Service patterns - Assign an add-on to a service pattern if you want to configure a feature for this service only. Service patterns are, for example, *REST Service* and *SOAP Service*.

Technically, assigning an add-on to a pattern is possible under the following conditions:
* The add-on pattern implements the *PathLocationAddon* interface, and
* the pattern supports the *PathLocation* interface.
* See also the figure: Application Protection patterns above.

The add-ons are mostly used to enable WAF features. Example add-ons are:

* *Access Restriction*: Use this add-on to white- or blacklist IPs.
* *ICAP Scanning*: Use this add-on to perform a virus scan of uploaded files.
* *Request Validation Settings*: Use this add-on to fine-tune the request validation by changing the configuration of ModSecurity.

See: [Standard Patterns Reference](../../../nevisadmin4/Appendixes/Standard-Patterns-Reference) for a complete list of the add-on patterns.

## What if my Use Case is not Covered by the Standard?

If your use case is not covered by the standard patterns, contact Nevis Support and explain your case. The nevisProxy patterns are in active development and we are interested in your requirements.

In the meantime you have several options:

* Customize the settings in the *navajo.xml* file with the *Generic nevisProxy Settings* pattern. The *Help* page of this pattern explains which cases are supported.
* Adapt the configuration in the *web.xml* file with the *Generic Virtual Host Settings* pattern or the *Generic Application Settings* pattern.
* Solve complex use cases with the Lua script, by means of the *Lua HTTP Processing* pattern.

## How to configure the nevisProxy examples with nevisAdmin 4?

The examples provided in the nevisProxy documentation and in the installed package under `/opt/nevisproxy/examples/` cover several aspects of a typical nevisProxy configuration.
They fall into three broad categories:
--------------------------------------------------------------------------------
Section: ### Examples with LuaFilters
Several examples show how to configure one or several LuaFilters to perform certain tasks.
The reason for using a LuaFilter can be that the use case is too specific to have its own filter, or that the process has to be fine-tuned for the target installation.
Let us know if you use one of the LuaFilter examples in your configuration.
We may create a dedicated filter or pattern for the widespread ones.

Proceed as follows to configure a *Lua HTTP Processing* pattern from an existing LuaFilter:

- Add a *Lua HTTP Processing* pattern to your configuration;
- Copy the content of the `Script` parameter from the LuaFilter in the *Lua Script* setting;
- Check that the names of the functions to be invoked for the requests and responses match the list in the description of the *Lua Script* setting;
- If the LuaFilter includes parameters, rename them in the script with the prefix `param_` and list them in the *Script Parameters* setting;
- Replace the placeholders as described in [Placeholders in the examples and default values](../../../nevisproxy/Placeholders-in-the-examples-and-default-values), generally:
  - `@PKG_HOME@` &rarr; `/opt/nevisproxy`
  - `@PKG_VAR@` &rarr; `/var/opt/nevisproxy`
  - `@PKG_INSTANCE@` &rarr; name of the nevisProxy instance
- Set the *Filter Phase* if your filter should be invoked during a specific processing step;
- Link the pattern to the *Additional Settings* of the target *Application* or *Virtual Host* pattern(s).
--------------------------------------------------------------------------------
Section: ### Filter-Mapping-Concepts.md
---
sidebar_position: 83
---

# Filter Mapping Concepts

Several nevisAdmin 4 patterns configure filters for nevisProxy. These filters have to be applied to requests and/or responses. For this, you need to configure *filter-mapping* elements in a nevisProxy *web.xml* file.

This chapter describes how patterns generate the *filter-mapping* elements, based on examples.

## Filter Inheritance

Suppose there is a nevisAdmin 4 project containing the following patterns:

<img className="boxed" src={require('../../../assets/50823525.png').default} alt="nevisAdmin 4 Test project with patterns"/>

This project sets up a nevisProxy instance with one virtual host serving the domain `www.mycompany.com`.

By default, the *Virtual Host* pattern sets up an *ErrorFilter* to handle HTTP error codes (such as the 404 Not Found code, or the 500 Internal Server Error code). This default error filter *ErrorHandler_Default* is applied to the root location via the following *filter-mapping* element:

```script title="Root Location Filter Mapping"
<filter-mapping>
 <filter-name>ErrorHandler_Default</filter-name>
 <url-pattern>/*</url-pattern>
</filter-mapping>
```

Because `/*` matches all paths, the default error filter is applied to all requests and responses: The filter is **inherited** to all sub-locations.

Filters are always inherited by default.

## Duplicated Filter Problem

Patterns often want to apply filters to specific sub-locations. This can cause the Duplicated Filter Problem. The following sample case illustrates this problem.

Suppose you have the following *Web Application* pattern:

<img className="boxed" src={require('../../../assets/50823527.png').default} alt="Sample Web Application pattern"/>

You want to give this application a different error handling: In case of an HTTP 404 Not Found error code, the application will return a nicer page than the default error page. In nevisAdmin 4, you can realize this by configuring a custom *HTTP Error Handling* pattern and assigning this pattern to the virtual host, via the *Additional Settings* field of the *Virtual Host* pattern:

<img className="boxed" src={require('../../../assets/50823524.png').default} alt="Assigning Error Handling pattern to Virtual Host pattern"/>

The *HTTP Error Handling* pattern "Custom 404" in the previous figure generates the following *filter-mapping* element, mapping the custom error filter *ErrorHandler_Custom_404* to `/myapp/*`:

```script title="Sub-location Filter Mapping"
<filter-mapping>
 <filter-name>ErrorHandler_Custom_404</filter-name>
 <url-pattern>/myapp/*</url-pattern>
</filter-mapping>
```

But: The *Virtual Host* pattern already maps the default error filter *ErrorHandler_Default* to `/*`. This means that error handling would be done twice for requests sent to your application. This is what we call the Duplicated Filter Problem.

## Filter Purpose Exclusion Mechanism

To solve the Duplicated Filter Problem, nevisAdmin 4 provides the *filter purpose exclusion* mechanism: When you declare a *purpose* for a filter, the nevisProxy generator automatically generates an *exclude-url-regex* expression for *filter-mapping* elements.

This algorithm works as follows:

* When generating a filter *F*, patterns can set a purpose for this filter.
* When *F* is mapped to a parent location *P* and a sub-location *C*, a regular expression *R* for *C* is generated.
* *R* is added to the *exclude-url-regex* of the *filter-mapping* for *F* at *P*.

Because of this *filter purpose exclusion* mechanism, the *filter-mapping* element for the default error filter *ErrorHandler_Default* of our example changes as follows:

```script title="Root Location Filter Mapping"
<filter-mapping>
 <filter-name>ErrorHandler_Default</filter-name>
 <url-pattern>/*</url-pattern>
 <exclude-url-regex>^/myapp/.*$</exclude-url-regex>
</filter-mapping>
```

As of nevisAdmin 4.6, the *filter purpose exclusion* mechanism is applied for the following use cases (patterns):

* HTTP Error Handling
* Request Validation (ModSecurity)
* CSRF Protection
--------------------------------------------------------------------------------
Section: ### Protecting-a-Web-Application.md
---
sidebar_position: 79
---

# Protecting a Web Application

The chapter [First Steps](../../quickstart-appliance) describes in detail how to make a web application accessible via nevisProxy. Depending on the type of application, you use one of the following patterns:

* *Web Application* pattern:
  * Suitable for form-based web applications as well as for hybrid applications consisting of a single-page application and REST API.
  * Provides simple header-based CSRF protection by default.
  * Provides ModSecurity with OWASP Core Rule Set by default.
  * You can customize the CSRF protection and the ModSecurity rules directly in the *Web Application* pattern screen:
    * CSRF protection: Select "custom" from the drop-down menu in the *Security: CSRF Protection* field, then assign and configure the add-on pattern *CSRF Protection Settings* via the *Additional Settings* field.
    * ModSecurity rules: Select "custom" from the drop-down menu in the *Security: Request Validation* field, then assign and configure the add-on pattern *Request Validation Settings* via the *Additional Settings* field.
* *REST Service* pattern:
  * Used for stand-alone REST APIs.
  * Will have options for CORS in future releases.
* *SOAP Service* pattern:
  * Will have options for schema validation in future releases.

:::note
You can add extra security features to all patterns in the GUI, by assigning add-on patterns via the *Additional Settings* field. You can find this field on the bottom of the screen where you configure the pattern.
:::
--------------------------------------------------------------------------------
Section: ### Upgrading-the-provided-OWASP-Core-Rule-Set-of-ModSecurity.md
---
sidebar_position: 80
---

# Upgrading the provided OWASP Core Rule Set of ModSecurity

## Introduction

The **Virtual Host** pattern provides the setting **OWASP ModSecurity CRS version**, where you can either select a pre-configured version of the Core Rule Set, or choose the **custom** option, and provide a customized rule bundle. The preconfigured versions include only slight changes compared to the official Core Rule Set releases.

In case you prefer to customize the Core Rule Set, the following guide describes how to create a rule bundle for the **Virtual Host** pattern, based on the Core Rule Set version 3.3.4 with ModSecurity engine version 3.0.8.

## Step 1: Set up the `modsecurity.conf`

First, create a new directory and download the default [`modsecurity.conf-recommended`](https://raw.githubusercontent.com/SpiderLabs/ModSecurity/v3.0.8/modsecurity.conf-recommended) file. The version of this file should match the version of the ModSecurity engine shipped with nevisProxy. Rename the configuration file to `modsecurity.conf` and apply the following changes:

1. Set the `SecRuleEngine` to `On`, which enables blocking requests.
2. In the file system configuration section, adapt the location where ModSecurity stores temporary files. This way admin4 will generate a proper instance level location for these files. Edit the following lines:
3. Replace `SecTmpDir /tmp/` with `${tmp_dir}`
4. Replace `SecDataDir /tmp/` with `${data_dir}`
5. Replace `SecAuditLog /var/log/modsec_audit.log` with `${audit_log}`
6. Comment out the rule `SecUnicodeMapFile unicode.mapping 20127` as it can fail the startup process if the file is not provided.
7. Finally, at the very end, insert the following line to include the CRS configuration file (which will be created in the second step):

```
Include crs-setup.conf
```
--------------------------------------------------------------------------------
Section: ### Recommended scaling considerations
* Adapt the `SecRequestBodyLimit` and `SecRequestBodyNoFilesLimit` parameters to your environment. For example:

```
SecRequestBodyLimit 104857600
SecRequestBodyNoFilesLimit 10485760
```

* The default value of `SecPcreMatchLimit` and `SecPcreMatchLimitRecursion` parameters may be too low for real world applications. To avoid false positives, they can be increased to the following values:

```
SecPcreMatchLimit 100000
SecPcreMatchLimitRecursion 100000
```

* If there are requests still exceeding the above limits, instead of blocking the request, a warning can be traced by adapting the following rule:

```
SecRule TX:/^MSC_/ "!@streq 0" \
 "id:'200005',phase:2,t:none,deny,msg:'ModSecurity internal error flagged: %{MATCHED_VAR_NAME}'"
```

To:

```
SecRule TX:MSC_PCRE_LIMITS_EXCEEDED "@eq 1" \
 "id:'200005',phase:5,t:none,log,pass,msg:'PCRE match limits were exceeded.'"
```

* Disable the `SecAuditEngine` by setting it to `Off`, as the navajo.log in nevisProxy already traces the necessary information.
* Disable sharing information by setting `SecStatusEngine` to `Off`.

## Step 2: Set up the Core Rule Set

Download the latest stable release of the [Core Rule Set](https://github.com/coreruleset/coreruleset/releases), and extract it. Move the following to the above created directory:

* `crs-setup.conf.example`, and rename it to `crs-setup.conf`
* The whole rules folder with all of its content, except the two exclusion file examples:
  * REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example
  * RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example

Once done, adapt the `crs-setup.conf` to your needs.

We recommend reviewing rule 900200 as the list of allowed HTTP methods is rather restrictive by default.

Finally, to include the rules from the `rules` folder, we need a new file named `rules.conf`, with the following content:

```
Include rules/REQUEST-901-INITIALIZATION.conf
Include rules/REQUEST-903.9001-DRUPAL-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9002-WORDPRESS-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9003-NEXTCLOUD-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9004-DOKUWIKI-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9005-CPANEL-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9006-XENFORO-EXCLUSION-RULES.conf
Include rules/REQUEST-905-COMMON-EXCEPTIONS.conf
Include rules/REQUEST-910-IP-REPUTATION.conf
Include rules/REQUEST-911-METHOD-ENFORCEMENT.conf
Include rules/REQUEST-912-DOS-PROTECTION.conf
Include rules/REQUEST-913-SCANNER-DETECTION.conf
Include rules/REQUEST-920-PROTOCOL-ENFORCEMENT.conf
Include rules/REQUEST-921-PROTOCOL-ATTACK.conf
Include rules/REQUEST-922-MULTIPART-ATTACK.conf
Include rules/REQUEST-930-APPLICATION-ATTACK-LFI.conf
Include rules/REQUEST-931-APPLICATION-ATTACK-RFI.conf
Include rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf
Include rules/REQUEST-933-APPLICATION-ATTACK-PHP.conf
Include rules/REQUEST-934-APPLICATION-ATTACK-NODEJS.conf
Include rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf
Include rules/REQUEST-942-APPLICATION-ATTACK-SQLI.conf
Include rules/REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION.conf
Include rules/REQUEST-944-APPLICATION-ATTACK-JAVA.conf
Include rules/REQUEST-949-BLOCKING-EVALUATION.conf
Include rules/RESPONSE-950-DATA-LEAKAGES.conf
Include rules/RESPONSE-951-DATA-LEAKAGES-SQL.conf
Include rules/RESPONSE-952-DATA-LEAKAGES-JAVA.conf
Include rules/RESPONSE-953-DATA-LEAKAGES-PHP.conf
Include rules/RESPONSE-954-DATA-LEAKAGES-IIS.conf
Include rules/RESPONSE-959-BLOCKING-EVALUATION.conf
Include rules/RESPONSE-980-CORRELATION.conf
```

At the end, the directory should have the following structure:

```
├── crs-setup.conf
├── modsecurity.conf
├── rules
│   ├── crawlers-user-agents.data
│   ├── iis-errors.data
│   ├── java-classes.data
│   ├── java-code-leakages.data
│   ├── java-errors.data
│   ├── lfi-os-files.data
│   ├── php-config-directives.data
│   ├── php-errors.data
│   ├── php-function-names-933150.data
│   ├── php-function-names-933151.data
│   ├── php-variables.data
│   ├── REQUEST-901-INITIALIZATION.conf
│   ├── REQUEST-903.9001-DRUPAL-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9002-WORDPRESS-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9003-NEXTCLOUD-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9004-DOKUWIKI-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9005-CPANEL-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9006-XENFORO-EXCLUSION-RULES.conf
│   ├── REQUEST-905-COMMON-EXCEPTIONS.conf
│   ├── REQUEST-910-IP-REPUTATION.conf
│   ├── REQUEST-911-METHOD-ENFORCEMENT.conf
│   ├── REQUEST-912-DOS-PROTECTION.conf
│   ├── REQUEST-913-SCANNER-DETECTION.conf
│   ├── REQUEST-920-PROTOCOL-ENFORCEMENT.conf
│   ├── REQUEST-921-PROTOCOL-ATTACK.conf
│   ├── REQUEST-922-MULTIPART-ATTACK.conf
│   ├── REQUEST-930-APPLICATION-ATTACK-LFI.conf
│   ├── REQUEST-931-APPLICATION-ATTACK-RFI.conf
│   ├── REQUEST-932-APPLICATION-ATTACK-RCE.conf
│   ├── REQUEST-933-APPLICATION-ATTACK-PHP.conf
│   ├── REQUEST-934-APPLICATION-ATTACK-NODEJS.conf
│   ├── REQUEST-941-APPLICATION-ATTACK-XSS.conf
│   ├── REQUEST-942-APPLICATION-ATTACK-SQLI.conf
│   ├── REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION.conf
│   ├── REQUEST-944-APPLICATION-ATTACK-JAVA.conf
│   ├── REQUEST-949-BLOCKING-EVALUATION.conf
│   ├── RESPONSE-950-DATA-LEAKAGES.conf
│   ├── RESPONSE-951-DATA-LEAKAGES-SQL.conf
│   ├── RESPONSE-952-DATA-LEAKAGES-JAVA.conf
│   ├── RESPONSE-953-DATA-LEAKAGES-PHP.conf
│   ├── RESPONSE-954-DATA-LEAKAGES-IIS.conf
│   ├── RESPONSE-959-BLOCKING-EVALUATION.conf
│   ├── RESPONSE-980-CORRELATION.conf
│   ├── restricted-files.data
│   ├── restricted-upload.data
│   ├── scanners-headers.data
│   ├── scanners-urls.data
│   ├── scanners-user-agents.data
│   ├── scripting-user-agents.data
│   ├── sql-errors.data
│   ├── unix-shell.data
│   └── windows-powershell-commands.data
└── rules.conf
```

Compress the content of the directory into a zip file, for example:

```
zip -r modseccrs.zip ./*
```

and upload the archive to the **Virtual Host** pattern.
--------------------------------------------------------------------------------
Section: ### PEM-Based-Key-Management.md
---
sidebar_position: 130
---

# PEM-Based Key Management

The *PEM Key Store* and *PEM Trust Store* patterns support the upload of key material in PEM format into nevisAdmin 4.

The key material can either be inserted into a text field or uploaded as PEM files. In both cases, you can use variables to store the content in the inventory instead.

The keys are automatically converted into JKS and PKCS12. Up to and including nevisAdmin 4.8, these files are re-generated on each deployment and thus there are always changes.

The key material will be deployed using the same folder structure as the one for the automatic key management.

Pros:

* Complete deployment of a keystore/truststore.
* Use the same content on multiple hosts.

Cons:

* KS and P12 files are created during generation. As these files contain timestamps, they change on each deployment.
* As nevisAdmin 4 is the master of the entire keystore content, the private key will be deployed as well.

Consider using this pattern when you need a simple solution for the complete deployment of a keystore/truststore and do not mind the limitations.

<img className="boxed" src={require('../../assets/pem.gif').default} alt="How to upload trusted certificates in PEM format"/>
--------------------------------------------------------------------------------
Section: ### Automatic-Key-Management.md
---
sidebar_position: 129
---

# Automatic Key Management

nevisAdmin 4 can automatically generate key material for Nevis components. Automatic key management is a convenience feature which allows you to deploy without concern for keystore and truststore content.

If you have complex requirements, consider the following alternatives:

* PEM-Based Key Management
* nevisKeybox-Based Key Management (classic deployment only)

The properties of automatic key management are as follows:

Pros:

* Keys are created on the target host / inside the Kubernetes cluster and never leaves those systems.
* Easier to get started as less configuration is required.
* One shot deployment in case the entire project is deployed.

Cons:

* Does not support using the same key on multiple hosts / for different services.
* Limited configuration options.
* Partial deployment of a project can lead to incomplete truststore content.
* In classic, not all failure cases (for example deleted files or expired CA) can be fixed in one deployment. Multiple deployments may be required.

To enable automatic key management, first set the following global variable in your inventory.

```
vars:
  __nevisadmin_pki_automatic_enabled: true
```

By default, it is not required to add keystore/truststore patterns to your project. The required keystores and truststores will be generated automatically (implicit mode).

As of nevisAdmin version 4.5, you can set the following variables to force users to assign *Automatic Key Store* / *Automatic Trust Store* patterns wherever a keystore/truststore is needed:

```
vars:
  __nevisadmin_pki_automatic_enabled: true
  __nevisadmin_pki_automatic_allowed_mode: explicit
```

## Deployment Scenarios

Automatic key management works differently in classic VM and Kubernetes deployments. This section highlights the differences.
--------------------------------------------------------------------------------
Section: #### Enforcing the Renewal of nevisAdmin 4 CA
As of nevisAdmin 4.6, there is no GUI or REST API to control the CA. The only way to exchange the CA is via the database.

nevisAdmin 4 will automatically create a new CA when no CA is found in the database. Associated certificates will be re-created with the next deployment. You can therefore just delete the CA in the database. Run the following SQL commands on the nevisAdmin 4 host:

```
# stop nevisAdmin 4
[root@nevisadmin4 ~]# nevisadmin4 stopService

# connect to the database as configured in /var/opt/nevisadmin4/conf/nevisadmin4.yml
[root@nevisadmin4 ~]# mysql -u <user> -p<password>

MariaDB [(none)]> use nevisadmin4;

# delete the nevsiAdmin 4 CA
MariaDB [nevisadmin4]> delete from ca;

# delete all the stored certificates to enforce that they are created again
MariaDB [nevisadmin4]> delete from pki_store_content;
MariaDB [nevisadmin4]> commit;
MariaDB [nevisadmin4]> quit

# start nevisAdmin 4
[root@nevisadmin4-dev ~]# nevisadmin4 startService
```

## Explicit Usage

Wherever a keystore / truststore is needed, you can assign the *Automatic Key Store* / *Automatic Trust Store* patterns to make the automatic key management explicit.

Further, explicit assignment is required in some patterns to enforce the use of 2-way TLS:

* Assign an *Automatic Key Store* to use a client certificate for outbound TLS connections.
* Assign an *Automatic Trust Store* to set up a truststore to validate incoming connections.
--------------------------------------------------------------------------------
Section: ### Linking an Automatic Trust Store with Automatic Key Store(s)
In the *Automatic Trust Store* you can assign one or multiple *Automatic Key Store* patterns via *Trusted Key Stores*. Use this method to inform nevisAdmin 4 about a trust relation. nevisAdmin 4 will make sure that any certificate issued for that keystore is automatically trusted. This is often required when using generic patterns, for example *Generic Authentication Realm* or *Generic Authentication Step,* which perform outbound TLS connections, create or validate tokens.

<img className="boxed" src={require('../../assets/1.gif').default} alt="How to link an automatic truststore with an automatic keystore"/>
--------------------------------------------------------------------------------
Section: ### Truststore
A *truststore* may contain:

* CA certificate(s) for trust validation (TLS)
* Certificate(s) used to validate signed tokens

For trust validation during a TLS handshake the truststore must contain the CA (or a parent thereof) which has issued the certificate of the other party.

For signature validation the truststore must contain the signer certificate.

## Patterns for Key Management

Patterns that require a keystore or truststore have dedicated references, which allow you to assign a pattern that provides the keystore / truststore.

The standard pattern library provides the following patterns for key management:

* *Automatic Key Store*/ *Automatic Trust Store:* See the chapter [Automatic Key Management](Automatic-Key-Management.md).
  * These patterns can be used in classic VM and Kubernetes deployments. nevisAdmin 4 automatically sets up the keystore / truststore during deployment. This is the default behavior when no pattern is assigned.
* *nevisKeybox Store:* See the chapter [nevisKeybox-Based Key Management](nevisKeybox-Based-Key-Management.md).
  * The *nevisKeybox Store* pattern can act as keystore or truststore or both. This pattern can be used for classic deployments only. The pattern requires that nevisKeybox is installed and an instance named *default* has been created on the target hosts. nevisAdmin 4 does not deploy into nevisKeybox. You have to manage the content manually using the *neviskeybox* command-line interface.
* *PEM Key Store* / *PEM Trust Store:* See the chapter [PEM-Based Key Management](PEM-Based-Key-Management.md).
  * These patterns can be used in classic and Kubernetes deployments. The key material is uploaded in PEM format in the pattern or via the inventory. Formats for Java-based components (JKS and PKCS12) are generated automatically. The files are deployed by nevisAdmin 4 and will be exposed to Nevis components.
--------------------------------------------------------------------------------
Section: ### Setting-Up-a-SAML-Identity-Provider.md
---
sidebar_position: 96
---

# Setting Up a SAML Identity Provider

## Preconditions

* You need a *Realm* pattern that defines the process for initial authentication. See Configuring LDAP Login for Web Application for an example configuration.

* To use the IDP, you have to integrate at least one SP. You need the following information about the SP:
  * The signer certificate
  * The SP issuer
  * The Assertion Consumer Service URL (used for IDP-initiated authentication only)
--------------------------------------------------------------------------------
Section: #### Realm Patterns
You can add a new *Realm* pattern, or reuse an existing *Realm* pattern. The *SAML IDP* pattern just exposes the realm as an authentication service via nevisProxy.

If you add a new pattern, you can pick any kind of *Realm* pattern.  The *Authentication Realm* is usually the most convenient choice because it offers many standardized configuration options.


## Quick Start

Perform the next steps to set up a SAML IDP.

1. Configure the *SAML IDP* pattern as follows:
   1. Enter a value for the SAML issuer in the *SAML Issuer* field.
      1. The SP needs this information to validate SAML responses.
      2. Some SPs require the issuer to be a URL that points to the IDP.
   2. Enter at least one frontend path in the *Frontend Paths* field, or use the default.
   3. Assign a *SAML SP Connector* pattern to the *SAML SP Connector(s)* field.
   4. Configure the SAML signer in the *SAML Signer* field, by assigning an (*Automatic) Key Store* pattern.
   5. Assign a *Virtual Host* pattern to the *Virtual Host* field. The assigned *Virtual Host* pattern defines where to make the frontend path accessible.
   6. In the *Authentication Realm* field, specify an *Authentication Realm* pattern that provides the authentication flow.
2. Configure the *SAML SP Connector* pattern as follows:
   1. Enter the SP issuer in the *SP Issuer* field.
   2. Establish SP signer trust by assigning a truststore provider pattern, such as an *Automatic Trust Store* pattern, to the *SP Signer Trust* field.

:::note Step 2
Describes how to configure the *SAML SP Connector* pattern. You can also have a look at the pattern on the right in the next figure.
:::
--------------------------------------------------------------------------------
Section: ### Automatic Key Management
For test setups and in case the SP is defined in the same nevisAdmin 4 project, you can use automatic key management. Proceed as follows:

* Assign an *Automatic Trust Store* pattern to the *SP Signer Trust* field of the *SAML SP Connector* pattern.
* Link the *Automatic Trust Store* pattern with the automatic keystore used by the SP, by assigning the relevant *Automatic Key Store* pattern to the *Trusted Key Stores* field of the *Automatic Trust Store* pattern.

For production setups, either use the *nevisKeybox Store* pattern, or the *PEM Trust Store / PEM Key Store* provider patterns.
--------------------------------------------------------------------------------
Section: ### Use-SAML-Authentication-for-a-Web-Application.md
---
sidebar_position: 97
---

# Configuring SAML Authentication for a Web Application

## Preconditions

* Make sure your application is accessible via nevisProxy as explained in [Protecting a Web Application](../../../Application-Protection/Protecting-a-Web-Application/Protecting-a-Web-Application).
* Make sure you have the following information about your IDP at hand:
  * The Issuer (also known as Entity ID) that uniquely identifies the IDP.
  * The certificate used by the IDP to sign SAML messages.
  * The Single-Sign-On URL.
--------------------------------------------------------------------------------
Section: ### Supported IDPs
You can integrate a third-party SAML Identity Provider (IDP) or set up your own as described in Setting Up a SAML Identity Provider.

## Quick Start

Authentication via SAML (Web Browser SSO) requires:

* The configuration of a SAML Service Provider (SP).
* The integration of the SP with the IDP.

Perform the next steps:

1. In the relevant *Web Application* pattern:
   1. Attach a *SAML SP Realm* pattern to the *Authentication Realm* field.
2. To configure the *SAML SP Realm* pattern:
   1. Go to the *nevisAuth Connection* tab and attach a *nevisAuth Instance* pattern to the *nevisAuth* field.
   2. Open the *Basic Settings* tab and make the following configurations:
      1. Enter an arbitrary value for the SAML issuer in the *SAML Issuer* field. Inform your IDP about the value you have chosen.
      2. Assign a *Key Store* pattern to the *SAML Signer* (field). By specifying the keystore, you define which key material to use for signing the outgoing SAML messages.
      3. Assign a *SAML IDP Connector* pattern to the *SAML IDP Connector(s)* field. See the next step for more information on how to configure the *SAML IDP Connector* pattern.
3. To configure the *SAML IDP Connector* pattern:
   1. Enter the IDP Issuer in the *IDP Issuer* field. To find out the correct value of the IDP Issuer, either check the metadata of the IDP, or base64-decode a received SAML Response.
   2. Enter the URL of the IDP in the *IDP URL* field. The SP may invoke the authentication process by sending an *AuthnRequest* SAML message to this URL.
   3. Assign a relevant truststore pattern to the *IDP Signer Trust* field. Depending on the type of truststore pattern, you have to do additional configuration.
--------------------------------------------------------------------------------
Section: ### Automatic Key Management
For testing purposes and if the IDP is configured in the same nevisAdmin 4 project, you can use automatic key management. Proceed as follows:

* *SAML SP Realm* pattern: Assign an *Automatic Key Store* pattern to the *SAML Signer* field.
* *SAML IDP Connector* pattern: Assign an*Automatic Trust Store* pattern to the *IDP Signer Trust* field.
* *Automatic Trust Store* pattern: Enter the *Automatic Key Store* pattern used by the IDP in the *Trusted Key Stores* field.

For production setups, either use the *nevisKeybox Store* pattern, or the *PEM Trust Store / PEM Key Store* provider patterns.

The following figure shows a sample configuration for all patterns involved:

<img className="boxed" src={require('../../../../assets/50823290.png').default} alt="Use SAML for a Web application - patterns with settings"/>

## Session Upgrade

For SP-initiated authentication, the SP sends a SAML *AuthnRequest* to the IDP. This *AuthnRequest* contains the following element:

```
<samlp:RequestedAuthnContext>
 <saml:AuthnContextClassRef>urn:nevis:level:1</saml:AuthnContextClassRef>
</samlp:RequestedAuthnContext>
```

This *RequestedAuthnContext* element defines the minimum required authentication level. If you want to demand a higher authentication level, you can assign an Authorization Policy to your application. When the session is not at this level yet, the SP will send an additional *AuthnRequest* to the IDP.
--------------------------------------------------------------------------------
Section: ### Supported-SAML-Flows.md
---
sidebar_position: 98
---

# Supported SAML Flows

## Overview

You can configure the following SAML flows:

* SAML Flows for Authentication
* SAML Flow for Session Upgrade
* SAML Flows for Logout

Configuring flows other than the ones above is not supported.

For information on how to configure the corresponding patterns, see:

* Setting Up a SAML Identity Provider (IDP)
* Configuring SAML Authentication for a Web Application (SP)

The patterns generate a configuration for nevisAuth, in particular for AuthState elements. This means that the nevisAuth documentation for these AuthStates applies as well. In some cases, you may not be able to configure certain AuthState properties via the patterns. If you run into such issues, raise a support ticket and explain your use case.

## Sample Setup

To describe the supported SAML flows, we use the following sample setup with two domains:

* `http://www.siven.ch`
  * Hosts a web application that requires authentication.
  * Authentication is enforced by a SAML Service Provider (SP).
* `http://sso.siven.com/`
  * Provides Single-Sign-On (SSO) for applications.
  * Hosts the SAML Identity Provider (IDP).

Nevis acts both as SP and as IDP.  But you can also use Nevis just for one party. For example, if the web application supports SAML out-of-the-box, the use of Nevis for the SP may not be required. However, Nevis can provide added value:

* **Perimeter authentication**
  * Authentication (and authorization) can be enforced by nevisProxy before the request reaches the application.
* **Support for multiple IDPs**
  * The IDP may be determined automatically based on complex custom criteria (for example, the source IP of the user or the current URL).
  * Support for IDP selection by the user is not available yet. Contact Nevis if you are interested in this feature.
--------------------------------------------------------------------------------
Section: ### SAML-Flows-for-Logout.md
---
sidebar_position: 91
---

# SAML Flows for Logout

This chapter describes the supported flows for SAML logout based on our sample setup. The SAML logout flows are best-effort; successful execution cannot be guaranteed.

Be aware of the following limitations:

1. SAML SPs must use the same endpoints for their *assertionConsumerService* and their *singleLogoutService*.
   1. This is the case if the SP is provided by Nevis, but can be problematic when integrating a third-party SP.
   2. Contact support if you want to integrate an SP that requires the use of different URLs for these two endpoints.
2. There is no feedback to the user if the session was successfully terminated for all affected parties.
   1. This can be improved by adapting the Javascript that is included in the default nevisLogRend template (see *macros.vm*).
3. The internal *nevisProxy Login Renderer* pattern cannot be used as it is not able to inject the Javascript required to distribute SAML messages.
   1. Use the *nevisLogrend* pattern instead if you want to support SAML logout flows.

## IDP-Initiated SAML Logout

<img className="boxed" src={require('../../../../assets/53124465.png').default} alt="IDP-initiated SAML logout flow"/>

IDP-initiated SAML logout works as follows (the numbers of the steps below correspond with the numbers in the figure above):

1. Logout is initiated by sending any HTTP request to a logout location of the SAML IDP. The SAML IDP provides two such locations:
   1. `<path>/logout` - logout with confirmation
   2. `<path>/?logout` - logout without confirmation
   3. Here `<path>` stands for any *Frontend Path* entered in the *SAML IDP* pattern.
2. The SAML IDP responds as follows:
   1. The *IdentityProviderState* produces an *AUTH_CONTINUE* response that contains a GUI descriptor.
   2. nevisLogRend transforms the GUI descriptor into an HTML page.
   3. nevisLogRend adds some Javascript (see *macros.vm*), which takes care of the remainder of this flow.
3. The browser sends a *LogoutRequest* message to each SP that has participated in this session.
   1. The requests are sent in parallel using AJAX calls.
   2. The *LogoutRequest* is included as a query parameter *SAMLRequest*.
   3. The SP terminates the session of the user.
   4. The SP clears any additional cookies used to detect expired sessions. See the *Session Expiration* features in the *SAML SP Realm* pattern.
   5. The SP returns a *LogoutResponse.* The default Javascript simply ignores these messages.
4. Once all SPs have been informed, the user is sent to a logout URL.
   1. The default logout URL is the root location ( */* ) of the virtual host that runs the SAML IDP.
   2. You can use the *Logout* pattern to change the logout URL.

## SP-Initiated SAML Logout

<img className="boxed" src={require('../../../../assets/53124468.png').default} alt="SP-initiated SAML logout"/>

SP-initiated SAML logout works as follows (the numbers of the steps below correspond with the numbers in the figure above):

1. Logout is initiated by sending a request to an application URL with the query parameter *logout*.
   1. Example: `https://www.siven.ch/myapp/?logout`
   2. The request is intercepted by nevisProxy and does not reach the application.
   3. The IDP is determined and the corresponding *ServiceProviderState* returns a *LogoutRequest.*
2. The browser is instructed to send a *LogoutRequest* to the SAML IDP.
   1. This request is typically sent using a POST request.
   2. The request is validated by the SAML IDP (*IdentityProviderState*).
3. The SAML IDP answers as follows:
   1. The *IdentityProviderState* produces an *AUTH_CONTINUE* response which contains a GUI descriptor.
   2. nevisLogRend transforms the GUI descriptor into an HTML page.
   3. nevisLogRend adds some Javascript (see *macros.vm*), which takes care of the remaining flow.
4. The browser sends a *LogoutRequest* message to each additional SP that has participated in this session.
   1. The requests are sent in parallel via AJAX calls.
   2. The *LogoutRequest* is added as a query parameter *SAMLRequest*.
   3. The SP terminates the session of the user.
   4. The SP clears any additional cookies used to detect expired sessions.
   5. The SP returns a *LogoutResponse.* The default Javascript just ignores these responses.
5. The session is terminated at the IDP by sending an additional request with *?logout* attached.
   1. This request is also sent in the background using an AJAX call.
   2. This is required to ensure that the session at the IDP is terminated.
6. The user is sent to the SP that has initiated the SAML logout.
   1. The URL contains a *LogoutResponse* message to signal a successful logout.
7. The SAML SP redirects the user to its logout target.
   1. By default the *RelayState* (URL of the application) is used and thus a new SAML authentication will be initiated.
   2. You can set a different *Logout Target* in the *SAML SP Realm* pattern.
--------------------------------------------------------------------------------
Section: ### Extended-Flow-for-Third-Party-Initiated-Authentication.md
---
sidebar_position: 91
---

# Extended Flow for Third-Party Initiated Authentication

The easiest way to integrate a third-party SAML Identity Provider (IDP) is to add a *SAML IDP Connector* pattern to your *SAML SP Realm* pattern*.*This approach is called *direct integration.*

Direct integration is not appropriate in the following cases:

* If you also have an own IDP. In this case, you may have to configure multiple *SAML IDP Connector* patterns and have to come up with a *Selection Expression* for each of them.
  * The expression can become complex, and you have to ensure that always exactly one expression evaluates to "True".
  * In some cases this can even be impossible as the IDP selection may depend on unknown criteria.
* If you have multiple *SAML SP Realm* patterns. In this case, maintaining the trust relationships for all IDPs can be cumbersome.

To overcome these issues, nevisAdmin 4 provides an experimental pattern called *SAML Response Consumer*.

The pattern itself is simple but the complete SAML flow is special and requires some explanation:
Let's assume that we already have a basic SAML setup that includes a Nevis SP and a Nevis IDP.
This basic setup is described in chapter SAML Flows for Authentication.
However, instead of integrating the third-party IDP in our SP, we want it to be associated with our Nevis IDP.
To achieve this, we configure a *SAML Response Consumer* pattern and select the same *Virtual Host* and *Authentication Realm* as in the *SAML IDP* pattern.

The following figure shows the resulting SAML flow:

<img className="boxed" src={require('../../../../../assets/53123699.png').default} alt="Third-party initiated authentication - SAML flow"/>

The SAML flow contains the following steps (the numbers of the steps correspond with the numbers in the figure above):

1. The user wants to access a web application.
   1. The web application is hosted on `www.siven.ch`.
   2. To access the application, the user requests a URL at the third-party IDP. This triggers an IDP-initiated authentication.
2. The third-party IDP authenticates the user and returns a SAML Response.
   1. The only known fact about this SAML Response is that the included assertion contains information about the user.
   2. The third-party IDP must also return a *RelayState* parameter, which contains the URL of the desired application.
   3. The browser is instructed to send both the SAML Response and the *RelayState* parameter to the SAML Response Consumer.
3. The SAML Response Consumer consumes the SAML Response and ensures that the user is authenticated.
   1. The Issuer is extracted to dispatch into a corresponding *ServiceProviderState*.
   2. The *ServiceProviderState* validates the signature of the received SAML message.
   3. An Authentication Processing flow is executed. This flow can be complex as the exact steps depend on what we know about the user and the information we have received.
4. The SAML Response Consumer now declares the authentication to be completed.
   1. The browser is redirected to the URL taken from the *RelayState* parameter. The remainder of the authentication flow is similar to an SP-initiated authentication. Check [SAML Flows for Authentication] for a more detailed description.
5. There is no authenticated session on `www.siven.ch`. Therefore, access to the application is denied.
   1. The request is handed over to the SAML SP, which triggers SP-initiated authentication.
6. The SAML SP forces the browser to send an *AuthnRequest* to our SAML IDP.
7. The SAML IDP consumes the *AuthnRequest*.
   1. As the SAML IDP and the SAML Response Consumer are associated with the same Authentication Realm there already is a session.
   2. As the session is authenticated already, the IDP immediately returns a SAML Response without any user interaction.
8. The browser is instructed to send the *AuthnRequest* to the SP.
9. The SP consumes the SAML Response, authenticates the session and redirects it to the application.
10. Now there is an authenticated session and the user is allowed to access the application.
--------------------------------------------------------------------------------
Section: ### SAML-Flows-for-Authentication.md
---
sidebar_position: 99
---

# SAML Flows for Authentication

This chapter describes the supported flows for SAML authentication based on the sample setup described in the Supported SAML Flows section.

## SP-Initiated Authentication

<img className="boxed" src={require('../../../../../assets/53123666.png').default} alt="SP-initiated SAML flow for authentication"/>

SP-initiated SAML authentication works as follows (the numbers of the steps below correspond with the numbers in the figure above):

1. The user wants to access the web application `www.siven.ch`:
   * The web application is behind a nevisProxy virtual host and protected by a SAML SP Realm*.*
   * The user uses a browser-based client.
2. As there is no authenticated session, access to the application is blocked.
   * Session tracking is based on a session cookie.
   * Authentication is enforced by nevisProxy.
   * The request is forwarded to nevisAuth, which acts as SP and initiates the SAML flow.
3. The SP checks if the session has been expired.
   * This check is optional and can be enabled in the *SAML SP Realm* pattern (*Session Expiration* tab*).*
   * The *SAML SP Realm* pattern provides different strategies on how to handle expired sessions. Each strategy corresponds with a field in the *Session Expiration* tab:
      * *Logout Reminder*: Renders a page that reminds the user to log out in the future.
      * *Timeout Page*: Renders a page that informs about the termination of the session due to timeout.
      * *Session Expiration Redirect*: Redirects to a configurable URL (for example, a hosted resource or the URL of the IDP to trigger IDP-initiated authentication).
4. The SP can also execute an optional custom pre-processing step.
   * You configure this step in the *Custom Pre-Processing* field of the *SAML SP Realm* pattern (*Advanced Settings* tab). Check the pattern's *Help* section for further information about this advanced feature.
5. The SP now determines which SAML IDP to invoke.
   * This step is not relevant when only one IDP is configured.
   * The IDP is selected based on a selection expression. You configure this expression in the *SAML IDP Connector* pattern (*Selection Expression* field, *Advanced Settings* tab). Check the pattern's *Help* section for examples.
6. The SP returns an *AuthnRequest*.
   * The *AuthnRequest* contains the Issuer of the SP and is signed with the SAML Signer of the SP.
   * The SP stores the current URL (of the application) in a *RelayState* parameter.
      * The SAML standard demands that the IDP returns this *RelayState* parameter unchanged.
   * The browser is instructed to send *AuthnRequest* and *RelayState* to the IDP. How these parameters are transmitted can be configured in the *SAML IDP Connector* pattern (*Binding: Outbound* field, *Basic Settings* tab):
      * POST-binding ("http-post"): Self-submitting form. This is the default setting.
      * Redirect-binding ("http-redirect"): Using query parameters and a 302 redirect.
7. The IDP consumes the *AuthnRequest*.
   * The IDP first extracts the Issuer from the *AuthnRequest* and dispatches the request into the correct *IdentityProviderState*.
      * Each *SAML SP Connector* pattern generates one *IdentityProviderState*.
   * The *IdentityProviderState* validates the signature of the *AuthnRequest*.
      * If the signature is not valid, then a standard SAML error response is returned.
8. If the user has no authenticated session on the IDP he has to log in first.
   * The authentication flow is defined by the *Authentication Realm* pattern assigned to the *SAML IDP* pattern.
9. Once the session is authenticated, the SAML IDP produces a SAML Response.

   * The Response is sent to the *AssertionConsumerServiceURL* that has been extracted from the *AuthnRequest*.
   * If no *AssertionConsumerServiceURL* is found, then the URL defined in the *SAML SP Connector* pattern is used.
10. The SP consumes the Response:

* Based on the Issuer of the Response the corresponding *ServiceProviderState* for this IDP is selected.
  * Each *SAML IDP Connector* pattern generates one *ServiceProviderState*.
* The *ServiceProviderState* validates the signature of the Response.
* If the Response contains an *AudienceRestriction* then it has to match the current URL.

11. The SP can execute an optional post-processing flow.

* You configure this flow in the *Post-Processing Flow* field of the *SAML SP Realm* pattern (*Advanced Settings* tab). Check the pattern's *Help* section for further information about this advanced feature.

12. The SP declares the authentication as done and redirects back to the web application.

* The URL of the application is taken from the *RelayState* parameter.

13. As there now is an authenticated session, nevisProxy allows the user to access the application.

* If an Application Access Token is assigned to the web application, the SAML SP is invoked again to produce that token.
* If an Authorization Policy is assigned that demands a higher authentication level, a session upgrade may be performed. See the chapter SAML Flow for Session Upgrade for details.

## IDP-Initiated Authentication

<img className="boxed" src={require('../../../../../assets/53123687.png').default} alt="IDP-initiated SAML flow for authentication"/>

IDP-initiated SAML authentication works as follows:

1. A user requests a URL that points to the IDP.
   1. The request may be sent to any of the frontend paths configured in the *Frontend Paths* field/property of the *SAML IDP* pattern (*Basic Settings* tab).
   2. Some parameters must be included (as POST or query parameters):
      1. Issuer: As used by the SP and configured in a *SAML SP Connector* pattern*.*
      2. *RelayState*: will be returned to the SP together with the SAML Response.
   3. The IDP uses the Issuer to determine the correct *IdentityProviderState* for this SP.
2. In case the user has no authenticated session he has to log in first.
   1. The authentication flow is defined by the *Authentication Realm* pattern assigned to the *SAML IDP* pattern.
3. Once the user has been authenticated, the SAML IDP returns a SAML Response.
   1. The *SAML SP Connector* pattern defines how the Response is returned:
      1. You can choose between POST-binding and redirect-binding.
      2. As there is no incoming *AuthnRequest,* configure the SP URL.
   2. The browser is instructed to send the Response and the *RelayState* parameter to the SP URL.
4. The SP consumes the Response:
   1. Based on the Issuer of the Response the corresponding *ServiceProviderState* for this IDP is selected.
   2. The *ServiceProviderState* validates the signature (either the Response or the contained Assertion may be signed).
   3. If the Response contains an *AudienceRestriction* then it has to match the URL of the SP.
5. The SP may execute an optional *Post-Processing Flow*.
   1. You configure this optional flow in the *Post-Processing Flow* field of the *SAML SP Realm* pattern (*Advanced Settings* tab). Check the pattern's *Help* section for further information about this advanced feature.
6. The SP declares the authentication done and redirects back to the web application.
   1. The URL of the web application is taken from the *RelayState* parameter.
7. As there now is an authenticated session, nevisProxy allows the user to access the application.
   1. If an Application Access Token is assigned to the web application, the SAML SP is invoked again to produce that token.
   2. If an Authorization Policy is assigned that demands a higher Authentication Level, a session upgrade may be performed. See the chapter SAML Flow for Session Upgrade for further information.

Be aware of the following warning/recommendation:

IDP-initiated authentication is harder to initiate (as it requires additional parameters to be sent) and potentially less secure (as the initial AuthnRequest from the SP is skipped). Thus, we recommend using SP-initiated authentication whenever possible.
--------------------------------------------------------------------------------
Section: ### Setting-up-an-OAuth-2.0-Authorization-Server.md
---
sidebar_position: 93
---

# Setting up an OAuth 2.0 Authorization Server

This chapter explains how to set up an OAuth 2.0 Authorization Server. There is no dedicated pattern for this case, but you can use standard nevisAuth patterns. Here, we use the following patterns:

* *Generic Authentication Step:* This pattern configures an *AuthorizationServer* AuthState. Check the nevisAuth documentation for further information.
* *Standalone Authentication Flow:* This pattern exposes the *Generic Authentication Step* pattern on a nevisProxy virtual host.

## Preconditions

* nevisMeta is set up. For more information, see the chapter [Setting up a nevisMeta Instance](Setting-up-a-nevisMeta-Instance.md).
* The nevisAuth host is able to reach the nevisMeta API.
* OAuth 2.0 setup is defined.
  * The OAuth 2.0 setup is defined with the nevisMeta Web Console pattern.
  * The ID of the setup is available, to configure the AuthorizationServer AuthState.
* An *Authentication Realm* pattern is available, to host the Authorization Server.
  * As part of the Authentication Realm pattern's settings, an initial authentication flow is specified in the Initial Authentication Flow field/property. The initial authentication flow is invoked when the user is not yet authenticated. The initial authentication flow is also used later on, when you configure the Generic Authentication Step pattern.

## Quick Start

This quick start shows how to set up an OAuth 2.0 Authorization Server. This quick start is kept as simple as possible for illustration purposes.

Be aware of the following potential issues:

* The user will not be asked for confirmation if no *ConsentState* AuthState is configured.
  * Check the nevisAuth technical documentation for details.
* You may have to configure key management, because:
  * The *AuthorizationServer* AuthState uses signer key material.
  * nevisAuth must be able to call nevisMeta. For this, set the *Nevis SecToken Trust* property of the *nevisMeta Instance* pattern.
* As input for the *AuthState(s): Parameters* field in *Generic Authentication Step* pattern, you may want to use a variable and define the values in the inventory. See the pattern's *Help* tab for details.
--------------------------------------------------------------------------------
Section: #### Perform the following steps
1. Add a *Generic Authentication Step* pattern. Configure the pattern as follows:
   1. Configure the *AuthorizationServer* AuthState in the *AuthState(s): direct input* field. Use the configuration from the code block below.
   2. Use the *AuthState(s): Parameters* field to externalize an environment-specific configuration, such as:
      * the host name of nevisMeta, or  
      * the ID of the OAuth 2.0 setup in nevisMeta.
   3. The *Additional Follow-up Steps* field defines the first step of the initial authentication flow. This step is executed if the user is not authenticated yet.  
      * Use the same authentication flow as the one in the *Initial Authentication Flow* field of the relevant *Authentication Realm* pattern. You have configured this pattern as a precondition, see the section Preconditions above.
2. Add a *Standalone Authentication Flow* pattern. Configure the pattern as follows:
    1. Assign a nevisProxy virtual host to the *Virtual Host* field.
    2. Enter a frontend path in the *Frontend Path* field.
    3. Assign the previously configured authentication realm to the *Authentication Realm* field (see also the section Preconditions).
    4. Assign the *Generic Authentication Step* pattern that you created in step 1 to the *Authentication Flow* field.

```script title="AuthState(s): direct input"
<AuthState name="${state.entry}" class="ch.nevis.esauth.auth.states.oauth2.AuthorizationServer" final="false">
 <ResultCond name="authenticate:valid-authorization-request" next="${state.exit.1}"/> <!-- execute the first assigned Additional Follow-Up Step -->
 <ResultCond name="invalid-authorization-request" next="${state.failed}"/>
 <ResultCond name="invalid-client" next="${state.failed}"/>
 <ResultCond name="invalid-redirect-uri" next="${state.failed}"/>
 <ResultCond name="invalid-token-request" next="${state.failed}"/>
 <ResultCond name="server-error" next="${state.failed}"/>
 <ResultCond name="stepup:valid-authorization-request" next="${state.done}"/>
 <property name="keyobjectref" value="DefaultSigner"/>
 <property name="keystoreref" value="DefaultKeyStore"/>
 <property name="dataSource" value="nevismeta"/>
 <property name="nevismeta.location" value="https://${param.meta}:8996/nevismeta/rest/modules/oauthv2/setups/Setup_${param.setup_id}/entities"/>
</AuthState>
```

The following figure shows the required patterns in an example configuration:

<img className="boxed" src={require('../../../assets/53125206.png').default} alt=""/>

<img className="boxed" src={require('../../../assets/53125208.png').default} alt=""/>

<img className="boxed" src={require('../../../assets/53125207.png').default} alt="Setting up an OAuth 2.0 Authorization Server - Patterns with entries"/>
--------------------------------------------------------------------------------
Section: #### Realm Patterns
nevisAdmin 4 provides several *Realm* patterns. You can use any *Realm* pattern for this purpose. The *Authentication Realm* is the most high-level and convenient pattern.

## Quick Start

Perform the following steps to set up a nevisMeta instance:

1. Add a *nevisMeta Instance* pattern. Configure the pattern as follows:

   1. Enter a deployment target in the *Deployment Target* field.
      1. Use a group, host, or service that exists in your inventory.
      2. The target hosts must have nevisMeta installed (version >= 1.5.1.6).
   2. Add a *nevisMeta Database Connector* pattern in the *Database Connector* field.
2. Configure the *nevisMeta Database Connector* pattern as follows:
   1. Enter a relevant URL in the *Connection URL* field. For example: "jdbc:mariadb://nevisdb:3306/nevismeta".
   2. Enter the name of the DB schema owner in the *Username* field. For example: "umet01".
   3. Connect a variable to the *Password* field.
      1. Set the value for this variable in your inventory.
3. Add a *nevisMeta Web Console* pattern. Configure the pattern as follows:
   1. Assign the previously configured *nevisMeta Instance* pattern to the *nevisMeta* field.
   2. Assign a *Virtual Host* pattern to the *Virtual Host* field. The nevisMeta Web Console is accessible on this virtual host via the path */nevismeta/*.
   3. Assign an *Authentication Realm* pattern to the *Authentication Realm* field.
   4. Assign a *Nevis SecToken* pattern to the *Application Access Token* field.
      1. The pattern verifies that this *Nevis SecToken* pattern is also assigned to the Realm pattern that you configured as a precondition (see the section: Preconditions above).

The following figure shows the nevisMeta patterns in an example configuration:

<img className="boxed" src={require('../../../assets/53125195.png').default} alt=""/>

<img className="boxed" src={require('../../../assets/53125196.png').default} alt=""/>

<img className="boxed" src={require('../../../assets/53125197.png').default} alt="Setting up a nevisMeta instance - Patterns with entries"/>

This example uses automatic key management.

For production setups, use the *PEM-* or *nevisKeybox Store* patterns instead.
--------------------------------------------------------------------------------
Section: ### User-Behavior-Analytics-Troubleshooting.md
---
sidebar_position: 117
---

# User Behavior Analytics Troubleshooting

You can check the status of the components in the nevisDetect web application, for more information see the Operator section in the nevisDetect User guide.

The detailed description of the monitoring messages can be found under the Monitoring chapter in the nevisDetect Reference guide.

## Logfiles

You can find the log files on the path below. You can also override the log files in the configuration: `/var/opt/nevisdetect/<component>/logs/nevisdetect-<component>.log`.

| Component | Log file |
| --- | --- |
| Persistency | `/var/opt/nevisdetect/persistency/logs/nevisdetect-persistency.log` |
| Admin | `/var/opt/nevisdetect/admin/logs/nevisdetect-admin.log` |
| Core | `/var/opt/nevisdetect/core/logs/nevisdetect-core.log` |
| Entrypoint | `/var/opt/nevisdetect/entrypoint/logs/nevisdetect-entrypoint.log` |

For troubleshooting, use the log entries created by the *OpTracer.* This helps you to find the service calls in the log. For example:

```
 2018-01-16_22:13:23.158 [https-jsse-nio-10.0.205.195-8181-exec-4] DEBUG c.n.nevisDetect.util.logging.OpTracer - ==>'GET https://nevisdetect-dev.nevis-security.com:8181/nevisdetect/persistency/runtimeconfiguration/getRuntimeConfiguration?waitTime=30000' remoteAddr='10.0.205.195' user='DETECT_CORE'

 2018-01-16_22:13:53.183 [https-jsse-nio-10.0.205.195-8181-exec-4] INFO c.n.nevisDetect.util.logging.OpTracer - <== 'GET https://nevisdetect-dev.nevis-security.com:8181/nevisdetect/persistency/runtimeconfiguration/getRuntimeConfiguration?waitTime=30000' remoteAddr='10.0.205.195' user='DETECT_CORE' in 30025 [msec]
```
--------------------------------------------------------------------------------
Section: #### nevisDetect Administration GUI
The administration of the service is conducted via a web application so add a *nevisDetect Administration GUI* pattern. The following properties are mandatory to set:

* *nevisDetect Admin*: set a reference to the *nevisDetect Admin Instance* pattern created above.
* *Virtual Host*: set a reference to the *Virtual Host* pattern created during the base setup.
* *Authentication Realm*: set a reference to the *Authentication Realm* pattern of the nevisIDM configuration.
* *Application Access Token*: set a reference to the *Nevis SecToken* pattern of the nevisIDM configuration.

<img className="boxed" src={require('../../assets/adminGUI.gif').default} alt="How to create a nevisDetect Administration GUI"/>
--------------------------------------------------------------------------------
Section: #### nevisDetect Persistency REST API
We use the Persistency REST services from the administration UI. To make it available, add a *nevisDetect Persistency REST API* pattern.

* nevisDetect Persistency: add a reference to the *nevisDetect Persistency Instance* pattern configured above.
* Virtual Host: set the same *Virtual Host* as for nevisDetect Admin Web Application Access.
* Authentication Realm: set the same *Authentication Realm* as for nevisDetect Admin Web Application Access.
* Application Access Token: set the same *Nevis SecToken* as for nevisDetect Admin Web Application Access.

<img className="boxed" src={require('../../assets/persistencyREST.gif').default} alt="How to create a nevisDetect Persistency REST API"/>
--------------------------------------------------------------------------------
Section: #### Risk Plugins
There are currently 3 different options available, at least one should be picked based on the use case and added under *Risk Plugins*. They are described in detail in the User Behavior Analytics Use Cases section.

## Integration with other Nevis components to protect web applications
--------------------------------------------------------------------------------
Section: #### nevisDetect Feature Correlator Instance
The nevisDetect Feature Correlator receives the HTTP request from nevisProxy and correlates and passes it on to the message bus.

* Deployment Target: it is advised to set the same target host as for *nevisProxy Instance.*
* nevisDetect Persistency Instance: add the reference for the instance configured above.
* nevisDetect Message Queue Instance: add the reference for the instance configured above.

To protect your web application, add this pattern to the Additional Settings in the Web application pattern on the Advanced Settings tab or for the Virtual host, otherwise it will have no effect.

<img className="boxed" src={require('../../assets/featureCorrelator.gif').default} alt="How to create a nevisDetect Feature Correlator Instance"/>
--------------------------------------------------------------------------------
Section: #### Further resources
If you want to set up User Behavior Analytics from scratch, also see the following resources:

* [Main Concepts](../../../nevisadmin4/introduction) of nevisAdmin 4.
* [First Steps](../quickstart-appliance), which explains how to configure a web application protected by nevisProxy.
* Alternatively, the following Nevis yoU books are also available (requires registration):
  * nevisAdmin 4 in a Nutshell, which provides an easy-to-read overview of Nevis administration and the concepts used.
  * Working with nevisAdmin 4, explaining how to configure a web application protected by nevisProxy in more detail.

## Basic Steps

If you are starting with an empty project, have a look at the [Base Setup](../Mobile-Authentication/Base-Setup) for Nevis Mobile Authentication which covers the same steps with more details (note that you can skip the nevisFIDO setup).
--------------------------------------------------------------------------------
Section: ### Virtual Host, nevisProxy, nevisAuth, nevisIDM
Nevis User Behavior Analytics relies on a *Virtual Host* where the services are exposed. It also needs a *nevisAuth Instance* where its authentication flows are configured. Note that a *nevisLogRend Instance* is created automatically if you did not create one beforehand.
--------------------------------------------------------------------------------
Section: ### nevisIDM and nevisIDM Web Application
Nevis User Behavior Analytics uses nevisIDM as its user and credential database. To be able to access the nevisIDM UI, we configure a *nevisIDM Web Application* as well. It is possible to use another user database for example LDAP, however in this guide we only show its configuration with nevisIDM. In the future, some use cases might only be available for nevisIDM, so we would recommend to use that if it is possible.
--------------------------------------------------------------------------------
Section: ### Web Application to protect
If it has not been added yet, the protected Web Application should also be configured. For more details visit: Adding a Web Application.
--------------------------------------------------------------------------------
Section: ### User-Behavior-Analytics-Use-Cases.md
---
sidebar_position: 120
---

# User Behavior Analytics Use Cases

The configuration of User Behavior Analytics Use Cases can be divided into two categories.

The first category is the integration of different detection technologies that can be used for fraud detection. Check the following chapters for details:

* [Adaptive and Continuous Authentication](../User-Behavior-Analytics-Use-Cases/Adaptive-and-Continuous-Authentication/Adaptive)
* [Custom Risk Score Provider Integration](../User-Behavior-Analytics-Use-Cases/Custom-Risk-Score-Provider-Integration)
* [User Behavior Analysis](../User-Behavior-Analytics-Use-Cases/User-Behavior-Analysis)

The second category is related to the operation and configuration of risk score normalization and policies. The configuration for those use cases is available in the nevisDetect Administration Web Application. For more details, see the nevisDetect User Guide:

* [Policy handling](../../../../nevisdetect/nevisDetect-User-Guide/Use-Cases-and-Personas/Security-expert/Policy-handling)
* [Normalized risk score calculation](../../../../nevisdetect/nevisDetect-User-Guide/Use-Cases-and-Personas/Security-expert/Normalized-risk-score-calculation)
* [Application management](../../../../nevisdetect/nevisDetect-User-Guide/Use-Cases-and-Personas/Security-expert/Application-management)
--------------------------------------------------------------------------------
Section: ### Base-Setup.md
---
sidebar_position: 1
---

# Base Setup

Nevis Mobile Authentication relies on the following Nevis components: nevisProxy, nevisAuth, nevisLogRend, nevisIDM and nevisFIDO.

The amount of base setup you have to do depends on your existing configuration (if any):

* If you are configuring Mobile Authentication for an existing setup, you already have a project. In this case, check the steps in this section and adapt your already configured patterns to the instructions, if required.
* In case you are starting from scratch, or with a setup that has only a subset of the needed patterns, then follow the instructions below.

The movies in the next sections show the base patterns you need to configure:

* Virtual Host, nevisProxy and nevisAuth
* nevisIDM
* nevisIDM Web Application
* nevisFIDO
--------------------------------------------------------------------------------
Section: ### Further resources
If you want to set up Mobile Authentication from scratch, also consult the following resources:

* [Main Concepts](../../../nevisadmin4/introduction) of nevisAdmin 4.
* [First Steps](../patterns-overview), which shows how to configure a web application protected by nevisProxy.
* Alternatively, the following Nevis yoU books are available (requires registration):
   * nevisAdmin 4 in a Nutshell, which provides an easy-to-read overview of Nevis administration and the concepts used.
   * Working with nevisAdmin 4, explaining how to configure a web application protected by nevisProxy in more detail. 

## Virtual Host, nevisProxy and nevisAuth

Nevis Mobile Authentication needs a *Virtual Host* where the Mobile Authentication services will be exposed.

<img className="boxed" src={require('../../assets/VirtualHost.gif').default} alt="How to create a virtual host"/>

Some settings in the movie above, such as *Frontend* and *Bind Addresses*, will be different or skipped in your setup. See the documentation listed in the *Further resources* chapter above in case you need more detailed instructions.

Nevis Mobile Authentication needs a *nevisAuth Instance* where its authentication flows will be configured. Note, that a *nevisLogRend Instance* will be created automatically.

<img className="boxed" src={require('../../assets/nevisAuth.gif').default} alt="How to create a nevisAuth instance"/>

## nevisIDM

Nevis Mobile Authentication uses nevisIDM as its user and credential database.

In classic deployments, the nevisIDM database is not managed by nevisAdmin 4. In our example, we use a prepared database docker image as DB. Make sure to create or attach your own database.

<img className="boxed" src={require('../../assets/nevisIDM.gif').default} alt="How to create a nevisIDM instance"/>

## nevisIDM Web Application

To be able to access the nevisIDM UI, we have to configure a *nevisIDM Web Application:*

<img className="boxed" src={require('../../assets/nevisIDM-webapp.gif').default} alt="How to create a nevisIDM web application"/>

## nevisFIDO

Now continue with the setup of nevisFIDO.
--------------------------------------------------------------------------------
Section: #### Uploading the Key Material into the nevisAdmin 4 Project
Now that you have generated and imported the key material into nevisIDM, you need to configure the nevisAdmin 4 patterns to use the keys. Therefore, upload the "nevisFIDO Private Key" into a *PEM Key Store*pattern used by the *nevisFIDO Instance* pattern, and the "nevisFIDO Certificate" into a *PEM Trust Store* pattern used by the *nevisIDM Instance* pattern. The next movie shows you how to do this:

<img className="boxed" src={require('../../assets/copy-key-material-to-admin.gif').default} alt="How to upload the generated key material to the nevisAdmin 4 GUI"/>

:::info
You may need different key material depending on your inventory. For example: you use different key material for the DEV and the PROD stage. To support this, follow these steps:

* Create the same patterns as in the movie above, but instead of pasting the key material, you create variables. For more information, see Working with Variables.
* Within each inventory, add each variable and upload the key material to each variable as a file. For more information, see Working with Inventory File Attachments.
:::

## Mobile Authentication Use Cases

Now you are ready to configure the actual use cases. Go to Mobile Authentication Use Cases.
--------------------------------------------------------------------------------
Section: ### Authentication.md
---
sidebar_position: 112
---

# Authentication

Nevis Mobile Authentication supports two authentication use cases:

* In-band authentication: 
For more information, see [In-Band Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/in-band-authentication) in the Nevis Mobile Authentication Concept and Integration Guide.
* Out-of-band authentication: 
For more information, see [Out-of-Band Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication) in the Nevis Mobile Authentication Concept and Integration Guide.

## In-Band Authentication

You use the *In-band Mobile Authentication Realm* pattern to protect a backend resource used by a mobile application (for example a REST Service).

The pattern is similar to a regular *Authentication Realm* pattern, however limited to the protection of *REST Service* or *Mobile Device Deregistration* patterns.

The next figure shows the connections of the *In-band Mobile Authentication Realm* pattern with other patterns:

<img className="boxed" src={require('../../../assets/43122911.png').default} alt="The In-band Mobile Authentication Realm pattern and its connections"/>

The next movie shows how to configure in-band authentication to protect a REST Service, with the *In-band Mobile Authentication Realm* pattern:

<img className="boxed" src={require('../../../assets/InbandMobileAuthenticationRealm.gif').default} alt="How to configure in-band authentication protecting a REST service"/>

## Out-of-Band Authentication

When a web application needs to be protected by mobile authentication, you can use the *Out-of-band Mobile Authentication* pattern.

The figure below shows a setup with out-of-band mobile authentication. The white text boxes represent the corresponding patterns.

<img className="boxed" src={require('../../../assets/43122917.png').default} alt="Out-of-band authentication setup with the relevant patterns"/>

The next sections explain how you can configure such an out-of-band authentication setup, including two-factor authentication.
--------------------------------------------------------------------------------
Section: ### Part 1 - Requesting an Access App
1. Open the *Virtual Host* pattern of your nevisAdmin 4 project. Go to the *Frontend Address* field/property in *Basic Settings* tab.
   1. Enter the **backend** URL in this field.
   2. Then enter a second URL in the same field.
      1. This second address must be the same as the first one, except for the "app" subdomain. For example, if your first address is `https://**app**.example.siven.dev/`,  `https://app.user9000.admin4aks.azure.nevis.dev`.
      2. The domain in this second address will be the **Deep Link Domain**. So in our example, the deep link domain would be*app.example.siven.dev*.
2. Now you can order an Access App:
   1. Follow the instructions on the page Ordering an Access App of the Nevis Access App Guide.
   2. Make sure to provide the **backend URL** and the **deep link domain** you specified in [step 1], so that they can be built into the application.
   3. When the application is built, note down the information in the following table. You will need this information later on - without it, deep linking support is not possible.

| System | Information to obtain |
| --- | --- |
| iOS | Team Identifier, Bundle Identifier |
| Android | Package Name, SHA256 Fingerprint |
--------------------------------------------------------------------------------
Section: ### Part 2 - Creating the basic Mobile Authentication with Deep Links pattern
1. Add the *Mobile Authentication with Deep Links* pattern to your nevisAdmin 4 project. Set the following fields:
2. Assign the existing *nevisFIDO Instance* pattern to the *nevisFIDO* field/property.
3. Assign the existing *Virtual Host* pattern to the *Virtual Hosts* field/property.
4. Specify the **Deep Link Path** in the *Deep Link Base Path* field/property. The deep link path is the path rendered into the deep links. For example, a deep link path that will only be used for registration would look like this:

```
/registration
```

You can only set one deep link path

You cannot set multiple deep link paths. The path set in the *Deep Link Base Path* field will be used in every deep link that the backend generates.
--------------------------------------------------------------------------------
Section: ### Part 4 - Configuring the relying party application
See also Protecting a Web Application.

The relying party application is responsible for requesting the deep link from the nevisFIDO component and rendering/displaying the link to the end user. This application is **not** provided by Nevis. Deploy it independently. This section shows how to integrate the relying party application into the project to enable deep links.

1. Add a *Web Application* pattern to your nevisAdmin 4 project (or open the pattern, in case there already exists one for the relying party application). Specify the following fields:
2. *Virtual Hosts* field, *Basic Settings* tab: Assign the **same** *Virtual Host* pattern to this field as the one assigned to the *Mobile Authentication with Deep Links* pattern.
3. *Frontend Paths* field, *Basic Settings* tab: Specify any desired frontend path.
4. *Authentication Realm* field, *Basic Settings* tab: Assign the **same** *Authentication Realm* pattern as the one assigned to the *Mobile Device Registration* pattern (which you created when you configured the Out-of-Band Registration).
5. *Application Access Token* field, *Basic Settings* tab: Assign the **same** token as the one assigned to the *Mobile Device Registration* pattern.
6. *Backend Addresses* field, *Backend Connection* tab: Provide an accurate backend address that points to the relying party application's backend.
--------------------------------------------------------------------------------
Section: ### Part 5 - Deployment
Deploy the configuration with nevisAdmin 4.

## Test

Now that we have deployed the Mobile Authentication with Deep Links use case, we can test it.

1. Open a browser on the mobile device where the Access App is installed
2. Navigate to the relying party application. The URL of the application can be constructed by merging the Backend URL and whatever you configured in the *Frontend Paths*field of the *Web Application* pattern.
3. Log in.
4. The relying party application will approach nevisFIDO for a deep link, which it should render on the screen.
      The following figure shows how it might look like:

      <img className="boxed" src={require('../../../assets/65964860.jpg').default} alt="Deep link sample"/>

      For debugging purposes, this is an example how the generated link should look like:

      ```
      https://app.example.siven.dev/registration?dispatchTokenResponse=eyJubWFfZGF0YSI6eyJ0b2tlbiI6ImZjNGYyNGRjLWU4OGQtNGNhNC04ZWU5LTQ0OTM2NDdhNTViMyIsInJlZGVlbV91cmwiOiJodHRwczovL3VzZXI5MDAwLmFkbWluNGFrcy5henVyZS5uZXZpcy5kZXYvbmV2aXNmaWRvL3Rva2VuL3JlZGVlbS9yZWdpc3RyYXRpb24ifSwibm1hX2RhdGFfY29udGVudF90eXBlIjoiYXBwbGljYXRpb24vanNvbiIsIm5tYV9kYXRhX3ZlcnNpb24iOiIxIn0
      ```

5. Click the link, after which a banner should be visible, prompting you to choose the application to open the link.
6. Choose the Access App.
7. Complete the registration process shown in the Access App user interface.

:::tip Congratulations
You just executed out-of-band mobile registration, using deep links!
:::

[1] <http://developer.android.com/training/app-links>,<http://github.com/google/digitalassetlinks/blob/master/well-known/details.md>

[2] <http://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html/>
--------------------------------------------------------------------------------
Section: ### Registration.md
---
sidebar_position: 112
---

# Registration

If you want to use a mobile device in mobile authentication operations, register it beforehand.

Nevis Mobile Authentication offers two registration use cases:

* In-band registration
For more information, see In-Band Registration in the Nevis Mobile Authentication Concept and Integration Guide.
* Out-of-band registration
For more information, see Out-of-Band Registration in the Nevis Mobile Authentication Concept and Integration Guide.

Both can be configured with the *Mobile Device Registration* pattern via the *Registration Type* property.

## Pattern Structure

The next figure shows the connections of the *Mobile Device Registration* pattern to other patterns:

<img className="boxed" src={require('../../../assets/43122775.png').default} alt="The Mobile Device Registration pattern and its connections"/>

The *Mobile Device Registration* pattern requires the following patterns:

* *Authentication Realm*, to configure the legacy login.
* *Virtual Host*, to expose the backend services.
* *nevisFIDO Instance*, to provide the *FIDO UAF* related services.
--------------------------------------------------------------------------------
Section: ### QR Code Integration
Out-of-band registration is designed to be integrated into existing web applications. This integration happens via browser-rendered QR codes. The existing web application obtains the QR code data from the relevant nevisFIDO instance and renders the code on the UI. Therefore, the application must be able to connect to the nevisFIDO instance.

If you are interested in the details, check out Out-of-Band Registration and Out-of-Band Registration Client Code Examples in the Nevis Mobile Authentication Concept and Integration Guide.

The next movie shows QR code integration into an existing web application. For this, it uses a demo application that is specifically prepared for this goal.

The existing web application (*QR Demo Web App* in the movie) and the *Mobile Device Registration* pattern/service must be protected by the **same** Authentication Realm!

<img className="boxed" src={require('../../../assets/MobileDeviceRegistration-qrdemo.gif').default} alt="How to create and protect a QR Demo Web App"/>

## In-Band Registration

For in-band registration, legacy login is generated automatically into the realm, since it is an exposed REST service consumed by the mobile app. Multi-step legacy login authentication flows are not supported by the Nevis Access App and cannot be configured using this pattern.

When in-band registration is selected as registration type, the authentication flow provided in the authentication realm will be transparently generated. But an *Authentication Realm*  pattern has to be provided nevertheless. In case no browser authentication is configured in the realm, set up a *User Information* pattern.

The next movie shows how to configure in-band registration.

<img className="boxed" src={require('../../../assets/MobileDeviceRegistration-inband.gif').default} alt="How to configure in-band registration"/>

## In-Band and Out-of-Band Registration Together

In-band and out-of-band registration can be configured together (independent of each other). You do this by selecting the option "both" in the *Registration Type* drop-down menu of the *Mobile Device Registration* pattern. The following movie shows how to proceed:

<img className="boxed" src={require('../../../assets/MobileDeviceRegistration-both.gif').default} alt="How to configure in-band and out-of-band registration together"/>
--------------------------------------------------------------------------------
Section: ### Mobile-Authentication-Use-Cases.md
---
sidebar_position: 110
---

# Mobile Authentication Use Cases

The figure below shows all Nevis Mobile Authentication patterns and the connections between them:

<img className="boxed" src={require('../../../assets/34643852.png').default} alt="The Mobile Authentication patterns and their connections"/>

As you can see, all patterns or use cases reference the *nevisFIDO Instance* pattern.

Be careful when creating multiple *nevisFIDO Instance*s: Each instance must be connected to a different *Virtual Host*. The reason is that the URLs allocated for nevisFIDO services on the virtual host are fixed, that is, they always start with */nevisfido/*. These URLs are then mapped to exactly one nevisFIDO backend.

## List of Use Cases

The following use cases are supported by the pattern library:

* Registration
* Authentication
* Deregistration
* Transaction Confirmation
* Mobile Authentication with Deep Links
--------------------------------------------------------------------------------
Section: ### Key-Management-Report.md
---
sidebar_position: 134
---

# Key Management Report

This report provides information about the *key stores* and *trust stores* used in a project. What is shown in the *Details* column depends on the *Type* and may change in future releases.

As of nevisAdmin 4.10 the following *Type* exist:

* *automatic*:
  * No pattern is assigned / this store is implicit.
  * Key material will be created / renewed automatically on deployment if required.
  * No Details are displayed as meta data / certificate(s) are not reachable for the report.
* *Automatic Key Store*:
  * A pattern is assigned / the store is explicit.
  * No Details are displayed as meta data / own certificate are not reachable for the report.
* *Automatic Trust Store*:
  * A pattern is assigned / the store is explicit.
  * No Details are displayed as meta data / trusted certificate(s) are not reachable for the report.
  * Since nevisAdmin 4.10, this pattern supports the upload of additional trusted certificates, similarly to PEM Trust Store.
* *nevisKeybox Store*:
  * Key material must be managed on the target host. Not supported in Kubernetes.
  * The Details column shows slot / label.
* *PEM Key Store*:
  * Key material must be uploaded in the pattern.
  * Details column shows expiration of owned certificate.
* *PEM Trust Store*:
  * Trusted certificates must be uploaded in the pattern.
  * Details column shows expiration of trusted certificates.

The *Instance* links the *Instance Pattern* the store belongs to.

## Example

<img className="boxed" src={require('../../assets/65964410.png').default} alt="Key Management Report - Example"/>
--------------------------------------------------------------------------------
Section: ### Application-Mapping-Report.md
---
sidebar_position: 132
---

# Application Mapping Report

This report lists the applications of each virtual host and how they are mapped to backend addresses.

## Example

<img className="boxed" src={require('../../assets/60753576.png').default} alt="Application Mapping Report - Example"/>
--------------------------------------------------------------------------------
Section: ### Security-Configuration-Report.md
---
sidebar_position: 132
---

# Security Configuration Report

This report provides a detailed overview of the security configuration for virtual hosts and the backend applications on these virtual hosts.

Each topic in the report directly links to the pattern property where you can configure the setting.

For many topics, you can click on *Show details...* to see the exact configuration that is generated into the configuration files of nevisProxy.

## Example

<img className="boxed" src={require('../../assets/60753573.png').default} alt="Security Configuration Report - Example"/>
--------------------------------------------------------------------------------
Section: ### Application Add-on Patterns
The nevisAuth plug-in provides several patterns that you can assign to applications. You assign these patterns in the property field *Additional Settings*, which is available in the application patterns (for example, the *Web Application* pattern). Here are some examples:

* The *Authorization Policy* pattern allows the definition of the required roles or authentication level.
* Token patterns (for example, the *Nevis SecToken* pattern) can be assigned to propagate the user identity to the backend.

## What if my Use Case is not Covered by the Standard?

If your use case is not covered by the standard patterns, contact Nevis Support and explain your case.

The nevisAuth patterns are in active development and we are interested in your requirements.

In the meantime you have several options:

* Use the *Generic Authentication Step* pattern to add a custom step to an authentication flow configured with the *Authentication Realm* pattern. See the *Help* page of the *Generic Authentication Step* pattern for further information.
* Use the *Generic Authentication Realm* pattern for complex authentication flows.
--------------------------------------------------------------------------------
Section: ### Further resources
If you want to set up Nevis Authentication Cloud from scratch, also see the following resources:

* [Main Concepts](../../../nevisadmin4/introduction) of nevisAdmin 4.
* [Getting Started](../quickstart-appliance), which explains how to configure a web application protected by nevisProxy.
* Alternatively, the following Nevis yoU books are also available (requires registration):
  * nevisAdmin 4 in a Nutshell, which provides an easy-to-read overview of Nevis administration and the concepts used.
  * Working with nevisAdmin 4, explaining how to configure a web application protected by nevisProxy in more detail.

## Basic Steps

If you are starting with an empty project, have a look at the [Base Setup](../Mobile-Authentication/Base-Setup) for Nevis Mobile Authentication which covers the same steps with more details. Skip the nevisFIDO setup, as that is the functionality that the Nevis Authentication Cloud will provide for you.
--------------------------------------------------------------------------------
Section: ### LDAP-Login.md
---
sidebar_position: 89
---

# LDAP Login

## Preconditions

* Make your web application accessible via nevisProxy as explained in Protecting a Web Application.

## Quickstart

1. Assign an *Authentication* *Realm* pattern to your web application.
2. Assign an *LDAP Login* pattern to your *Authentication Realm* pattern.
   1. You do this in the *Initial Authentication Flow* field, *Basic Settings* tab of the *Authentication Realm* pattern.
3. Configure the *LDAP Login* pattern as follows:
   1. Select the type of LDAP you have.
   2. Enter the LDAP URL.
   3. Enter the base DN where the users are located.

## LDAPS Integration

In case of LDAPS, you have to ensure that the issuing CA of the LDAP endpoint certificate is trusted.

For this, you have to assign a provider for the backend truststore in the *nevisAuth Instance* pattern.

* You do this in the *Backend Trust Store* field, *Key Management* tab.

You can assign the following patterns as provider:

* *nevisKeybox Store*: To use CA certificates managed via nevisKeybox on the target servers.
* *PEM Trust Store*: To deploy the CA certificates using nevisAdmin 4.
--------------------------------------------------------------------------------
Section: ### nevisIDM-Password-Login.md
---
sidebar_position: 86
---

# nevisIDM Password Login

## About nevisIDM Password Login

The *nevisIDM Password Login* pattern provides a username/password based authentication for applications based on nevisIDM users.

For information on how to configure authentication for the nevisIDM Administration GUI, refer to: Accessing the nevisIDM Administration GUI.

The user identity can be propagated to your backend application via an application access token, for example a *Nevis SecToken* or a *JWT Token*.

The next diagram gives an overview of the patterns involved and their relationship:

<img className="boxed" src={require('../../assets/7636779.png').default} alt="Patterns involved in nevisIDM Password Login"/>

## Preconditions

* Make your web application accessible via nevisProxy as explained in [Protecting a Web Application](../Application-Protection/Protecting-a-Web-Application/Protecting-a-Web-Application).
* Add a nevisIDM Instance pattern as explained in [Setting up a nevisIDM Instance](../Identity-Management/Setting-up-a-nevisIDM-Instance).

## Basic Steps

1. Assign an *Authentication Realm* pattern to your web application.
2. Assign the *nevisIDM Password Login* pattern to the *Authentication Realm* pattern.
3. Assign the *nevisIDM Instance* pattern to the *nevisIDM Password Login* pattern.
4. Assign a *Nevis SecToken* pattern to the *Authentication Realm* pattern.
5. Assign the same *Nevis SecToken* pattern to your web application.

## Use Case: Mandatory Password Change

The *nevisIDM Password Login* pattern also configures the mandatory password change after a user's first login to the system. The mandatory password change is enabled by default. It is enforced by the password policy in nevisIDM. When the user enters a password, the *nevisIDM Password Login* pattern verifies it against the default password policy of the relevant client.
--------------------------------------------------------------------------------
Section: ### identity-management.md
---
sidebar_position: 1
---

# Identity Management

The standard nevisIDM patterns provide a means to set up and configure a nevisIDM instance in a standardized way. 
Patterns are classified into categories for easy access; the nevisIDM patterns are classified in the *Identity Management* category.

The next diagram gives an overview of the available nevisIDM patterns:

<img className="boxed" src={require('../../assets/7640279.png').default} alt="Available nevisIDM patterns"/>

## Prerequisites

The nevisIDM patterns require nevisIDM to be already installed on the target host(s).

The following packages are required:

* *nevisidm*: Contains the nevisIDM web application. This package must be installed on the nevisIDM target host(s).
* *nevisidmcl*: Contains the nevisIDM authentication plug-ins (AuthStates). This package must be installed on the nevisAuth target host(s).

:::note
The *nevisidmdb* package is not required.
:::

The nevisIDM patterns only support nevisIDM in standalone mode. Before nevisAdmin 4 deploys the nevisIDM configuration, the system checks whether the installed nevisIDM version will suffice.

## Standard nevisIDM Patterns

The next chapters describe the standard nevisIDM patterns.
--------------------------------------------------------------------------------
Section: ### Patterns to Access the nevisIDM Web Application and the REST/SOAP Services
The following patterns are used to make the corresponding services of nevisIDM accessible via nevisProxy:

* The *nevisIDM Web Application* pattern configures nevisProxy to access the nevisIDM administration web application via the */nevisidm/admin* frontend path.
* The *nevisIDM REST Service* pattern makes the REST services of nevisIDM accessible via the */nevisidm/api* frontend path.
* The *nevisIDM SOAP Service* pattern makes the SOAP services of nevisIDM accessible via the */nevisidm/services* frontend path. See chapter [Accessing the nevisIDM Administration GUI](Accessing-the-nevisIDM-Administration-GUI.md) for more details.

All nevisIDM services require authentication, which is provided by the *nevisIDM Password Login* pattern. See the next section.
--------------------------------------------------------------------------------
Section: ### Accessing-the-nevisIDM-Administration-GUI.md
---
sidebar_position: 106
---

# Accessing the nevisIDM Administration GUI

The *nevisIDM Administration GUI* pattern is used to configure the access to the nevisIDM administration web application.

For information on how to configure nevisIDM user identity propagation to 3rd party web application, refer to nevisIDM Password Login.

## Preconditions

* Make your web application accessible via nevisProxy as explained in Protecting a Web Application.
* Add a nevisIDM Instance pattern as explained in Setting up a nevisIDM Instance.

## Quickstart

1. Add a new *nevisIDM Administration GUI* pattern to your project.
2. Assign an *Authentication Realm* pattern to the *nevisIDM Administration GUI* pattern.
3. Assign the *nevisIDM Password Login* pattern to the *Authentication Realm* pattern.
4. Assign the *nevisIDM Instance* pattern to the *nevisIDM Password Login* pattern.
5. Assign a *Nevis SecToken* pattern to the *Authentication Realm* pattern.
6. Assign the same *Nevis SecToken* pattern to the *nevisIDM Administration GUI* pattern.

After you have deployed the pattern, the application will be available on the */nevisidm/admin* frontend path.

For more information about the nevisIDM Administration GUI, see the [nevisIDM Technical Documentation](../../../nevisidm/introduction).

## Overview

The next diagram gives you an overview of the patterns involved and their relationship.

<img className="boxed" src={require('../../assets/7636793.png').default} alt="Patterns involved in configuring access to nevisIDM Web Application"/>

## nevisIDM Self-Administration

The nevisIDM self-administration web application is not accessible by default. Map the */nevisidm/selfadmin* frontend path with the *Generic Application Settings* pattern to make the application available. Proceed as follows:

1. Open the *nevisIDM Administration GUI* pattern in nevisAdmin 4.
2. Create the pattern *Generic Application Settings* in the *Additional Settings* field.
3. Define the settings for the *Generic Application Settings* pattern: enter the following code block in the *Filters and Mappings* field:

```
<servlet-mapping>
 <servlet-name>Connector_${service.name}</servlet-name>
 <url-pattern>/nevisidm/selfadmin/*</url-pattern>
</servlet-mapping>
```
--------------------------------------------------------------------------------
Section: ### Social-Login-Pattern-Map.md
---
sidebar_position: 54
---

# Pattern map

<img className="boxed" src={require('../../assets/social-login-pattern-map.png').default} alt="Social Login Pattern map"/>

<span style={{color: "blue"}}>Dark blue background:</span>

Used to denote patterns labeled as Applications, which are web applications accessible after deployment.

<span style={{color: "darkgoldenrod"}}>Yellow background:</span>

Used to denote pattern labeled as Social Login Flow.

<span style={{color: "green"}}>Green background:</span>

Used to denote patterns labeled as Nevis Components which describe the infrastructure.
--------------------------------------------------------------------------------
Section: ### passkey-pattern-map.md
---
sidebar_position: 62
---

# Pattern Map

<img className="boxed" src={require('../../assets/passkey-pattern-map.png').default} alt="Passkey pattern map"/>

<body text = "darkgreen">Dark green background:</body> Used to denote patterns labeled as ‘Nevis Components’ which describes the infrastructure.

<body text = "blue">Blue background:</body> Used to denote patterns labeled as ‘Admin UI’ which describes the admin infrastructure.

<body text = "darkgoldenrod">Yellow background:</body> Used to denote patterns labeled as ‘Login’ which are used to set up a general login flow with Passkey.

<body text = "lightgreen">Light green background:</body> Used to denote patterns labeled as ‘Applications’ which are web applications accessible after deployment.

<body text = "red">Red background:</body> Used to denote patterns labeled as ‘Self Registration’ which are needed for the self Registration Flow.

<body text = "pink">Pink background:</body> Used to denote patterns labeled as ‘SMTP’ which describes the SMTP infrastructure.
--------------------------------------------------------------------------------
Section: ### SAML-2.0-Identity-provider.md
---
sidebar_position: 21
sidebar_label: SAML 2.0 Identity provider
---
import Vimeo from '../../../../src/components/Vimeo';

# SAML 2.0 Identity Provider

Security Assertion Markup Language (SAML) is an *authentication protocol* and therefore a crucial part in identity federation between organisations.

As an open standard that allows identity providers (IdP) to pass authorization credentials to service providers (SP), SAML builds the link between the authentication of a user’s identity and the authorization to use a service. SAML only works for web applications.

For further information you could read more [here](https://www.nevis.net/en/fundamentals/what-is-saml).

For detailed view of the technical components used please visit [this](SAML-Pattern-map.md) page.

## The project template

The Nevis project template **SAML 2.0 Identity Provider** supports username / password login infrastructure. For demonstration purposes, the template includes an **example service provider**: it is the nevisIDM GUI and supports **SP initiated** login & logout procedures!

<img className="boxed" src={require('../../assets/SAML2.0-identity-provider.png').default} alt="SAML 2.0 Identity Provider"/>

<Vimeo src="https://player.vimeo.com/video/853672541" title="SAML 2.0 Identity Provider Project Template"/>

<img className="boxed" src={require('../../assets/SAML2.0-identity-provider2.png').default} alt="SAML 2.0 Identity Provider 2"/>

## Scenario for testing a successful deployment

1. Launch your Service Provider (in our example, the nevisIDM Administration GUI application) at `https://your_domain_goes_here/nevisidm/` - replace “your_domain_goes_here” with your real domain name!
2. First time you log-in using your “bootstrap” credentials (bootstrap/generated), you need to change your password before actual login could happen.
3. You land at your IDM admin page. Success!

 You can always observe the relevant SAML communication exchange via a SAML-tracer browser extension e.g. like this: SAML-login.png 

 <img className="boxed" src={require('../../assets/SAML-login.png').default} alt="SAML Login"/>

4. Optionally you could also try logout and observe corresponding SAML entries in a SAML-tracer browser extension:

 <img className="boxed" src={require('../../assets/SAML-logout.png').default} alt="SAML Logout"/>

5. Now it is time to replace the example SP (nevisIDM Admin GUI) with your own service provider and enjoy the Nevis security experience!

## User-facing flows

1. [Login](SAML-2.0-Login.md)
2. [Logout](SAML-2.0-Logout.md)
--------------------------------------------------------------------------------
Section: ### SAML-2.0-Login.md
---
sidebar_position: 22
---

# SAML 2.0 Login

## SP-Initiated Authentication

<img className="boxed" src={require('../../assets/SP-initiated-authentication.png').default} alt="SP initiated authentication.png"/>

SP-initiated SAML authentication works as follows (the numbers of the steps below correspond with the numbers in the figure above):
1. The user wants to access the web application www.siven.ch:
   * The web application is behind a nevisProxy virtual host and protected by a SAML SP Realm.
   * The user uses a browser-based client.
2. As there is no authenticated session, access to the application is blocked.
   * Session tracking is based on a session cookie.
   * Authentication is enforced by nevisProxy.
   * The request is forwarded to nevisAuth, which acts as SP and initiates the SAML flow.
3. The SP checks if the session has been expired.
   * This check is optional and can be enabled in the SAML SP Realm pattern (Session Expiration tab).
   * The SAML SP Realm pattern provides different strategies on how to handle expired sessions. Each strategy corresponds with a field in the Session Expiration tab:
      * Logout Reminder: Renders a page that reminds the user to log out in the future.
      * Timeout Page: Renders a page that informs about the termination of the session due to timeout.
      * Session Expiration Redirect: Redirects to a configurable URL (for example, a hosted resource or the URL of the IDP to trigger IDP-initiated authentication).
4. The SP can also execute an optional custom pre-processing step.
   * You configure this step in the Custom Pre-Processing field of the SAML SP Realm pattern (Advanced Settings tab). Check the pattern's Help section for further information about this advanced feature.
5. The SP now determines which SAML IDP to invoke.
   * This step is not relevant when only one IDP is configured.
   * The IDP is selected based on a selection expression. You configure this expression in the SAML IDP Connector pattern (Selection Expression field, Advanced Settings tab). Check the pattern's Help section for examples.
6. The SP returns an AuthnRequest.
   * The AuthnRequest contains the Issuer of the SP and is signed with the SAML Signer of the SP.
   * The SP stores the current URL (of the application) in a RelayState parameter.
      * The SAML standard demands that the IDP returns this RelayState parameter unchanged.
   * The browser is instructed to send AuthnRequest and RelayState to the IDP. How these parameters are transmitted can be configured in the SAML IDP Connector pattern (Binding: Outbound field, Basic Settings tab):
      * POST-binding ("http-post"): Self-submitting form. This is the default setting.
      * Redirect-binding ("http-redirect"): Using query parameters and a 302 redirect.
7. The IDP consumes the AuthnRequest.
   * The IDP first extracts the Issuer from the AuthnRequest and dispatches the request into the correct IdentityProviderState.
      * Each SAML SP Connector pattern generates one IdentityProviderState.
   * The IdentityProviderState validates the signature of the AuthnRequest.
      * If the signature is not valid, then a standard SAML error response is returned.
8. If the user has no authenticated session on the IDP he has to log in first.
   * The authentication flow is defined by the Authentication Realm pattern assigned to the SAML IDP pattern.
9. Once the session is authenticated, the SAML IDP produces a SAML Response.
   * The Response is sent to the AssertionConsumerServiceURL that has been extracted from the AuthnRequest.
   * If no AssertionConsumerServiceURL is found, then the URL defined in the SAML SP Connector pattern is used.
10. The SP consumes the Response:
   * Based on the Issuer of the Response the corresponding ServiceProviderState for this IDP is selected.
      * Each SAML IDP Connector pattern generates one ServiceProviderState.
   * The ServiceProviderState validates the signature of the Response.
   * If the Response contains an AudienceRestriction then it has to match the current URL.
11. The SP can execute an optional post-processing flow.
   * You configure this flow in the Post-Processing Flow field of the SAML SP Realm pattern (Advanced Settings tab). Check the pattern's Help section for further information about this advanced feature.
12. The SP declares the authentication as done and redirects back to the web application.
   * The URL of the application is taken from the RelayState parameter.
13. As there is an authenticated session now, nevisProxy allows the user to access the application.
   * If an Application Access Token is assigned to the web application, the SAML SP is invoked again to produce that token.
   * If an Authorization Policy is assigned that demands a higher authentication level, a session upgrade may be performed. See the chapter SAML Flow for Session Upgrade for details.
--------------------------------------------------------------------------------
Section: ### SAML-Pattern-map.md
---
sidebar_position: 24
---

# Pattern map

<img className="boxed" src={require('../../assets/SAML-patterns-map.png').default} alt="SAML Pattern map"/>

<body text = "blue">Dark blue background:</body> Used to denote patterns labeled as `Applications`, which are web applications accessable after deployment.

<body text = "darkgoldenrod">Yellow background:</body> Used to denote pattern labeled as `SAML Identity Provider` which are needed for the SAML flow.

<body text = "green">Green background:</body> Used to denote patterns labeled as `Nevis Components` which described the infrastructure.
--------------------------------------------------------------------------------
Section: ### mobile-pattern-map.md
---
sidebar_position: 72
---

# Pattern Map

<img className="boxed" src={require('../../assets/mobile_auth_pattern_map.png').default} alt="Pattern map"/>

<body text = "darkgreen">Dark green background:</body> Used to denote patterns labeled as ‘Nevis Components’ which describes the infrastructure.

<body text = "blue">Blue background:</body> Used to denote patterns labeled as ‘Admin UI’ which describes the admin infrastructure.

<body text = "darkgoldenrod">Yellow background:</body> Used to denote patterns labeled as ‘Login’ which are used to set up a general login flow with Passkey.

<body text = "lightgreen">Light green background:</body> Used to denote patterns labeled as ‘Applications’ which are web applications accessible after deployment.

<body text = "red">Red background:</body> Used to denote patterns labeled as ‘Self Registration’ which are needed for the self Registration Flow.

<body text = "pink">Pink background:</body> Used to denote patterns labeled as ‘SMTP’ which describes the SMTP infrastructure.
--------------------------------------------------------------------------------
Section: ### mobile-authentication.md
---
sidebar_position: 71
sidebar_label: Mobile Authentication
---

import Vimeo from '../../../../src/components/Vimeo';

# Mobile authentication

Mobile authentication is the verification of a user’s identity through the use of a mobile device and one or more authentication methods to ensure secure access. To keep your online services safe, enabling your users to use mobile authentication across their devices is the single most important step you can take.

<img className="boxed" src={require('../../assets/how-fido-works.png').default} alt="How FIDO works in a nutshell"/>

Using biometric capabilities of modern mobile devices is a convenient solution to multi-factor authentication (MFA). To verify an individual's identity it uses possession of a mobile device as a first factor, and a unique biometric identifier on that device as a second factor. Combining two factors into one.

<img className="boxed" src={require('../../assets/scan-qr.png').default} alt="QR Code Sign-in"/>

Our product allows organisations to build a seamless mobile authentication experience. The Access App and Mobile SDK are based on the open FIDO UAF standard. We support various biometric authentication methods and fallbacks:

* Complete FaceID, TouchID support on Apple iPhone devices.
* Fingerprint support and Biometric Prompt support on Android devices.
* Secure PIN-based fallback method, if a user does not have biometrics enabled.

For more details please visit our doc repository: [Overview | Nevis documentation](../../mobile-auth-concept-and-integration-guide/overview.md) & FIDO Alliance materials: [User Authentication Specifications Overview - FIDO Alliance](https://fidoalliance.org/specifications/).

Using this project template, users can sign-up for an account or sign-in using username & password followed by a QR code based 2nd factor authentication - representing the UAF based, out-of-band registration & authentication flows. 

There is always a fallback mechanism providing a one-time-password sent to the registered email address as eTAN code.

:::info Important Note

In order to work with this project template you need to have a proper access app installed on your mobile device. There is 2 options:

1. You can use a demo one (available for both [iOS](https://testflight.apple.com/join/q0lkyEVR) & [Android](https://appdistribution.firebase.google.com/pub/i/b58532b9c7f4ced2)).
2. You can go through the official process of [Ordering an access app](../../../nevisaccessapp/ordering-an-access-app) and have it dedicated, branded and configured for you.
:::

## The project template​

The NEVIS project template Mobile authentication is configured to use an example Web application (`http://example.com`) by default as a protected web service.

<img className="boxed" src={require('../../assets/mobile-auth.png').default} alt="Mobile Authentication"/>

<Vimeo src="https://player.vimeo.com/video/924603338" title="Mobile authentication tutorial"/>
--------------------------------------------------------------------------------
Section: ### Scenario for testing a successful deployment
0. Install your mobile access app (iOS or Android) and configure your project according to the template description.
1. Deploy your project.
2. Launch your example Web application at https://your_domain_goes_here/app/ - replace “your_domain_goes_here” with your real domain name!
3. Register a new user and use your access app (already installed on your mobile phone) to authenticate by reading a QR code provided by the server.
4. Log-out.
5. Log-in with the account you just registered using your access app to authenticate by reading a QR code provided by the server.
6. Now it is time to replace the exposed example application by your own service and enjoy the NEVIS security experience!
--------------------------------------------------------------------------------
Section: ### Pattern-map.md
---
sidebar_position: 14
---

# Pattern map

<img className="boxed" src={require('../../assets/Basic-IDM-template-overall.png').default} alt="Basic IDM template"/>

<body text = "blue">Dark blue background:</body> Used to denote patterns labeled as `Applications`, which are web applications accessible after deployment.

<body text = "darkcyan">Light blue background:</body> Used to denote patterns labeled as `Login Flow` which are used to set up a general login flow with password.

<body text = "darkgoldenrod">Yellow background:</body> Used to denote pattern labeled as `Self Registration Flow` which are needed for the self Registration Flow.

<body text = "green">Green background:</body> Used to denote patterns labeled as `Nevis Compontents` which described the infrastructure.

<body text = "lightgreen">Light green background:</body> Used to denote patterns labeled as `SMTP` which is used to set up mailing for `E-mail TAN` AuthState.

## Infrastructure patterns

<img className="boxed" src={require('../../assets/Basic-IDM-template-infrastructure.png').default} alt="Infrastructure pattern"/>
--------------------------------------------------------------------------------
Section: ### Open-ID-Connect-Provider.md
---
sidebar_position: 31
sidebar_label: OpenID Connect
---
import Vimeo from '../../../../src/components/Vimeo';

# OpenID Connect

Like SAML, OpenID Connect (OIDC) is an *authentication protocol*, facilitating the exchange of authorization credentials and basic profile information between identity providers and reliant parties (aka service providers). In other words, OIDC is a set of defined process flows for *federated authentication*. These flows are built using the OAuth 2.0 process flows as a base, adding a simple identity layer over it to allow for federated authentication.

OpenID Connect works both for *web and mobile applications*. Considering the fact that SAML only works for web applications, OIDC is the standard to follow when it comes to mobile applications and Javascript.

OpenID Connect lets reliant parties (RP’s) authenticate users across websites and apps without having to own and manage password files. Thanks to OIDC the reliant party knows at anytime what the identity of the person, currently using the browser or native app, is, without having to manage the users identity themselves.

For further information you could read more [here](https://www.nevis.net/en/fundamentals/what-is-oidc).

## The Project template

The Nevis project template OpenID Connect Provider supports username / password login infrastructure. 

<img className="boxed" src={require('../../assets/OpenID-connect-provider.png').default} alt="OpenID connect provider"/>

<Vimeo src="https://player.vimeo.com/video/853677095" title="OpenID Connect Provider Project Template"/>

<img className="boxed" src={require('../../assets/OIDC-project-template.png').default} alt="OIDC project template"/>

## Scenario for testing a successful deployment

Before hooking your services you can fairly simply make sure your deployment works as intended. Following the step-by-step guide below you would be able to verify the major OpenID Connect calls e.g. obtaining access tokens.

The purpose of the Authorization Code flow with PKCE is to acquire an Access Token, which can be added as Bearer token to REST calls made towards a Resource Server.

This flow should be used by single-page (SPA) and other client-side applications which cannot store a client secret as it could easily be extracted.

In order to run a very basic verification you must configure a couple of items as follows:
1. Launch your nevisMETA GUI application at `https://your_domain_goes_here/nevismeta` - replace “your_domain_goes_here” with your real domain name!
2. Login using bootstrap.
3. Choose the pre-configured Default setup.
4. Add & configure META resource server (using the + icon in the upper right corner).
   * Add custom name.
   * For `scope` ADD `openid` & `offline_access` with all flow consent set to NO CONSENT REQUIRED (by default this is set to CONSENT REQUIRED).

 <img className="boxed" src={require('../../assets/Resource-server.png').default} alt="Resource server"/>

5. Add & configure META client (using the + icon in the upper right corner).
   * Add custom name.
   * Redirect URLs: `<put your Azure domain name here>`
   * Registered Scopes: Put both openid & offline_access (start typing the name, then select from the popup list, this way the server and client are associated).
   * Token Endpoint Auth Method: in this example since POSTMAN calls are going to be performed, set this to `CLIENT_SECRET_POST`
   * PKCE Mode: `S_256_REQUIRED`

 <img className="boxed" src={require('../../assets/Meta-client.png').default} alt="Meta Client"/>

6. Prepare the POSTMAN calls (get authorization code, get access token, get refresh token).

 There is a need to generate 2 codes for PKCE:
   * `code_verifier` - must be a random `String` and at least 43 characters long.
   * `code_challenge` - URL-safe base64 encoded SHA256 hash of the `code_verifier`. The codes ensure message integrity. Even if an attacker intercepts the *Authorization Code*, they won't be able to obtain an *Access Token* as they also need the `code_verifier` and the `code_challenge`.

 Example Angular code to generate `code_challenge` from `code_verifier`:

 ```
 import * as CryptoJS from 'crypto-js';
 
 private generateCodeChallenge(code_verifier: string): string {
   return this.base64URL(CryptoJS.SHA256(code_verifier));
 }
 
 private base64URL(value) {
   return value.toString(CryptoJS.enc.Base64)
     .replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
 }
 ```

 Alternatively you can visit [PKCE Tools](https://example-app.com/pkce) and quickly get the codes needed.
 
 On behalf of the client we need to simulate an HTTP GET request to the Identity Suite Authorization endpoint. Example URL (HTTP GET), using POSTMAN GET call:

 ```
 https://<yourserver>.westeurope.cloudapp.azure.com/oauth/authorize
  ?response_type=code
  &code_challenge=U2ZQIMYt1dJ-Vft83__UiJihGh40zoXX5GoOnsDo4BE
  &code_challenge_method=S256
  &client_id=dbd00f622a1f005f
  &redirect_uri=https://<yourserver>.westeurope.cloudapp.azure.com
  &scope=openid,offline_access
 ```

 Besides setting the parameters defined above you’d also need to provide user credentials explicitly in POSTMAN since we do not have a real client running, just simulating it using POSTMAN. Go to the Authorization tab and provide bootstrap user credentials (see example below).

 <img className="boxed" src={require('../../assets/Get-authorization-code1.png').default} alt="Get authorization code"/>

 <img className="boxed" src={require('../../assets/Get-authorization-code2.png').default} alt="Get authorization code"/>

 Upon successful authentication, the authorization endpoint stores the code challenge, generates an Authorization Code, and redirects the user to the return_uri (in case of the example there is no service developed therefore → Page not found)  The code is however added as a query parameter. Example URL (HTTP GET):

 ```
 https://<yourserver>.westeurope.cloudapp.azure.com?code=WyZIgDiGQ0DIvbZM7vmBW2ADw6hzwekZac0oe_ucfYo
 ```

 On behalf of the client we now need to simulate an HTTP POST request to the *Identity Suite* Token endpoint (together with the `code_verifier`). Example URL (HTTP POST), using POSTMAN GET call:

 ```
 https://<yourserver>.westeurope.cloudapp.azure.com/oauth/token
 grant_type=authorization_code
 &client_id=dbd00f622a1f005f
 &client_secret=
 &code_verifier=DP0DueG8PR9rj6ITsWg7YHEUEg5QPttl84wq6xA7NNo9z0vLmCWNTYPKYrjCC9hh
 &code=WyZIgDiGQ0DIvbZM7vmBW2ADw6hzwekZac0oe_ucfYo
 &redirect_uri=https://<yourserver>.westeurope.cloudapp.azure.com
 ```

 <img className="boxed" src={require('../../assets/Get-access-token.png').default} alt="Get access token"/>

 The token endpoint verifies the code_challenge and the code_verifier. The token endpoint returns an Access Token. Depending on the scopes requested, additional tokens will be returned:
   * ID Token: scope `openid`
   * Refresh Token: scope `offline_access`

 ```script title="Example JSON response"
 {
   "access_token":"...",
   "refresh_token":"...",
   "id_token":"...",
   "token_type":"Bearer",
   "expires_in":3600
 }
 ```

7. Now it is time to configure your own resource server(s) & client and enjoy the Nevis security experience!

## User-facing flows

1. [Authorization code flow with PKCE](OIDC-Token-Authorization-Code-Flow.md)
2. [Refresh token flow](Refresh-Token-Flow.md)
--------------------------------------------------------------------------------
Section: ### nevisauth-fido-authstates.md
---
sidebar_position: 10
---

# FIDO AuthStates

nevisFIDO provides its own AuthStates, which you can configure and use in nevisAuth.

## Installation

The nevisFIDO AuthStates are installed using the [client RPM](../../nevisfido-component/installation.md#client-rpm-installation). After installing the RPM, the AuthStates and the required dependencies are located under `/opt/nevisfidocl/nevisauth/lib`.

## Configuration

We provide the following AuthStates:
* `FidoUafAuthState`: configure this AuthState, if mobile authentication is executed by an AccessApp, where a browser is not involved. 
  * Example use-case: the user initiates a removal of a credential through their AccessApp, and the process is to be authenticated with mobile authentication.
* `OutOfBandFidoUafAuthState`: configure this AuthState, if mobile authentication is executed by an AccessApp, but the authentication is initiated from a browser from a different device. 
  * Example use-case: the user tries to transfer money via a web application in the browser, and the process is to be authenticated by a push notification sent to the AccessApp, followed by mobile authentication.
* `Fido2AuthState`: configure this AuthState if authentication is executed by the browser and native capabilities of the device. 
  * Example use-case: the user logs into a web application through the browser using the fingerprint scanner of the mobile device.

When you configure a nevisFIDO AuthState, pay attention to the following:

* If the `classPath` attribute is specified in the `AuthEngine` configuration, it has to contain the directory with the nevisFIDO AuthStates directory (as in the following sample code):

  ```xml
  <AuthEngine name="AuthEngine"
              classPath="/var/opt/nevisauth/default/plugin:/opt/nevisauth/plugin:/opt/nevisfidocl/nevisauth/lib"
              classLoadStrategy="PARENT_FIRST"
              useLiteralDictionary="true"
              addAutheLevelToSecRoles="true"
              compatLevel="none"
              inputLanguageCookie="LANG">
  ```

* If you employ a JSON based client, use a `DirectResponseState` AuthState as the `AuthDone` AuthState to make integration easier. For example, the `AuthDone` AuthState in the sample below will return a successful HTTP response with `{ "message" : "successful authentication" }` as body:

  ```xml
  <AuthState name="AuthDone"
             class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState"
             final="true"
             resumeState="false">
      <Response value="AUTH_DONE"/>
      <property name="contentType" value="application/json"/>
      <property name="content" value="{&quot;message&quot;:&quot;successful authentication&quot;}"/>
      <property name="statusCode" value="200"/>
  </AuthState>
  ```

* Restart the nevisAuth instance.
--------------------------------------------------------------------------------
Section: ### outofbandfidouafauthstate.md
---
sidebar_position: 30
---

import REUSE02 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/query-dispatch-target/http-response.md'
import REUSE03 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/out-of-band-authstate-dispatch-token-response.md'
import REUSE04 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/succeeded-status/response-body.md'
import REUSE05 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/dispatch-png-qr-code-with-encryption/response-body.md'
import REUSE06 from '/docs/reusable-md/_new-auth-http-client-information.md'

# OutOfBandFidoUafAuthState

<REUSE06/>

## Introduction and overview

The `OutOfBandFidoUafAuthState` AuthState manages the UAF authentication in a nevisFIDO server by invoking the [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service). The typical use case is that a client wants to access an application using a desktop, whereas the authentication is done with a mobile device. In this case, a token is dispatched to the mobile device, where the user authenticates.

The UAF authentication process including nevisAuth and the `OutOfBandFidoUafAuthState` is as follows:

1. The `OutOfBandFidoUafAuthState` sends a [dispatch target query](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/dispatch-target-service#query-dispatch-target) to retrieve the dispatch targets defined for the user. The `fidoUafUsername` attribute is used to generate this request. The value of this attribute (that is, the username) can be retrieved in different ways:

    * By authenticating the user through an AuthState that is configured before the `OutOfBandFidoUafAuthState`. The  username value can be a variable expression using `notes`.

    * The HTTP client provides the FIDO UAF username directly in the incoming request as JSON or FORM parameters. The username value can be a variable expression using `inargs`.

2. The nevisFIDO server returns the [list of dispatch targets](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/dispatch-target-service#response-body-3) to nevisAuth, which forwards the dispatch targets to the client. If no dispatch targets are found, nevisAuth returns an empty list.
3. The client selects one of the dispatch targets, if required in interaction with the user. Subsequently, the client sends a request with the dispatch target ID and the username to nevisAuth.
4. The `OutOfBandFidoUafAuthState` sends a dispatch token request to the nevisFIDO server with the provided dispatch target ID. nevisFIDO uses the [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service) for this. In the context of transaction confirmation, the `OutOfBandFidoUafAuthState` can be configured with a list of FIDO UAF `transaction`. This list of `transaction` will be sent to the nevisFIDO server as part of the `GetUAFRequest`
5. The nevisFIDO server returns a dispatch token response to nevisAuth, which forwards the response to the client. The dispatch token response contains a FIDO UAF session ID. See [Example Response Using FCM Dispatcher](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service#example-response-using-fcm-dispatcher) for a response example.
6. The client queries nevisAuth. It depends on the configuration of the `fidoUafSessionId` property in the `OutOfBandFidoUafAuthState` whether the client must provide this property. By default, the client is required to send the `fidoUafSessionId` property in a POST with a payload like this:

   ```json
   { "fidoUafSessionId" : "asdetwdIDsdfsewSAdsds09823423sdfsd9ds" }
   ```

7. The `OutOfBandFidoUafAuthState` processes the authentication status query, by asking the nevisFIDO server whether the  user was actually authenticated. If so, the `OutOfBandFidoUafAuthState` has a transition `ok`. nevisAuth sends a response to the client, including a payload like this:

   ```json
   {
     "status" : "succeeded",
     "timestamp" : "2018-12-14T20:37:48.556Z",
     "tokenInformation" : {
       "tokenResult" : "tokenRedeemed",
       "dispatcherInformation" : {
         "name" : "firebase-cloud-messaging",
         "response" : "successful dispatch"
       }
     },
     "uafStatusCode" : 1200,
     "userId" : "123122233",
     "authenticators" : [ {
       "aaid" : "ABBA#0001"
     } ]
   }
   ```

8. The client must send another request to nevisAuth to continue with the authentication process.

```plantuml title="OutOfBandFidoUafAuthState example flow"
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white
 
    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}


title Authentication Flow with DispatchTokenAuthState

actor "Client (Web Application)" as client
actor "FIDO Mobile client" as mobileclient
participant nevisProxy as proxy

box "nevisAuth"
    participant DispatchTokenAuthState as uaf
    participant OkAuthState as ok
    participant FailedAuthState as failed
end box

participant nevisFIDO as fido

== Dispatch Target Query ==

client -> proxy : ""username""
note right
authenticate
end note
proxy -> uaf : ""inargs:username""
activate uaf
uaf -> fido : Dispatch Target Query
activate fido
fido -> uaf : Dispatch Targets
deactivate fido
uaf -> uaf : isDirectResponse = true
uaf -> proxy : DispatchTargets
deactivate uaf
proxy -> client : DispatchTargets

== Dispatch Token Request ==

client -> proxy : ""dispatch target ID + username""
note right
authenticate
end note
proxy -> uaf : ""dispatch target ID + username""
activate uaf
uaf -> fido : Dispatch Token Request
activate fido
fido -> uaf : Dispatch Token Response
deactivate fido
uaf -> uaf : store ""fidoUafSessionId"" in ""session""
uaf -> uaf : isDirectResponse = true
uaf -> proxy : Dispatch Token Response
deactivate uaf
proxy -> client : Dispatch Token Response
client -> client : store ""fidoUafSessionId""

== Token Dispatch ==

fido -> mobileclient : ""token""
deactivate fido
mobileclient -> proxy : ""token""
note left
redeem token
end note
activate fido
proxy -> fido : ""token""
fido -> proxy : ReturnUafRequest(""AuthenticationRequest"")
deactivate fido
proxy -> mobileclient : ReturnUafRequest(""AuthenticationRequest"")

== Authentication Response ==

deactivate fido
mobileclient -> proxy : SendUafResponse(""RegistrationResponse"")
activate fido
proxy -> fido : SendUafResponse(""RegistrationResponse"")
activate fido
fido -> fido : session status = ""succeeded"" / ""failed""
fido -> proxy : ""ServerResponse""
deactivate fido
proxy -> mobileclient : ""ServerResponse""


== Status ==

client -> proxy : ""fidoUafSessionId""
proxy -> uaf : ""o.fidoUafSessionId.v""
activate uaf
uaf -> fido : operation status for ""fidoUafSessionId""
activate fido
fido -> uaf : ""clientAuthenticating"" / ""succeeded"" / ""failed""
deactivate fido
uaf -> uaf : set transition result ""OK"" / ""FAILED"" /""ERROR"" in session
uaf -> uaf : isDirectResponse = true
uaf -> proxy : status
deactivate uaf
proxy -> client : status

== Auth State Transition ==

client -> proxy : ""fidoUafSessionId""
proxy -> uaf : ""o.fidoUafSessionId.v""
activate uaf

uaf -> uaf : get transition result from session

alt transition result ""OK""

uaf -> ok : ResultCond="ok"

activate ok
ok --> proxy
deactivate ok

else transition result ""FAILED"" / ""ERROR""

uaf -> failed
deactivate uaf
activate failed

failed --> proxy
deactivate failed

end

@enduml
```

:::info

To allow chained UAF AuthStates, nevisAuth will remove the stored FIDO UAF session ID every time an AuthState transition occurs in the `OutOfBandFidoUafAuthState`.

As a consequence, the HTTP client will receive the `authenticated` status only once for a given session ID. The next queries with the same session ID will return an `unknown` status.
This is to prevent the following undesired situation:

Suppose a given configuration consists of the two chained UAF AuthStates *AuthState1* and *AuthState2*. If the user authenticates in *AuthState1*, the AuthEngine will make *AuthState2* the current AuthState. If the client sends an authentication status request with the session ID used in *AuthState1*, and the session has not been cleaned up, then the user will be considered authenticated in *AuthState2*.
:::
--------------------------------------------------------------------------------
Section: ### device-service.md
---
sidebar_position: 55
---

import REUSE01 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/request-headers.md'
import REUSE02 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/response-headers.md'
import REUSE03 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/http-request.md'
import REUSE04 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/curl-request.md'
import REUSE05 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device-header-device-signature-as-json.md'
import REUSE06 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/http-response.md'
import REUSE07 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device-decrypted-response.md'

import REUSE11 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/request-headers.md'
import REUSE12 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/request-body.md'
import REUSE13 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/http-request.md'
import REUSE14 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/curl-request.md'
import REUSE15 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets-as-json.md'
import REUSE16 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-delete-credentials-and-dispatch-targets-as-json.md'
import REUSE17 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/http-response.md'

import REUSE21 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device/request-headers.md'
import REUSE22 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device/http-request.md'
import REUSE23 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device/curl-request.md'
import REUSE24 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device-header-device-signature-as-json.md'
import REUSE25 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device/http-response.md'

import REUSE31 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/request-headers.md'
import REUSE32 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/response-headers.md'
import REUSE33 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/http-request.md'
import REUSE34 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/curl-request.md'
import REUSE35 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device-oob-operations-header-device-signature-as-json.md'
import REUSE36 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/http-response.md'
import REUSE37 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device-oob-operations-decrypted-response.md'

# Device Service

This chapter describes the Device Service. The Device Service is **not a standard FIDO service**, but a proprietary nevisFIDO functionality.

:::info
The Device Service is an HTTP API to be used by the [Nevis Mobile Authentication SDK](/mobilesdk), so it is aimed for mobile applications. Other applications, such as administration web applications, should not try to use it. It is presented here for reference.

This service is in **experimental** state and can be modified or dropped in future releases without notice.
:::

:::caution Android SDK 3.6.1 / 3.6.2 device identifier issue

Registrations created with Android SDK [3.6.1](/mobilesdk/release_notes/android-release-notes#android-sdk-361---24012024) and [3.6.2](/mobilesdk/release_notes/android-release-notes#android-sdk-362---19032024) resulted in a non-unique [device identifier](https://docs.nevis.net/mobilesdk/concept/concept-description/device-management#device-identifier).

Due to this, Android SDK 3.7.0 will not query these endpoints for affected users.

Refer to the [issue description](/mobilesdk/appendixes/known-issues#non-unique-device-identifier-android-sdk) for details.

:::

A device represents a mobile device. A mobile device has FIDO UAF credentials and dispatch targets. The Authentication Mobile SDK allows the definition of multiple accounts in a device and thus the FIDO UAF credentials and dispatch targets of a device can be associated with multiple identities.

The Device Service consists of three parts or endpoints: the Get, Modify and Delete Device.

## Get Device Credentials

This section describes the Get Device Credentials part of the Device Service.
--------------------------------------------------------------------------------
Section: ### HTTP Status Codes
The following HTTP status codes are returned by the Create Dispatch Target part/endpoint of the Dispatch Target Service:

| HTTP Code | Description                                                                                                                                                                                                                                  |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 201       | Created   The server successfully created the dispatch target.                                                                                                                                                                            |
| 400       | Bad Request   The provided payload is not properly formatted.                                                                                                                                                                             |
| 401       | Unauthorized   The request was not authorized. There is an invalid SecToken or unresolved username.                                                                                                                                       |
| 403       | Forbidden   The user is not found in the credential repository based on the provided username.        |
| 405       | Method Not Allowed   The method of the received request was not `POST`.                                                                                                                                                                   |
| 406       | Not Acceptable   The `Accept` header is not properly set to `application/json`.                                                                                                                                                           |
| 415       | Unsupported Media Type   The `Content-Type` header is not properly set to `application/json;charset=UTF-8`.                                                                                                                               |
| 422       | Unprocessable Entity   The request could not be processed. For example, because the name of the provided dispatch target is already in use by another dispatch target of the user, or because the specified dispatcher is not configured. |
| 500       | Internal Server Error   The server could not process the request because of an unexpected error.                                                                                                                                          |

## Modify Dispatch Target

This section describes the Modify part of the Dispatch Target Service.

The modify dispatch target HTTP API is particular regarding the approach used to guarantee that the HTTP client is authorized to perform the operation (i.e. to modify the dispatch target). Instead of using authorization headers (containing for instance a `SecToken`) to do the authorization check, the client must send the payload with a signature. This signature is generated with the private signature key of the dispatch target to be modified. nevisFIDO will only process request that are properly signed. This guarantees that only clients possessing the private signature key of the dispatch target are allowed to modify it. This is the reason why the private signature key is assumed to be safely stored by the HTTP client.

:::info
The modify dispatch target HTTP API is intended to be used by the [Nevis Mobile Authentication SDK](/mobilesdk) only, so it is aimed for mobile applications. Other applications, such as administration web applications, should not use it. It is presented here for reference.
:::
--------------------------------------------------------------------------------
Section: ### Server Configuration
The server configuration defines the configuration of the main web server.

* `server.port`

  Web application port. If not specified, the default value is 8080.
* `server.host`

  Network address to which the server must bind. By default, it binds to all available interfaces (that is, "0.0.0.0").

* `server.protocol`

  Either `http` or `https`. It is advisable to always run nevisFIDO in `https` mode. Refer to the `server.tls`
  settings for configuring TLS if set to `https`.

* `sever.connection-timeout`

  The time after which idle connections will be terminated. The default value is 30 seconds. If no time unit is
  provided, seconds will be used.

* `sever.tls.keystore`

  Path to the keystore that holds the TLS certificate of nevisFIDO.

* `sever.tls.keystore-passphrase`

  Password used to access the keystore and the key. Use the mechanisms described
  in [Application Configuration](#application-configuration) to avoid providing a plaintext password.

* `sever.tls.keystore-type`

  Defines the type of keystore. It is recommended using a "pkcs12" type of keystore. If not specified, the system will
  use the default keystore type of the Java Virtual Machine that runs nevisFIDO.

* `sever.tls.key-alias`

  Alias that identifies the key in the keystore.

* `sever.tls.require-client-auth`

  `true` if client authentication (2-way TLS) is required for the TLS connection, `false` if no client authentication is
  required.

* `sever.tls.truststore`

  Path to the truststore that holds the TLS certificates (typically a PKCS12 file) that nevisFIDO trusts. These are the
  certificates presented by the client when doing client authentication.

* `sever.tls.truststore-passphrase`

  Password used to access the truststore contents. Use the mechanisms described
  in [Application Configuration](#application-configuration) to avoid providing a plaintext password.

* `sever.tls.truststore-type`

  Defines the type of truststore. It is recommended using a "pkcs12" type of keystore. If not specified, the system will
  use the default keystore type of the Java Virtual Machine that runs nevisFIDO.

* `sever.tls.supported-protocols`

  Provides a list of protocols that are accepted by the client when trying to initiate a connection with TLS. This
  attribute must be provided as an array. By default only `TLSv1.2` is supported.

* `sever.tls.cipher-suites`

  Provides a list of ciphers that are accepted by the client when trying to initiate a connection with TLS. This
  attribute must be provided as an array. The default cipher suites are:
  * `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
  * `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`
  * `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`
  * `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`
  * `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`
  * `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`

```yaml title="Server configuration example"
server:
  port: 9443
  host: localhost
  protocol: https
  connection-timeout: 30s
  tls:
    keystore: conf/nevisfido-server-keystore.p12
    keystore-passphrase: password
    keystore-type: pkcs12
    key-alias: nevisfido
    supported-protocols:
      - TLSv1.2
    cipher-suites:
      - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
      - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
      - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
      - TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
      - TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
      - TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
```
--------------------------------------------------------------------------------
Section: ### WsEventSource.md
---
sidebar_position: 41
---

# WsEventSource

The `WsEventSource` provides a SOAP web-service API to the event system. The SOAP service is published at a configured endpoint. The service offers the following operations which are used to signal an event:

* void signal(EventData event)
* JobResult synchronousSignal(EventData event) throws JobResult

The WSDL and XML schema needed to invoke the service can be found in the JAR `nevisdp- wsclient.jar`. It also contains Java client stubs to invoke the service.

Optional authentication is handled by means of two-way SSL.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: URL of the endpoint | The URL which is used to publish the service. |
| threads | optional: paraVal<br/>default: 10<br/>type: integer | The number of threads the HTTP server uses to handle client requests. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this HTTP server. It uses the Java system property names to set up the key and trust stores. No SSL is used by default. Two-way SSL is the only way to configure authentication. |
| raiseFault | optional: paraVal<br/>default: none<br/>type: boolean | Instead of returning JobResult on the synchronousSignal call, raise a SOAP fault if an error occurs. |

## Example

Register a SOAP web-service at the URL `http://localhost:1234/nevisdp/ws`.

```
<eventSource name="wsEvents" type="WsEventSource">
    <dp:paraVal name="endpoint" value="http://localhost:1234/nevisdp/ws" />
</eventSource>

```
--------------------------------------------------------------------------------
Section: ### RsEventSource.md
---
sidebar_position: 39
---

# RsEventSource

The `RsEventSource` provides a RESTful web-service API to the event system. The REST service is published at a configured endpoint and offers several service interfaces for event generation:

* `/data`: The data interface consumes XML-based events when invoked with a POST operation.

```
POST /nevisdp/event/data HTTP/1.0
Content-Type: application/xml

<eventData>
    <data>
        <name>key1</name>
        <value>value1</value>Y
    </data>
    <data>
        <name>key1</name>
        <value>value1</value>Y
    </data>
</eventData>
```

* `/query`: The query interface uses the URL's query parameter to create an event when invoked with the POST operation.

```
POST /nevisdp/event/query?key1=value1&key2=value2 HTTP/1.0
```

Authentication is handled by means of two-way SSL.

If the result of the triggered jobs is of interest, the WS can be invoked in a synchronous mode by including the matrix parameter „sync" in the URL:

```
POST /nevisdp/event/data;sync=true HTTP/1.0
POST /nevisdp/event/query;sync=true?key1=value1&key2=value2 HTTP/1.0
```

* `/xml`: The xml interface consumes arbitrary XML documents. For every call an event is generated. Data is extracted using X-path expressions.

```
POST /nevisdp/event/xml HTTP/1.0
Content-Type: application/xml

<user>
 <name>Mustermann</name>
 <firstName>Hans</firstName>
</user>
```

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: URL of the endpoint | The URL which is used to create the service. |
| threads | optional: paraVal<br/>default: 10<br/>type: integer | The number of threads the HTTP server uses to handle client requests. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this HTTP  server. It uses the Java system property names to set up the key and trust stores. |
| data | optional: paraMap<br/>default: none<br/>type: string/xpath | Only required when using the XML endpoint. Defines the event's data fields using XPath queries. The current node in the XPath queries is the document root received through the xml endpoint. |
| xpathNamespaces | optional: paraMap<br/>default: none<br/>type: string/string (uri) | Register namespace prefixes to the specified URIs. Those prefixes are used to parse the XPath expressions. The URIs specified have to match the URIs in the XML document. |

## Example

Register a RESTful web-service at URLs:

* `http://localhost:1234/nevisdp/rs/data`
* `http://localhost:1234/nevisdp/rs/query`

```
<eventSource name="rsEvents" type="RsEventSource">
 <dp:paraVal name="endpoint" value="http://localhost:1234/nevisdp/rs" />
</eventSource>
```
--------------------------------------------------------------------------------
Section: ### SoapEventSource.md
---
sidebar_position: 40
---

# SoapEventSource

The `SoapEventSource` provides a SOAP web service API for the event system. The SOAP service provider is published at a configured endpoint and listens for SOAP messages. XPath queries are used to map the incoming message data to the generated event data.

Authentication is handled by means of two-way SSL.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: URL of the endpoint | The URL which is used to create the service. |
| threads | optional: paraVal<br/>default: 10<br/>type: integer | The number of threads the HTTP server uses to handle client requests. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this HTTP server. It uses the Java system property names to set up the key and trust stores. |
| data | required: paraMap<br/>default: none<br/>type: string/xpath | Defines the event's data fields using XPath queries. The current node in the XPath queries is the SOAP message's body. |
| synchronous | optional: paraVal<br/>default: false<br/>type: boolean | Defines whether the SoapEventSource runs in synchronous mode, i.e. returns the result of the triggered jobs. |
| xpathNamespaces | optional: paraMap<br/>default: none<br/>type: string/string (uri) | Register namespace prefixes to the specified URIs. Those prefixes are used to parse the XPath expressions. The URIs specified have to match the URIs in the XML document. |

## Example

Register a SOAP web service at URL

* `http://localhost:1234/nevisdp/soap`

Process message bodies of type:

```
<person id="someId">
    <name>First Last</name>
    <email>mail@domain.com</email>
</person>

<eventSource name="soapEvents" type="SoapEventSource">
    <dp:paraVal name="endpoint" value="http://localhost:1234/nevisdp/soap" />
    <dp:paraMap name="data">
        <value name="id" value="./person/@id" /> (mailto:@id)
        <value name="name" value="./person/name/text()" />
        <value name="email" value="./person/email/text()" />
    </dp:paraMap>
</eventSource>
```
--------------------------------------------------------------------------------
Section: ### NevisIDMConnectionPool.md
---
sidebar_position: 80
---

# NevisIDMConnectionPool

The `NevisIDMConnectionPool` provides access to the NevisIDM administration web service and is used by `NevisIDMSource` and `NevisIDMSink`. It supports three modes of authentication:

* Basic authentication uses basic HTTP authentication with a username and password.
* Client certificate authentication uses a client certification to authenticate for nevisIDM using nevisProxy.
* Ninja authentication uses the Nevis sectoken as credential to access the nevisIDM web services.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: connection url | The connection URL pointing to the administration web service of nevisIDM. |
| wstrustEndpoint | optional: paraVal<br/>default: none<br/>type: connection url | The connection URL pointing to the `wstrust` web services of nevisAuth. |
| loginMode | required: paraVal<br/>default: none<br/>type: login-mode string | The login-mode determines the kind of authentication the pool uses:<br/>`basic`: Use basic HTTP authentication.<br/>`proxyCert`: Use a client certificate and nevisProxy.<br/>`ninja`: Use a Nevis sectoken.  |
| username | optional: paraVal<br/>default: none<br/>type: string | The username used for basic authentication. |
| password | optional: paraVal<br/>default: none<br/>type: string<br/>sensitive: true | The password used for basic authentication. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key- and truststores. |
| wstrustSslSettings | optional: paraMap<br/>default: none<br/>type: connection url | The SSL configuration settings used to perform two-way SSL authentication with the `wstrust` endpoint.  It uses the Java system property names to set up the key and trust stores. |

## Examples
--------------------------------------------------------------------------------
Section: ### SmtpConnectionPool.md
---
sidebar_position: 81
---

# SmtpConnectionPool

The `SmtpConnectionPool` is used to define and configure an SMTP mail server. It is used by the `EmailDataSink` to send e-mail messages.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| connectionUrl | required: paraVal<br/>default: none<br/>type: smtp(s) URL | The URL defining the server's hostname and port. For example: `<smtp://hostname:25>` or `<smtps://hostname:465>`. |
| username | optional: paraVal<br/>default: none<br/>type: string | The username used to authenticate with the SMTP server. |
| password | optional: paraVal<br/>default: none<br/>type: string<br/>sensitive: true | The password used to authenticate with the SMTP server. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key and trust stores. |

## Example

Example using an unencrypted connection:

```
<object type="SmtpConnectionPool" name="mailService">
    <dp:paraVal name="connectionUrl" value="smtp://myhost.ch:25"/>
</object>
```

Example using an SSL connection:

```
<object type="SmtpConnectionPool" name="mailService">
    <dp:paraVal name="connectionUrl" value="smtps://localhost:465"/>
    <dp:paraVal name="username" value="mail-user"/>
    <dp:paraVal name="password" value="secret"/>
    <dp:paraMap name="sslSettings">
        <value name="javax.net.ssl.trustStore" value="truststore.jks"/>
        <value name="javax.net.ssl.trustStorePassword" value="secret"/>
        <value name="javax.net.ssl.trustStoreType" value="jks"/>
    </dp:paraMap>
</object

```
--------------------------------------------------------------------------------
Section: ### HttpConnectionPool.md
---
sidebar_position: 83
---

# HttpConnectionPool

The `HttpConnectionPool` is an HTTP/1.1 compliant HTTP agent implementation based on the Apache HTTP Client. It is, for example, used to connect to the `NevisAgent`. It implements the `org.apache.http.client.HttpClient` interface.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| poolSize | optional: paraVal<br/>default: 8<br/>type: integer | The size of the connection pool. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key and trust stores. |
| proxySettings | optional: paraMap<br/>default: none<br/>type: string/string | The proxy settings used for the HTTP connection. The following values have to be provided: `http.proxyHost`: The hostname of the proxy server; `http.proxyPort`: The port number of the proxy server.  |

## Example

Example configuring an SSL connection:

```
<object type="HttpConnectionPool" name="httpConnection">
    <dp:paraMap name="sslSettings">
        <value name="javax.net.ssl.trustStore" value="truststore.jks"/>
        <value name="javax.net.ssl.trustStorePassword" value="secret"/>
        <value name="javax.net.ssl.trustStoreType" value="jks"/>
        <value name="javax.net.ssl.keyStore" value="keystore.jks"/>
        <value name="javax.net.ssl.keyStorePassword" value="secret"/>
        <value name="javax.net.ssl.keyStoreType" value="jks"/>
    </dp:paraMap>
    <dp:paraVal name="poolSize" value="10"/>
</object>
```

Example configuring of an HTTP proxy:

```
<object type="HttpConnectionPool" name="httpConnection">
    <dp:paraMap name="proxySettings">
        <value name="http.proxyHost" value="proxy.domain.com"/>
        <value name="http.proxyPort" value="3128"/>
    </dp:paraMap>
</object>
```
--------------------------------------------------------------------------------
Section: ### LDAPConnectionPool.md
---
sidebar_position: 79
---

# LDAPConnectionPool

The `LDAPConnectionPool` provides LDAP connections for `DataSource` and/or `DataSink` implementations that need access to databases. It implements the `LdapContextProvider` interface which is used to access an `javax.naming.ldap.LdapContext`. The latter is responsible for connection pooling. Connection pooling of the JDK is used. See [here](http://java.sun.com/products/jndi/tutorial/ldap/connect/pool.html).

Currently, the default connection pooling configuration from the JDK is used. There is no other way than using system properties to configure the sizing of the connection pooling.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| connectionUrl | required: paraVal<br/>default: none<br/>type: connection url starting with`ldaps?://` | The connection URL to be passed to establish a connection. |
| username | optional: paraVal<br/>default: none<br/>type: string | The username DN to be passed to establish a bind. |
| password | optional: paraVal<br/>default: none<br/>type: string<br/>sensitive: true | The binding password to be passed to establish a connection. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key and trust stores. |
| connectionProperties | optional: paraMap<br/>default: none<br/>type: name value pairs | Adds a custom property to the environment of the `InitialLdapContext`. This feature can be used to set, for example, timeout properties. |
| retry | optional: paraVal<br/>default: 5<br/>type: integer | The number of retry attempts the connection pool carried out when a connection cannot be established. |
| retryInterval | optional: paraVal<br/>default: 5<br/>type: integer | The number of seconds between connection trials. |

## Example

Example using an unencrypted connection:

```
<object type="LDAPConnectionPool" name="ldapConnection">
    <dp:paraVal name="connectionUrl" value="ldap://localhost:10389"/>
    <dp:paraVal name="username" value="uid=admin,ou=system"/>
    <dp:paraVal name="password" value="secret"/>
</object>
```

Example using an SSL connection:

```
<object type="LDAPConnectionPool" name="ldapConnection">
    <dp:paraVal name="connectionUrl" value="ldap://localhost:10389"/>
    <dp:paraVal name="username" value="uid=admin,ou=system"/>
    <dp:paraVal name="password" value="secret"/>
    <dp:paraMap name="sslSettings">
        <value name="javax.net.ssl.trustStore" value="truststore.jks"/>
        <value name="javax.net.ssl.trustStorePassword" value="secret"/>
        <value name="javax.net.ssl.trustStoreType" value="jks"/>
    </dp:paraMap>
</object>
```
--------------------------------------------------------------------------------
Section: ### SoapConnectionPool.md
---
sidebar_position: 82
---

# SoapConnectionPool

The `SoapConnectionPool` is used to define a SOAP web service endpoint. It creates a SOAP dispatcher using an endpoint URL, a web service qualified name and a port qualified name.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: http URL | The endpoint URL of the web service. |
| serviceName | required: paraVal<br/>default: none<br/>type: QName | The qualified name of the web service. |
| portName | required: paraVal<br/>default: none<br/>type: QName | The qualified name of the web service's port. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key and trust stores. |
| soapVersion | optional: paraVal<br/>default: none<br/>type: QName | The version of the SOAP binding that shall be used. Supported are 1.1 and 1.2. |
| username | optional: paraVal<br/>default: none<br/>type: QName | The username used in the HTTP basic authentication scheme. |
| password | optional: paraVal<br/>default: none<br/>type: string<br/>sensitive: true | The password used in the HTTP basic authentication scheme. If omitted, the username is used as a password instead. |
| sessionMaintain | optional: paraVal<br/>default: true<br/>type: boolean | A Boolean value indicating whether the SOAP connection shall maintain a session and store session cookies. |

## Example
--------------------------------------------------------------------------------
Section: ### Repositories.md
---
sidebar_position: 15
---

# Repositories

All runtime data in the nevisDataPorter is stored in *repositories*. A repository is reminiscent of a scope, e.g., page, request or session known in web applications. Each repository has a unique *name*. The name of the repository and the name of the data item can be used to access any data from within the XML-configuration using the unified expression language specified as part of the JSP 2.1 standard (JSR-245).

The following table gives a short overview of the existing repositories in use.

| Repository | Name | Description |
| --- | --- | --- |
| Configuration | cfg | Contains all variables defined in the configuration section and all configuration values passed programmatically during the intialization. |
| Runtime configuration | rtCfg | Contains all variables passed programmatically or through the event system during the export of a module. |
| Implementation (plug-in factories) | impl | Internal data repository which is generally not used in configurations. Contains factories which are used to create instances of concrete DataObjects, DataSources, DataFilters and DataSinks. |
| Instance (plug-in instances) | inst | Contains all objects instantiated in any initialization section and all instances which are registered programmatically. |
| Input (data) | in | Contains objects returned from a DataSource. The name is derived from the name of the embedding entity. |
| Output (result objects) | out | Contains objects which have to be exported by a DataSink. The name is derived from the name of the embedding entity. |
| Control (control objects) | ctl | Contains objects which contain control information which can be consumed be any DataFilter in the chain or the DataSink. The name is derived from the name of the embedding entity. |
| Constants | const | Contains constants defined by nevisDataPorter. E.g., the NULL object which is used to have an explicit representation of null. |

In the following chapters some of the repositories are explained in more detail.

## Configuration repository

All variables defined in the configuration section (see Configuration Overview) are put into the configuration repository. Plug-ins can reference these configuration variables. You can also pass configuration variables programmatically from within your application when calling the initial method of the DataPorter object. This allows to parameterize your configuration file. All values passed at the intialization phase are additionally stored in the configuration repository ("cfg"). Values received in the export phase, e.g., from the event system, are stored in the runtime-configuration repository ("rtCfg").

## Implementation repository

All implementations of DataObject, DataSource, DataFilter, DataSink and EventSource are registered programmatically at the implementation repository under a unique name. In the configuration file these names are used to refer to the respective factory. nevisDataPorter uses the configured name to retrieve the corresponding factory from the implementation. This factory is used to create new instances of a given plug-in.

The following configuration fragment shows how the name "LDAPDataSink" is used to create the built-in DataSink to access an LDAP directory.

```
<dataSink type="LDAPDataSink">
    <dp:paraVal name="ldapContext"   value="${inst.initalContext}"/>
    <dp:paraVal name="operation"     value="createOrUpdate"/>
    <dp:paraVal name="basedn"        value="ou=${cfg.appl_ou},${cfg.basedn}"/>
    <dp:paraVal name="rdn"           value="cn=#{in.appl.RESOURCENAME}"/>
</dataSink>
```

Plug-ins can be registered in the configuration file in the setup section.

```
<setup>
    <factory class="ch.nevis.idm.dataporter.factory.NevisIDMConnectionPoolFactory"/>
    <factory class="ch.nevis.idm.dataporter.factory.NevisIDMSourceFactory"/>
    <factory class="ch.nevis.idm.dataporter.factory.NevisIDMSinkFactory"/>
    <dataFunction class="ch.nevis.idm.dataporter.NevisIDMDataFunctions"/>
</setup>
```

Here, the specified class has to implement a Factory interface and has to provide a public parameter- less constructor.

In addition, plug-ins can be registered programmatically with nevisDataPorter by registering a factory using the `registerInstanceFactory(Factoryfactory)` method. The interface Factory defines two methods. The first method returns a description of the plug-in, the second creates a new instance using the passed configuration. The description returned by the first method contains the previously mentioned implementation name, the plug-in type and all its possible and mandatory configuration parameters including their types and possible values.

## Instance repository

Next to the implementation repository there is an instance repository. All the DataObjects that are defined in the global or local initialization sections are automatically registered at the instance repository under the configured names.

The following configuration fragment shows the definition of a JDBC connection pool and can be placed in any initialization section.

```
<object type="JDBCConnectionPool" name="dataSource">
    <dp:paraVal name="connectionUrl"     value="jdbc:oracle:thin:@hispano:49185:ESAU"/>
    <dp:paraVal name="username"          value="system"/>
    <dp:paraVal name="password"          value="managed"/>
    <dp:paraVal name="driver"            value="oracle.jdbc.OracleDriver"/>
</object>
```

Now we can reference the instance dataSource from the example above. The following configuration fragment shows how the previously instantiated JDBCDataSource can be accessed from an the instance repository.

```
<dataSource type="JDBCDataSource">
    <dp:paraVal name="query"         value="select name from application where name in (#?)"/>
    <dp:paraVal name="datasource"    value="${inst.dataSource}"/>
    <dp:paraVal name="parameter"     value="${cfg.appl_list}" separator=","/>
</dataSource>
```

A nevisDataPorter client can programmatically register concrete plug-in instances by using the registerInstance method. E.g., if you run within an application server you may have a javax.sql.DataSource in your JNDI tree which you want to register at the nevisDataPorter so you can use it for all your JDBCDataSource objects.

## Input-, output- and control repository

Each entity in a module has its unique name. The input-, output- and control repositories contain records with names identical to the entity currently in process. Thus the input-, output- and control repositories are related to each other.

Each record returned from the DataSource is stored by nevisDataPorter in the input repository under the name of the embedding entity. The input repository is cleared from all data before the new data is written into it. In the output and control repositories, corresponding identically named empty records are created. Then the DataFilter chain is processed.

A DataFilter may access source records from the input repository or variables from the configuration repository to create attributes on the destination objects or values on the control object.

```
<dataFilter type="ELMappingFilter">
<dp:attrVal name="objectClass"   value="top group" separator=" "/>
<dp:attrVal name="cn"            value="#{in.appl.name}"/>
<dp:attrVal name="description"   value="#{cfg.description}"/>
</dataFilter>
```

In the example shown above, three attributes are created on the target object: The attribute *objectClass* is set to a list containing the values "top" and "group". This is configured in a static way, i.e. the two values are read directly from the configuration file. The second attribute is the most common case. The attribute *cn* is written to the value of the attribute *name* in the input data object. As the current entity is named "appl" in the example (data not shown), the entity is selected in the input repository through the sub-expression "in.appl". The third attribute *description* is set to the value of the attribute *description* stored in the configuration repository ("cfg").

At the end the DataSink exports the destination object to the target system. The records in the control repository are used to pass control messages along the execution path while the records in the output repository hold destination objects to be exported.
--------------------------------------------------------------------------------
Section: ### authentication.md
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import AccountSelector from './account-selector.md'
import AuthenticatorSelector from './authenticator-selector.md'
import PinUserVerifier from './pin-user-verifier.md'
import PasswordUserVerifier from './password-user-verifier.md'
import BiometricUserVerifier from './biometric-user-verifier.md'
import DevicePasscodeUserVerifier from './device-passcode-user-verifier.md'
import FingerprintUserVerifier from './fingerprint-user-verifier.md'

# Authentication

Using the [authentication operation](../../concept/operations/authentication.md), you can verify the identity of the user using an already [registered](registration.md) authenticator.

:::tip
To do an authentication operation, [configure](../configuration.md) and [initialize](../initialization.md) the SDK to obtain a `MobileAuthenticationClient` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/MobileAuthenticationClient.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/mobileauthenticationclient), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmamobileauthenticationclient), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/MobileAuthenticationClient-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/interfaces/MobileAuthenticationClient.html)</sub>.
:::

Depending on the use case, there are two types of authentication: [in-app authentication](#in-app-authentication) and [out-of-band authentication](#out-of-band-authentication).

For more information, see [Authentication](../../concept/operations/authentication.md).

## In-app authentication

For the application to trigger the authentication, provide the name of the user to authenticate to an `Authentication` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/Authentication.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/authentication), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaauthentication), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/Authentication-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/Authentication.html)</sub>, and trigger an in-app authentication.

:::info
In Authentication Cloud, the name is the technical username, that is, the `userId` attribute of the [Authentication Cloud API](/authcloud/api-doc/api-reference/approval-ref).

The `LocalData.accounts` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/localdata/LocalData.html#accounts()), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/localdata/accounts), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmalocaldata/accounts), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/LocalData/accounts.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/LocalData.html#accounts)</sub> method can be used to get the registered accounts, and the `Account.username()` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/localdata/Account.html#username()), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/account/username), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaaccount/username), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/Account/username.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/Account.html#username)</sub> method to get the user name of each account.

:::

Provide an [authenticator selector](#authenticator-selector), which returns the authenticator to be used.

Depending on the authenticator used to authenticate, provide any of the corresponding user verifiers: [PIN user verifier](#pin-user-verifier), [password user verifier](#password-user-verifier), [biometric user verifier](#biometric-user-verifier), [device passcode user verifier](#device-passcode-user-verifier), or [fingerprint user verifier](#fingerprint-user-verifier).

<Tabs groupId="code-snippets">

  <TabItem value="kotlin" label="Android/Kotlin" default>

  ```kotlin title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/DefaultAuthenticationTest.kt
  ```

  </TabItem>

  <TabItem value="java" label="Android/Java">

  ```java title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/DefaultAuthenticationTest.java
  ```

  </TabItem>

  <TabItem value="swift" label="iOS/Swift">

  ```swift title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/AuthenticationTests.swift
  ```

  </TabItem>

  <TabItem value="objective-c" label="iOS/Objective-C">

  ```objectivec title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/NMAAuthenticationTests.m
  ```

  </TabItem>

  <TabItem value="dart" label="Flutter/Dart">

  ```dart title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/authentication_test.dart
  ```

  </TabItem>

  <TabItem value="typescript" label="React Native/TypeScript">

  ```typescript title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/Authentication.test.tsx
  ```

  </TabItem>

</Tabs>

## Out-of-band authentication

When the authentication is initiated in another device or application, the information required to process the operation is transmitted through a QR code or a link. An example of out-of-band authentication is the case where the user wants to do a bank transfer using a web application in a laptop, and the server sends a push notification to the application asking for authentication.

The out-of-band authentication is done in three phases:

1. The payload obtained from the QR code or the link is provided to an `OutOfBandPayloadDecode` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/outofband/OutOfBandPayloadDecode.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/outofbandpayloaddecode), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaoutofbandpayloaddecode), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/OutOfBandPayloadDecode-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/OutOfBandPayloadDecode.html)</sub> to obtain an `OutOfBandPayload` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/outofband/OutOfBandPayload.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/outofbandpayload), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaoutofbandpayload), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/OutOfBandPayload-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/OutOfBandPayload.html)</sub> object. The payload to be provided is of type:

```json
{
    "nma_data" : {
        "token" : "b4b07559-f934-4597-a1c5-44d89f691e8f",
        "redeem_url" : "https://fido.siven.ch/nevisfido/token/redeem/authentication"
    },
    "nma_data_content_type" : "application/json",
    "nma_data_version" : "1"
}
```

For more information on how to obtain the `OutOfBandPayload`, see [Obtain an out-of-band payload](other-operations.md#obtain-an-out-of-band-payload).

2. Provide the `OutOfBandPayload` to an `OutOfBandOperation` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/outofband/OutOfBandOperation.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/outofbandoperation), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaoutofbandoperation), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/OutOfBandOperation-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/OutOfBandOperation.html)</sub>. When building the `OutOfBandOperation`, invoke the `OutOfBandOperation.onAuthentication` method with an object taking an `OutOfBandAuthentication`.

3. Invoke `OutOfBandOperation.execute`. If the provided payload is successfully redeemed in the server, and it corresponds to an authentication, the object provided in `OutOfBandOperation.onAuthentication` is invoked with an `OutOfBandAuthentication` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/outofband/OutOfBandAuthentication.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/outofbandauthentication), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaoutofbandauthentication), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/OutOfBandAuthentication-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/OutOfBandAuthentication.html)</sub>.

4. Provide an [authenticator selector](#authenticator-selector), and the required user verifiers to the `OutOfBandAuthentication`.

5. Invoke `OutOfBandAuthentication.execute` to continue with the operation.

<Tabs groupId="code-snippets">

  <TabItem value="kotlin" label="Android/Kotlin" default>

  ```kotlin title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/DefaultOutOfBandAuthenticationTest.kt
  ```

  </TabItem>

  <TabItem value="java" label="Android/Java">

  ```java title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/DefaultOutOfBandAuthenticationTest.java
  ```

  </TabItem>

  <TabItem value="swift" label="iOS/Swift">

  ```swift title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/OutOfBandOperationTests.swift
  ```

  </TabItem>

  <TabItem value="objective-c" label="iOS/Objective-C">

  ```objectivec title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/NMAOutOfBandOperationTests.m
  ```

  </TabItem>

  <TabItem value="dart" label="Flutter/Dart">

  ```dart title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/out_of_band_operation_test.dart
  ```

  </TabItem>

  <TabItem value="typescript" label="React Native/TypeScript">

  ```typescript title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/OutOfBandOperation.test.tsx
  ```

  </TabItem>

</Tabs>
--------------------------------------------------------------------------------
Section: ### Breaking Changes
The API is backwards compatible with the previous 3.x versions, but there are some breaking changes that affect how to use the SDK to build your application using the `release` flavor:

* You must copy a binary in the machine building the application and set the `FINALIZE_ANDROID_ROOT` to point to the directory where the binary is copied.
* The name of the finalization JAR file has changed.

See the [Android installation](../guide/installation/android-installation.md) for details.

## Android SDK 3.5.1 - 17.11.2023

* FIXED: We fixed an issue which caused improper authorization cookies being returned by the SDK in case the Accounts were registered against multiple backends (NEVISACCESSAPP-5386).

## Android SDK 3.5.0 - 09.10.2023

* FIXED: The SDK relies on the system CA certificates to validate the server certificate and is strict doing hostname validation. (NEVISACCESSAPP-5210)
* FIXED: The user interaction timeout is not triggered during PIN authentication if the authenticator is in cool down mode. (NEVISACCESSAPP-5225)
--------------------------------------------------------------------------------
Section: ### In-app authentication
After registration, the user is able to authenticate in-app using FIDO UAF-based authentication. First, the mobile application initiates the authentication flow by contacting the backend. This is usually done through a custom backend, such as a custom application or API gateway.

```plantuml

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  borderColor #CDD2D4
  backgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

title Authentication Cloud In-App Authentication

legend right

<color:BF3666><size:24><&arrow-right></size>Custom Implementation</color>
<color:168CA9><size:24><&arrow-right></size>Nevis APIs</color>

end legend

actor User as user

box "Mobile Device"
    participant "Mobile Application" as mobile  #499985
    participant "Nevis SDK" as sdk
end box

participant "Custom Backend" as backend  #499985
participant "Nevis Authentication Cloud" as api


user -[#BF3666]> mobile++: authenticate
group <color:168CA9>&#8505;</color> See Developer Guide <b>Operations - Authentication</b>
autonumber
mobile -> sdk++: ""client.operations().authentication()""
autonumber stop
sdk -> api++: ""uaf/1.1/request/authentication""
api --> sdk--: UafRequest
sdk -> api++: ""/_app/uaf/1.1/facets""
api --> sdk--: trusted facets
sdk -> mobile: request authentication information
mobile -> user: request authentication information
user -> mobile: provide authentication information
mobile -> sdk: provide authentication information
sdk -> api++: ""/_app/uaf/1.1/authentication""
hnote over api
  Process FIDO UAF authentication
end note
api --> sdk--: ok (JWT token)
sdk -> mobile--: ""onSuccess(JWT token)""
end group
mobile -[#BF3666]> backend++: verify authentication (JWT token)
autonumber resume
backend -[#BF3666]> api++: ""/api/v1/introspect (JWT token)""
autonumber stop
api -> backend--: status ""active=true""
hnote over backend
  verify and complete authentication 
  on your backend
end hnote
backend -[#BF3666]> mobile--: user authenticated <color:#499985><&check></color>
mobile -[#BF3666]> user: user authenticated <color:#499985><&check></color>
mobile -[#BF3666]> backend--: perform authenticated operations
```

1. You use the SDKs [authentication operation](guide/operation/authentication#in-app-authentication) to start the authentication process. The process will involve asking the user to provide biometric, PIN or device passcode authentication information.
2. After a successful authentication, the SDK will return a `JWT`. To validate the token, call the [`api/v1/introspect` endpoint](/authcloud/api-doc/api-reference/introspect-ref).

:::tip

* Concept

  For more information regarding the registration concept, see the [SDK Concept Guide](concept/operations/authentication#in-band-authentication) chapter.

* Mobile SDK Developers

  For hands-on information on how to use the SDK to achieve in-app authentication, see the [Developer Guides Operations](../guide/operation/authentication.md#in-app-authentication) chapter.

* Authentication Cloud API

  For more information regarding the Authentication Cloud API, visit [Authenticate transactions with QR code or deep link](/authcloud/api-doc/api-use-cases/mobile-app/authenticate-QR-code) or [Authenticate transactions with push notification](/authcloud/api-doc/api-use-cases/mobile-app/authenticate-push)

* Authentication Cloud Concept

  For more information about available authentication methods, visit the [Authentication methods comparison](/authcloud/authentication-methods) chapter.

:::

## Out-of-band registration

```plantuml
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  borderColor #CDD2D4
  backgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

title Authentication Cloud Out-Of-Band Registration

legend right

<color:BF3666><size:24><&arrow-right></size>Custom Implementation</color>
<color:168CA9><size:24><&arrow-right></size>Nevis APIs</color>

end legend

actor User as user

participant  "PC/Laptop" as pc #499985

box "Mobile Device"
    participant "Mobile Application" as mobile #499985
    participant "Nevis SDK" as sdk
end box

participant "Custom Backend" as backend  #499985
participant "Nevis Authentication Cloud" as api

user -[#BF3666]> pc++: authenticate
pc -[#BF3666]> backend++: authenticate
user -[#BF3666]> pc: register device
pc -[#BF3666]> backend: register

autonumber
backend -[#BF3666]> api++: ""/api/v1/users/enroll""
hnote over api
  Initiate out-of-band registration
  to obtain the token required for
  processing the FIDO UAF registration
end hnote

api --> backend--: enroll response (""enrollment.appLinkUri"", ""enrollment.statusToken"")
backend --[#BF3666]> pc--: render QR code / link
autonumber stop

loop
  pc -[#BF3666]> backend++: poll  
  autonumber resume
  backend -[#BF3666]> api++: ""/api/v1/status (statusToken)""  
  api --> backend--: status ""pending""
  autonumber stop
  backend --[#BF3666]> pc--: waiting  
end loop

user -[#BF3666]> mobile++: open app
user -[#BF3666]> mobile: scan QR Code

group <color:168CA9>&#8505;</color> See Developer Guide <b>Operations - Registration</b>

autonumber resume
mobile -> sdk++: ""operations().outOfBandOperation().onRegistration()""
autonumber stop
sdk -> api++: ""_app/token/redeem/registration""
hnote over api
  Initiate device registration based
  on the obtained token
end hnote
api --> sdk--: UafRequest

sdk -> api++: ""/_app/uaf/1.1/facets""
api --> sdk--: trusted facets

sdk -> mobile: request registration information
mobile -> user: request registration information
user -> mobile: provide registration information
mobile -> sdk: provide registration information
sdk -> api++: ""/_app/uaf/1.1/registration""
hnote over api
  Complete device registration
end hnote
api --> sdk--: ok
sdk -> mobile--: onSuccess()
end group
mobile -[#BF3666]> user--: user registered <color:#499985><&check></color>

loop
  pc -[#BF3666]> backend++: poll  
  backend -[#BF3666]> api++: ""/api/v1/status""
  autonumber resume    
  api --> backend--: status ""succeeded""
  autonumber stop
  backend --[#BF3666]> pc: device registered <color:#499985><&check></color>  
end loop

```

1. The first HTTP API call to the cloud backend is done against the [`api/v1/users/enroll` endpoint](/authcloud/api-doc/api-reference/registration-ref). This endpoint is usually called by another backend application, for example a custom backend to start a user enrollment. The user enrolment is necessary to create the user in the backend before an actual mobile authentication registration can be performed.
2. The Nevis Authentication cloud returns the enroll response to your backend. The `enrollment.appLinkUri` contains the link required for the registration process. The `enrollment.statusToken` can be used to check the enrollment progress.
3. The `appLinkUri` link can be displayed to the user as clickable link in cases the user operates on a mobile device or rendered in a QR code to allow the user to scan the code using the mobile application or the mobile phones' camera app.
4. The `statusToken` obtained in step 2 is used to poll the Nevis Authentication cloud backend using the [`/api/v1/status` endpoint](/authcloud/api-doc/api-reference/status-ref). By polling the status, your custom backend and web application will be able to determine when the registration was completed successfully and proceed afterwards with your scenario, like showing the user a success message or redirecting them.
5. During an ongoing registration, the status API will return `pending`, indicating that the registration has not been completed yet and has not failed so far.
6. You use the SDKs [out of band registration operation](../guide/operation/registration.md#out-of-band-registration) to start the actual registration process. The process will involve asking the user to provide biometric, PIN or device passcode authentication information. The SDK requires the `appLinkUri` for this, which the app needs to pass after the link has been clicked or the QR code scanned.
7. After the user completed the out-of-band registration in the mobile application, the [`/api/v1/status` endpoint](/authcloud/api-doc/api-reference/status-ref) will return `succeeded` allowing your custom backend and the web application to detect the successful enrollment.

:::tip

* Concept

  For more information regarding the registration concept, see the [SDK Concept Guide](concept/operations/registration#out-of-band-registration) chapter.

* Mobile SDK Developers

  For hands-on information on how to use the SDK to achieve out-of-band registration, see the [Developer Guides Operations](../guide/operation/registration.md#out-of-band-registration) chapter.

* Authentication Cloud API

  For more information regarding the Authentication Cloud API, visit [Register your mobile app](/authcloud/api-doc/api-use-cases/mobile-app/register-mobile-app).

:::

## Out-of-band authentication

```plantuml
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  borderColor #CDD2D4
  backgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

title Authentication Cloud Out-Of-Band Authentication

legend right

<color:BF3666><size:24><&arrow-right></size>Custom Implementation</color>
<color:168CA9><size:24><&arrow-right></size>Nevis APIs</color>

end legend

actor User as user

participant  "PC/Laptop" as pc #499985

box "Mobile Device"
    participant "Mobile Application" as mobile #499985
    participant "Nevis SDK" as sdk
end box

participant "Custom Backend" as backend  #499985
participant "Nevis Authentication Cloud" as api


user -[#BF3666]> pc++: authenticate
pc -[#BF3666]> backend++: authenticate
autonumber
backend -[#BF3666]> api++: ""/api/v1/approval"" (channel=app)
hnote over api
  Initiate out-of-band authentication
  to obtain the token required for
  processing the FIDO UAF registration
end note

api --> backend--: approval response (""qrCode"", ""appLinkUri"")
backend --[#BF3666]> pc--: render ""qrCode"" or ""appLinkUri""
autonumber stop

loop
  pc -[#BF3666]> backend++: poll
  autonumber resume
  backend -[#BF3666]> api++: ""/api/v1/status""    
  api --> backend--: status ""pending""  
  autonumber stop
  backend --[#BF3666]> pc--: waiting  
end loop

user -[#BF3666]> mobile++: open app
user -[#BF3666]> mobile: scan QR Code
group <color:168CA9>&#8505;</color> See Developer Guide <b>Operations - Authentication</b>
autonumber resume
mobile -> sdk++: ""operations().outOfBandOperation().onAuthentication()""
autonumber stop
sdk -> api++: ""_app/token/redeem/authentication""
hnote over api
  Initiate device authentication based
  on the obtained token
end hnote
api --> sdk--: UafRequest
sdk -> api++: ""/_app/uaf/1.1/facets""
api --> sdk--: trusted facets
sdk -> mobile: request authentication information
mobile -> user: request authentication information
user -> mobile: provide authentication information
mobile -> sdk: provide authentication information
sdk -> api++: ""/_app/uaf/1.1/authentication""
hnote over api
  Complete device authentication
end hnote
api --> sdk--: ok
sdk -> mobile--: onSuccess()
end group
mobile -[#BF3666]> user--: user authenticated <&check>

autonumber resume
backend -[#BF3666]> api++: ""/api/v1/introspect (statusToken)""
autonumber stop
api -> backend--: ""active=true""
backend --[#BF3666]> pc: authentication successful  <color:#499985><&check></color>
backend--

```

1. The first HTTP API call to the cloud backend is done against the [`api/v1/users/approval` endpoint](/authcloud/api-doc/api-reference/approval-ref). This endpoint is usually called by another backend application, for example a custom backend to start a user authentication. The `channel` defines how the message should be transmitted.
2. The Nevis Authentication cloud returns the approval response to your backend. The `appLinkUri` contains the link required for the authentication process. THe `qrCode` contains a base64 encoded image which can be rendered. The `statusToken` can be used to check the enrollment progress.
3. The `appLinkUri` link can be displayed to the user as clickable link in cases the user operates on a mobile device, otherwise the `qrCode` can be rendered to allow the user to scan the code using the mobile application or the mobile phones' camera app.
4. The `statusToken` obtained in step 2 is used to poll the Nevis Authentication cloud backend using the [`/api/v1/status` endpoint](/authcloud/api-doc/api-reference/status-ref). By polling the status, your custom backend and web application will be able to determine when the authentication was completed successfully and proceed afterwards with your scenario, like showing the user a success message or redirecting them. The response also contains the `token` which can be used with the [introspect endpoint](/authcloud/api-doc/api-reference/introspect-ref).
5. During an ongoing authentication, the status API will return `pending`, indicating that the authentication has not been completed yet and has not failed so far.
6. You use the SDKs [out-of-band authentication operation](guide/operation/authentication#out-of-band-authentication) to start the actual authentication process. The process will involve asking the user to provide biometric, PIN or device passcode authentication information. The SDK requires the `outOfBandPayload` for this which the app needs to pass either after the link has been clicked or the QR code scanned.
7. After the user completed the out-of-band authentication in the mobile application, call the [`api/v1/introspect` endpoint](/authcloud/api-doc/api-reference/introspect-ref) using the `statusToken` received in step 2. The introspect endpoint will reply with `active` indicating the successful authentication.

:::info Status vs introspect endpoint

* The [status endpoint](/authcloud/api-doc/api-reference/status-ref) provides information of an ongoing operation. In addition, it returns the `token` which can be used to query the introspect endpoint.
* The [introspect endpoint](/authcloud/api-doc/api-reference/introspect-ref) is used to check whether a token is valid, and whether the token was actually issued by your Authentication Cloud instance.

The custom backend should call _either_ the status _or_ the introspect endpoint depending on the scenario progress.

:::

:::tip

* Concept

  For more information regarding the out-of-band authentication concept, see the [SDK Concept Guide](concept/operations/authentication#out-of-band-authentication) chapter.
  Be aware that link, QR code or push messages are available for out-of-band authentication.

* Mobile SDK Developers

  For hands-on information on how to use the SDK to achieve out-of-band authentication, see the [Developer Guides Operations](guide/operation/authentication#out-of-band-authentication) chapter.

* Authentication Cloud API

  For more information regarding the Authentication Cloud API, visit [Mobile App](/authcloud/api-doc/api-use-cases/mobile-app/).

* Authentication Cloud Concept

  For more information about available authentication methods, visit the [Authentication methods comparison](/authcloud/authentication-methods) chapter.

:::

:::info Transaction confirmation

The FIDO transaction confirmation is technically the same as a FIDO authentication, but additional information is present in the authentication information request, which gives the user details of the transaction.

For this reason, this chapter does not separately list the transaction confirmation flows. See the [Concept Operations](../concept/operations/transaction-confirmation.md) chapter for additional details.
:::
--------------------------------------------------------------------------------
Section: ### glossary.md
# Glossary

## Client SDK

| Term           | Description                                                                                                                                                                                                                                                                                                                                  | Example                                                                         |
|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| Secure Enclave | The Secure Enclave is a coprocessor fabricated within the system on chip (SoC). It uses encrypted memory and includes a hardware random number generator. The Secure Enclave provides all the cryptographic operations for Data Protection key management and maintains the integrity of Data Protection, even if the kernel is compromised. | All iPhones using the A7 processor or newer contain the Secure Enclave          |
| TPM            | The Trusted Platform Module is an international standard for a secure cryptoprocessor, a dedicated microcontroller designed to secure hardware through integrated cryptographic keys.                                                                                                                                                        | Most newer generation Android devices contain TPM chips to securely store data. |

## General Nevis Mobile Authentication

| Term                             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Example                                                                                                                                                                                                                                                                                                                                                                                                       |
|----------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| In-band communication            | Using the current channel.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | A message is delivered through an already established and currently used HTTP communication channel.                                                                                                                                                                                                                                                                                                          |
| Out-of-band (OOB) communication  | Using a channel other than the main communication channel.                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | A message is delivered through push notification, instead of a currently used HTTP communication channel.                                                                                                                                                                                                                                                                                                     |
| Out-of-band (OOB) authentication | Authentication done in an application separated from the application that requires the authentication, with no direct communication between the two.                                                                                                                                                                                                                                                                                                                                                                                    | A web application for banking is accessed from a browser on a laptop. The web application handles the banking-related business logic, but requires authentication by a distinguished Access App, which is installed on a mobile device.                                                                                                                                                                       |
| In-band authentication           | Authentication done within the same application that requires it.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | A mobile banking application, which does not require the installation of another application to handle the authentication. All required functionality is built into one application.                                                                                                                                                                                                                          |
| Transaction confirmation         | An operation in the FIDO protocol that allows a relying party to request that a FIDO Client displays some information to the user, and requires the user to authenticate locally to their FIDO Authenticator to confirm the information. This provides proof-of-possession of previously registered key material and an attestation of the confirmation back to the relying party.                                                                                                                                                      | A mobile banking application has among its capabilities bank transfers. If the amount of the transfer exceeds a threshold, the user must confirm the transaction after authenticating. In the confirmation message presented to the user, the amount of the transaction is included. When the user confirms the transaction, the contents of the message (and thus the amount) are proven by the FIDO server. |
| Access App                       | Dedicated native mobile app built to implement the FIDO UAF authentication, registration and deregistration capabilities. Optionally also implements transaction confirmation capabilities.                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Business App                     | A business application, that users interact with, to conduct business with Nevis customers.                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Relying Party                    | "A web site or other entity that uses a FIDO protocol to directly authenticate users (that is, performs peer-entity authentication)." → see [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO                             | Fast Identity Online                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Client                  | "A FIDO UAF Client implements the client side of the FIDO UAF protocols." → see [FIDO UAF Architectural Overview](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-overview-v1.1-id-20170202.html#fido-uaf-client) and [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Server                  | "A FIDO UAF server implements the server side of the FIDO UAF protocols." → see [FIDO UAF Architectural Overview](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-overview-v1.1-id-20170202.html#fido-uaf-client) and [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Protocol                | "The FIDO UAF protocols carry FIDO UAF messages between user devices and Relying Parties." → see [FIDO UAF Architectural Overview](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-overview-v1.1-id-20170202.html#fido-uaf-client) and [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO Authenticator               | "A FIDO Authenticator is responsible for user verification, and maintaining the cryptographic material required for the relying party authentication." → see  [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Authenticator           | "A FIDO UAF Authenticator is a secure entity, connected to or housed within FIDO user devices, that can create key material associated to a Relying Party. The key can then be used to participate in FIDO UAF strong authentication protocols." → see [FIDO UAF Architectural Overview](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-overview-v1.1-id-20170202.html#fido-uaf-client) and [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html). |                                                                                                                                                                                                                                                                                                                                                                                                               |
| UAF                              | "The FIDO Protocol and family of authenticators which enable a service to offer its users flexible and interoperable authentication. This protocol allows triggering the authentication before the server knows the user" → see [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Client TLS                       | A two way TLS connection where the client also needs a valid certificate. Also known as two way SSL.                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Dispatch Target                  | Client identifier used in out-of-band message. transmission.                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | A unique id identifying a physical mobile device of a user                                                                                                                                                                                                                                                                                                                                                    |
| Dispatch Channel                 | A means, by which the message is transmitted to the client.                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Push (message), Link, E-Mail, ...                                                                                                                                                                                                                                                                                                                                                                             |
| Dispatcher                       | The actual implemented component tasked with sending an out-of-band message.                                                                                                                                                                                                                                                                                                                                                                                                                                                            | The Firebase Cloud Messaging Dispatcher (bound to the 3rd party Firebase Cloud Messaging Service).                                                                                                                                                                                                                                                                                                            |
| Channel Linking                  | Channel linking describes the concept, where a user is requested to visually confirm an out-of-band authentication. The user does so by comparing information shown in a web browser and in the authentication client application. The purpose of channel linking is to verify the current channel or operation, to prevent login attempts by a malicious second party, for example, another user.                                                                                                                                      | During authentication, the browser shows the characters "6A". The same characters are shown in the mobile application, allowing the user to "link" these two channels.                                                                                                                                                                                                                                        |
--------------------------------------------------------------------------------
Section: ### Using push notifications
Using push notifications for mobile authentication is possible on a single device or on multiple devices. However, for same-device authentication, the mobile-only solution provides a better user experience. Additionally, it is able to serve as a fallback in case the push notification was not received by the mobile device.

<img className="boxed" src={require('../../assets/use-cases/authentication/uc-oob-authentication-push.drawio.png').default} alt="Context overview of out-of-band authentication with push notification"/>

:::info Prerequisites

The user must register for [push notifications](../concept-description/push-notifications-in-out-of-band-scenarios.md) before being able to carry out an out-of-band authentication using push.

:::

Out-of-band authentication is initiated by the backend. A possible scenario is where a user wants to access a protected endpoint from outside of the app, for example to log into a web application using a desktop browser. The user must be authenticated first, before the protected endpoint can be accessed. For this to happen, the mobile application integrates the SDK, which provides out-of-band authentication by push notification.

1. The user starts a login.
2. The Nevis Mobile Authentication Backend initiates an authentication, and sends a push message payload to a push provider.
3. An encrypted push notification is sent to the mobile device, which must be handled by the mobile application.
4. The mobile application triggers the out-of-band authentication process with the SDK, by providing the encrypted push notification.
5. Once the mobile application completes the out-of-band authentication process, the user is granted access to the protected endpoint, such as a web application in a desktop browser.
--------------------------------------------------------------------------------
Section: ### Using links (mobile-only solution)
By using links for authentication, the user is able to simply click a link in a browser-based application to initiate the authentication process. This scenario is of course only valid, if the user wants to perform an authentication on the same device, where the app integrating the SDK is present.

<img className="boxed" src={require('../../assets/use-cases/authentication/uc-oob-authentication-link.drawio.png').default} alt="Context overview of out-of-band authentication with mobile-only solution"/>

1. Out-of-band authentication is initiated by the backend. A possible scenario is where a user wants to access a protected endpoint from outside the app, for example, to log in to a web application using a browser on the same device. The user must be authenticated first before the protected endpoint can be accessed. For this to happen, the mobile application integrates the SDK, which provides out-of-band authentication through links.
2. When the user clicks the link provided in the web application, encrypted payload information contained in the link is forwarded to the mobile application.
3. The mobile application triggers the out-of-band authentication process with the SDK, by providing the encrypted payload.
4. Once the mobile application completes the out-of-band authentication process, the user is granted access to the protected endpoint, for example, a web application in a desktop browser. For further information, see the [Access App Guide](/nevisaccessapp/features/channels).
--------------------------------------------------------------------------------
Section: ### I have multiple web applications that my users access via a browser. I would like to authenticate them using mobile authentication. Is the Nevis Access App the right approach for that?
Yes. The Nevis Access App is an excellent fit for this scenario. When a user attempts to log in to the application, an authentication request is triggered and sent to the authenticating user's Access App.
The Nevis Access App supports handling multiple accounts or identities, so, if your web applications require to authenticate with different identities, a single Access App will be enough.
--------------------------------------------------------------------------------
Section: ### number-matching.md
---
sidebar_position: 15
---

# Number Matching

The number matching feature serves to prevent MFA (multi factor authentication) fatiuge attacks.

:::info Multi Factor Authentication Fatigue Attack

MFA push fatigue attack, also known as MFA Bombing or MFA Spamming, is a type of social engineering cyberattack. In this strategy, attackers repeatedly send second-factor authentication requests to the target victim registered devices. The attack relies on users approving simple push notifications without knowing the context of the session they are authenticating.

:::

## Overview

If _number matching_ is used when triggering out-of-band authentication via push message in the server, the application asks the end-user to provide some digits. The operation will only continue if the user enters the correct digits displayed on the screen into the Access App.

It is important to present the end-user enough information in both the web application (where the out-of-band authentication is started) and the Access App about the necessary digits. In the Access App, the label `number_matching_screen_description` in the [localizations file](../ordering-an-access-app.md#localizations-file) contains context information that helps to define the required digits.

If the user provides invalid digits, the authentication will fail.

<img className="boxed" src={require('../assets/number-matching-app-feature.drawio.png').default} alt="Number Matching with Push Messages"/>

1. The user performs a login or transaction confirmation, a push message is sent to the Access App.
2. The browser shows a random, two digit code.
3. The user enters the code displayed in the browser in the Access App and confirms the entry.
4. If the code matches, the user can continue with the operation.
5. The user completes the operation.

:::info Related documentation

For additional _conceptual_ information, refer to the following chapters in the concept guide:

* [Channel Linking](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication#channel-linking) contains information regarding the number matching concept from the backends point of view. Number matching is a _specific subset_ of channel linking.

For additional _technical_ information, visit the following chapters in the reference guide:

* [Out of Band FIDO UAF Auth State](/nevisfido/reference-guide/config-nevis-components/nevisauth-fido-authstates/fido-uaf/outofbandfidouafauthstate) contains information of how to configure the nevisAuth auth state.

:::
--------------------------------------------------------------------------------
Section: ### qr_code.md
---
sidebar_position: 30
---

# QR Code

A QR code is a convenient alternative to push messages if the end user has access to two different devices during operations. This is a prerequisite for using QR codes, because the code needs to be scanned by the mobile application.

## Prerequisites

The end user has access to a web application that displays the QR code generated by the Nevis backend or by a third-party system.

## How it Works

<img className="boxed" src={require('../../assets/oob-qr-code-dispatch.png').default} alt="Out-of-Band Operations with QR Codes"/>

The example use case in the above figure shows how QR codes work. The numbers in the figure correspond with the numbers of the description below.

1. The end user opens the web page on a desktop browser and initiates an out-of-band operation. As the end user does not have push notifications available (for any of the above-mentioned reasons), the web application offers an alternative possibility in the form of a QR code.
2. The end user opens the app and scans the displayed QR code.
3. The desired operation starts.

:::info Related documentation

For additional _conceptual_ information, refer to the following chapters in the concept guide:

* [Out-of-Band Message Transmission](/configurationguide/mobile-auth-concept-and-integration-guide/concept-description/out-of-band-message-transmission) contains information regarding the message transmission concept.
* [Out-of-Band Registration](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-registration) contains information regarding the registration scenario.
* [Out-of-Band Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication) contains information regarding the authentication scenario.
* [Out-of-Band Transaction Confirmation](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-transaction-confirmation) contains information regarding the transaction confirmation scenario.

For additional _technical_ information, visit the following chapters in the reference guide:

* [QR Code Dispatcher](/nevisfido/reference-guide/dispatchers/qr-code-dispatcher) contains information of how to configure and use the QR code dispatcher.
* [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service) contains information regarding the HTTP API dispatch service.

:::
--------------------------------------------------------------------------------
Section: ### push_message.md
---
sidebar_position: 10
---

# Push message

Push notifications are the most convenient way of delivering information from the backend system to the mobile client application. The backend uses the [Google Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging) service to send push messages to the client.

## Prerequisites

* The end user **accepted** to receive push notifications.
* The end user registered his Access App on the Nevis Mobile Authentication backend.
* On Android devices, the Google Play Services need to be available. The Google Play Services are preinstalled on most Android devices but may be missing on some vendor models like for example Huawei.

:::info

Push notifications cannot be used for the _registration_ operation. This is because the push identifier is not known to the backend before the registration process is completed.
:::

## How it Works

<img className="boxed" src={require('../../assets/oob-push-messages.png').default} alt="Out-of-Band Operations with Push Messages"/>

The example use case in the above figure shows how push notifications work during an authentication operation. Other operations behave very similar, apart from who or what initiates the operation. The numbers in the figure correspond with the numbers of the description below.

1. The end user starts a login.
2. The Nevis Mobile Authentication Backend initiates an authentication, and sends a push message payload to a push provider.
3. The push provider sends an encrypted push notification to the mobile device. The mobile application has to deal with the notification.
4. The mobile application triggers the out-of-band authentication process with the SDK by providing the encrypted push notification.
5. Once the mobile application has completed the out-of-band authentication process, the user is granted access to the protected endpoint, for example, a web application in a desktop browser.

## Preventing push-fatigue attacks

If you want to prevent push fatigue attacks, we recommend using push messages in combination with the [number matching](../number-matching) feature.

:::info Related documentation

For additional _conceptual_ information, refer to the following chapters in the concept guide:

* [Out-of-Band Message Transmission](/configurationguide/mobile-auth-concept-and-integration-guide/concept-description/out-of-band-message-transmission) contains information regarding the message transmission concept.
* [Out-of-Band Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication) contains information regarding the authentication scenario.
* [Out-of-Band Transaction Confirmation](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-transaction-confirmation) contains information regarding the transaction confirmation scenario.

For additional _technical_ information, visit the following chapters in the reference guide:

* [FCM Dispatcher](/nevisfido/reference-guide/dispatchers/fcm-dispatcher) contains information of how to configure and use the push message dispatcher.
* [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service) contains information regarding the HTTP API dispatch service.

:::
--------------------------------------------------------------------------------
Section: ### link.md
---
sidebar_position: 20
---

# Link

This section focuses on end-user interactions when there is only _one_ mobile device (and no desktop) available or in use. This method is referred to as the "mobile-only solution". It makes use of links to transfer information from the backend to the Access App.

:::tip

* For **additional information** regarding the **Apple App Association file** as well as the **Google App-Site association** file refer to [app link best practices](/nevisaccessapp/appendixes/app-link-best-practices) in the appendix.
* If the application is not yet installed, the browser is able to **initiate the installation of the mobile application** in a convenient way in case [app links](#app-links---starting-with-the-https-scheme) are used.
* We recommend **hosting a page on the app link path** which offers the end user a direct link to the Google Play Store or Apple App Store.

:::

## Prerequisites

App links require certain prerequisites to work:

* (iOS) The link has to refer to an HTTP domain endpoint that hosts an [Apple App Association File](https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html) in a well-known location.
* (iOS) The page with the link has to contain an HTML meta tag that allows the Safari browser on iOS to display a [smart banner](https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/PromotingAppswithAppBanners/PromotingAppswithAppBanners.html) for the application.
* (Android) The link refers to an HTTP domain endpoint that hosts an App-Site association/link [verification file](https://github.com/google/digitalassetlinks/blob/master/well-known/details.md) in a well-known location.

## How it Works

<img className="boxed" src={require('../../assets/oob-mobile-only.png').default} alt="Out-of-Band Operations with app links"/>

The example use case in the above figure shows how linking works. The numbers in the figure correspond with the numbers of the description below.

1. The end user opens the web page on his/her mobile phone and initiates an out-of-band operation. Because the end user has only one device at hand, and no push notifications are available, the web application offers an alternative possibility in the form of a link.
2. The user clicks the link. This opens the mobile application and forwards the out-of-band payload.
3. The user is authenticated.
4. The desired operation starts.
--------------------------------------------------------------------------------
Section: ### Fixes
* The Access App relies on the system CA certificates to validate the server certificate and is strict doing hostname validation (NEVISACCESSAPP-5210).

## Nevis Access App Android 2.7.2 - 12.09.2023
--------------------------------------------------------------------------------
Section: ### Highlights
We are pleased to present the **Nevis Cluster 2.201911.427 LTS** release. This is the first Nevis release covered by an extensive long-term-support plan, as detailed in the Nevis Product Lifetime and Platform Support Matrix. The LTS (long-term-support) releases focus on stability and will fix defects and security issues while avoiding major, potentially breaking changes.

This release ships, among many bug fixes and product improvements, with the following highlights:

* Performance improvements and faster recovery in the nevisProxy MariaDB session store, leading to a better user experience during infrastructure failovers.
* Support of TLS 1.3, the new and most secure version of the TLS protocol in nevisProxy (requires at least nevisAppliance, RHEL 7 and SLES12 only).
* Full support for OAuth 2.0 token introspection endpoints (RFC 7662).
* Protect your services with terms and conditions, using the new feature available in nevisIDM.
* Starting with this release, nevisIDM fully supports the latest long-term release of Oracle: Oracle 19c.
* Performance and stability improvements in nevisAdmin 4 when working with large deployments.
* PREVIEW Experimental support of highly automated Kubernetes deployments in nevisAdmin 4.
* … and much much more.
--------------------------------------------------------------------------------
Section: ### Concept-Description-and-Technical-Architecture.md
---
sidebar_position: 3
---

# Concept Description and Technical Architecture

The nevisAppliance is the recommended Linux platform for Nevis software. The nevisAppliance provides an opinionated and fixed set of pre-installed packages and configuration, it is not meant as general purpose Linux.

It uses the CentOS/64bit operating system configured for optimal performance, and features adequate security settings to be used within DMZ and secure network zones.

The nevisAppliance can be used in two different configurations. When used as a hardware appliance, the software is directly installed on the server's disk. As a software appliance, it is delivered as a CDROM (ISO) image which has to be installed in a virtual server (VMware ESX).

## File system

The nevisAppliance uses an overlay file system which consists of multiple layers.

* The lowest level contains the operating system (OS). It is a single squashfs image file mounted to the "/" mount point. This image contains all operating system files (/bin, /usr, …) as well as third party software components, such as the MySQL database or the ClamAV virus scanning engine. The scope of available software within this layer depends on the image type you have chosen, see the chapter "Image types". This layer is going to be replaced whenever you install a new `neviscd2_<version>os<type>.img` file.
* The operating system image is transparently overlaid by a writable file system storing all persistent data, such as all your configuration and log files. Every file, symbolic link and empty directory not listed within the */etc/rwdisk.conf* file is going to be deleted when rebooting the server. Thus, do not install any additional software packages (rpm), or they will get lost once you reboot the server.
* The third layer includes the Nevis products and component images. Each Nevis product or component is packed into a single read-only file system and all those image files are mounted to the `/opt/nevis*` directories. This layer is updated by installing a new `neviscd2_<cluster_version>nevis<type>.img` file.

<img className="boxed" src={require('./attachments/6651585/7635447.png').default} alt="File system layers"/>

## Reference architecture

A nevisAppliance is able to host different Nevis software. You choose which product or component to use by creating an instance of the required product or component. Figure below Sample network diagram shows two appliances. One is located within the DMZ hosting nevisProxy instances, while the second one is located within the secure server network called "Application Zone" hosting a nevisAuth instance.

<img className="boxed" src={require('./attachments/6651585/7635448.png').default} alt="Sample network diagram"/>

The nevisAppliance within the DMZ uses two Ethernet interfaces:

* The intranet Ethernet interface (eth0) is connected to the internal firewall. It is used for the communication from the nevisAppliance to the application servers as well as for the administrative network traffic from the management server to the nevisAppliance. You can add routes to the intranet servers using the nevis-appliance command.
* The internet Ethernet interface (eth1) is connected to the external firewall. It is used for connections from clients using the web applications to the nevisAppliance. The default route is normally configured using the router attached to this interface.

The nevisAppliance within the "Application Zone" uses one Ethernet interface:

* The internal Ethernet interface is used for application and administrative network traffic.
--------------------------------------------------------------------------------
Section: ### Communication ports
Figure below Default ports shows the default ports Nevis product or components commonly use for communicating with each other.

<img className="boxed" src={require('./attachments/6651585/7635451.png').default} alt="Default ports"/>

| Port | Protocol | Usage |
| --- | --- | --- |
| TCP 80/443 | HTTP and HTTPS | The standard ports for HTTP(S) traffic. |
| TCP 8991 | SOAP over HTTPS | The communication between nevisProxy and nevisAuth. |
| TCP 8988 | HTTP | The communication between nevisProxy and nevisLogRend (usually, nevisLogRend is located on the same server as nevisProxy and is listening on the local loopback interface (localhost)). |
| TCP 8989 | SOAP over HTTPS | The communication between nevisAuth and nevisIDM. Can also be used to access the web front end of nevisIDM via nevisProxy. |
| UDP 694 | Failover heartbeat | Heartbeat messages exchanged between the nevisAgent instances. |
| TCP 9094 | HTTPS | Communication between nevisAdmin and nevisAgent (to every host). |
| UDP 123UDP 53 | NTP and DNS | NTP and DNS packages are sent to the central NTP and DNS servers. |
| UDP 514TCP 10514 | Syslog over UDP or TLS | Every server may forward log messages to the nevisAdmin server. |
| TCP 1186 | MySQL Cluster | The NDB nodes on nevisProxy and/or nevisAuth need to connect to the server hosting the management node. |
| TCP 22 | SSH | You may want to enable SSH access from the intranet or dedicated administration workstations to any server hosting Nevis products or components. |
| TCP 8037 | HTTPS | Web access to nevisAdmin (by the administrator). |
--------------------------------------------------------------------------------
Section: #### /etc/snmp/snmpd.conf
The SNMP daemon can be initialized using the  `nevisappliance` script and the command `m`.

<img className="boxed" src={require('../attachments/6651476/7635486.png').default} alt="Use the nevisappliance command to enable the SNMP daemon"/>

It creates an `snmpd.conf` file and sets the community string for read-only access. You can adapt the file according to your requirements. The `/usr/share/snmp/mibs/NEVIS-MIB.txt` management information base file describes the Nevis-specific parameters that can be supervised via SNMP.

See also Monitoring ClamAV and Database monitoring for information on additional components that you can configure on your nevisAppliance.

The following section shows a small selection of these parameters:

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyStatus.<instance index>`

 Alternatively, if you are using a failover cluster, the  `instanceProxyFOStatus` attribute can be checked: `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyFOStatus.<instance index>`

 Indicates whether the nevisProxy instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxySessions.<instance index>`

 Number of open user sessions.

 You should ensure that you have enough free sessions (at least 80% of the configured maximum).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyMemory.<instance index>`

 Virtual memory (in kilobytes) allocated by the working proxy process.

 During operation the memory consumption increases and an increase of several gigabytes is not uncommon. Usually, this value does not exceed its initial size by more than 2GB.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyResponseTime.<instance index>`

 Average request time (in seconds) of the HTTP requests.

 Can be an indication of slow application response times but sometimes you may also measure slow request times due to long-polling ajax requests or the download of huge files. This value is mainly used for statistical purposes and you don't need to configure a threshold.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.proxyTable.proxyEntry.instanceProxyConnections.<instance index>`

 Number of TCP connections to the nevisProxy instance.

 In normal operation, this value shall not exceed 50% of the configured maximum.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.authTable.authEntry.instanceAuthStatus.<instance index>`

 Indicates if the nevisAuth instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.authTable.authEntry.instanceAuthJVMKBHeapUsage.<instance index>`

 Heap usage (in kbytes) of the nevisAuth instance's virtual machine.

 The value must not exceed (80%) of the configured limitation (Xmx).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.logrendTable.logrendEntry.instanceLogrendStatus.<instance index>`

 Indicates if the nevisLogRend instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.idmTable.idmEntry.instanceIdmStatus.<instance index>`

 Indicates if the nevisIDM instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.idmTable. instanceIdmJVMKBHeapUsage.<instance index>`

 Heap usage (in kbytes) of the nevisIDM instance's virtual machine.

 The value must not exceed (80%) of the configured limitation (Xmx).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.credTable.credEntry.instanceCredStatus.<instance index>`

 Indicates whether the nevisCred instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceDiskDeviceOnline.1`

 Number of disk devices which are online (to monitor the raid controller).Value must not change (a lower value indicates a device outage).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceFreeMemory.1`

 Available memory (in kilobytes) of the server.

 A server should always have enough free memory to handle peak-loads. A minimum of 256Mbytes is recommended.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceFreeSwap.1`

 Free swap space (in kilobytes) of the server.

 The server must not use the whole swap space during normal operation. We expect that at least 1GB of swap space will be left unused.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceLoad.1`

 Load of the server.

 The load of a server shall not exceed the number of available CPU cores heavily.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceFreeDiskSpace.1`

 Free disk space (in kilobytes) of the server.

Disk space is required to write log or persistent data. Always ensure that there is enough disk space available. A minimum of 10Gbytes is recommended (free disk space can fall below this value during a nevisAppliance update due to the transfer of the new image to the server).

Parameters are accessed on a per instance basis (instance index). You should verify/monitor the instance name as well to make sure that you are monitoring the correct instance.

## Extended service statistics
--------------------------------------------------------------------------------
Section: ### Start replication, slave database on node1
Now, you set up the same configuration the other way round for node1 to be slave of node2. Determine the status of node2 and start the replication on node1.

Example:

```script title="Record the log position on node2"
2> SHOW MASTER STATUS;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000002 | 37888579 |              |                  |
+------------------+----------+--------------+------------------+
```

Example:

```script title="Start replication from node2 to node1"
1> CHANGE
MASTER TO master_host='node2', master_port=3306, master_user='replication',
master_password='<admin password>', master_log_file='mysql-bin.000002',
master_log_pos=37888579;
1> START SLAVE;
1> SHOW SLAVE STATUS\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: node2
                  Master_User: replication
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000002
          Read_Master_Log_Pos: 37888579
               Relay_Log_File: mysql-relay-bin.000002
                Relay_Log_Pos: 529
        Relay_Master_Log_File: mysql-bin.000002
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
...
               Last_IO_Errno: 0
               Last_IO_Error:
              Last_SQL_Errno: 0
              Last_SQL_Error:
 Replicate_Ignore_Server_Ids:
            Master_Server_Id: 2
```

## Configure nevisIDM

The nevisIDM instance is created as documented in the nevisIDM reference guide.

*Use the same user names and passwords for which you granted remote access*.

The IP addresses of node1 and node2 are used in this example for illustration purposes. You can use these servers' host names instead, of course.:

```script title="Create the nevisIDM instance"
# nevisidm inst create nevisidm \
 IDMDB_CONNECTION=jdbc:mysql://node1:3306,node2:3306/nevisidm \
 IDMDB_USERNAME=UIDM02 \
 IDMDB_PASSWORD=password \
 IDM_APPL_URL=https://`hostname`:8989 \
 IDM_SERVER_1_URL=https://`hostname`:8989/nevisidm/services/v1/LoginService \
 IDM_SERVER_DB=mysql \
 RTGROUP=nvbgroup \
 RTOWNER=nvauser \
 SERVER_URL=https://`hostname`:8989 \
 NINJA_CERT=/var/opt/neviskeybox/default/<auth signer>/truststore.jks
```

After the instance creation, you need to edit the nevisIDM properties (using the *nevisidm config idm* command). Add the *failOverReadOnly=false* parameter to the *database.connection.url*.

Example:

```script title="Sample db.connection.url within the nevisidm-prod.properties file"
database.connection.url=jdbc:mysql://node1:3306,node2:3306/nevisidm?failOverReadOnly=false
```

You can start the nevisIDM instance now.

## Upgrading a nevisIDM version

For upgrading nevisIDM and migrating the nevisIDM database, refer to the nevisIDM release notes.

## Database monitoring

Monitoring of the database can be implemented by SNMP, see also the chapter Monitoring using SNMP. To enable enhanced database monitoring, you need to specify a user and password for the monitoring script. This user name and password have to be stored in the `/var/opt/nevisagent/mysql.conf` file.

Example:

```script title="Sample mysql.conf file"
db_connection_username=root
db_connection_password=password
```

We recommend monitoring the OIDs listed in the table below:

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceMySqlNodes.1`

 Indicates whether the MySQL daemons are running (= "1") or not (= "0").

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceMySqlSlaveStatus.1`

 Indicates whether the replication of this database works (= "1") or not (= "0").

## Database backup and recovery

The *mysqldump* program can make backups of your database. The backup shall be executed regularly.

You can use the backup script `/tools/dbbackup.sh` to execute the `mysqldump` command. This script reads its configuration from the `/var/opt/nevisagent/mysql.conf` file.

Example:

```script title="Sample mysql.conf file for backup purpose"
db_connection_username=root
db_connection_password=password
db_backup="mysql nevisidm"
```

On success, the script returns the name of the archive containing all database backup files on stdout.
To restore a database, extract the corresponding database file from the backup archive and import it into the primary node similar to the procedure shown in Import the databases.

```script title="Import example"
# mysql -u root -p < ~/db_mysql.sql
# mysql -p --execute='FLUSH PRIVILEGES;'
# mysql -u root -p < ~/db_nevisidm.sql
```

## Restore a node

If one of the database server nodes needs to be restored, proceed similar to an initial setup:

* Create the database configuration file and start the instance.
* Set the administration password and grant the necessary privileges.
* Skip the step where you create the initial database using the *nevisidmdb* command.
* See the chapter Synchronize the databases on how to export the database from the running node and on how to import it to the re-created server.
--------------------------------------------------------------------------------
Section: ### Virus-protection-using-ClamAV.md
---
sidebar_position: 27
---

# Virus protection using ClamAV

The nevisAppliance includes the Clam antivirus scanning engine which can be used by nevisProxy to detect and block HTTP requests/responses containing a virus.

For virus protection with ClamAV to work on the nevisAppliance, first manually download and then constantly update the virus signature database. See Update the virus signature database for instructions.

<img className="boxed" src={require('../attachments/ClamAV.png').default} alt="Pass HTTP requests/responses to ClamAV"/>

## Configure and start c-icap daemon

nevisProxy forwards HTTP requests/responses via the ICAP protocol to the ClamAV daemon. The c-icap daemon is used to implement this interface.

The following tasks are necessary to start the c-icap server:

1. Copy the configuration template:

 ```
 cp /usr/local/c-icap/etc/c-icap.conf.tmpl \
  /usr/local/c-icap/etc/c-icap.conf
 ```

2. *Optional:* You may now want to adapt the files `/usr/local/c-icap/etc/c-icap.conf` and `/usr/local/c-icap/etc/virus_scan.conf` to your needs. See the [c-icap website](http://c-icap.sourceforge.net/) for further information.

3. Start the c-icap daemon:

 ```
 /etc/init.d/c-icap start
 ```

 From now on, the daemon will automatically start every server reboot.

When using nevisAdmin v3, you can use the "Create" button within the operation view of the c-icap instance. This creates both, the configuration file for the c-icap daemon as well as the cron job entry shown in the chapter Update the virus signature database.

## Configure nevisProxy

nevisProxy uses the ICAPFilter to forward HTTP requests and/or responses to the c-icap server to be validated by ClamAV. Example for request validation (content type application/.*):

```
<filter>
    <filter-name>ICAPUploadFilter</filter-name>
    <filter-class>ch::nevis::isiweb4::filter::icap::ICAPFilter</filter-class>
    <init-param>
        <param-name>ErrorCode</param-name>
        <param-value>403</param-value>
    </init-param>
    <init-param>
        <param-name>BufferRequest</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>RequestBufferSize</param-name>
        <param-value>100000000</param-value>
    </init-param>
    <init-param>
        <param-name>AllowRequestModification</param-name>
        <param-value>false</param-value>
    </init-param>
    <init-param>
        <param-name>ScanRequestHeaderCondition</param-name>
        <param-value>Content-Type:application/.{*}</param-value>
    </init-param>
    <init-param>
        <param-name>SplittMultipartBody</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>ScanRequest</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>InetAddress</param-name>
        <param-value>localhost:1344</param-value>
    </init-param>
    <init-param>
        <param-name>TargetURI</param-name>
        <param-value>
        /srv_clamav?allow204=on&sizelimit=off&mode=simple
        </param-value>
    </init-param>
</filter>
```

See the nevisProxy reference guide for more information about the ICAPFilter options.

## Update the virus signature database

The virus database files (.cvd/.cld) of ClamAV are stored in the `/var/lib/clamav/` directory. You can use the *freshclam* utility to update these database files.

1. Configure the file `/etc/freshclam.conf`. For example, by setting the right *DatabaseMirror* to use or the *HTTPProxyServer* required to connect to the internet. For additional documentation and limitations with the public mirrors, see [the official ClamAV documentation](https://www.clamav.net/documents/configuration#freshclamconf).

 ```script title="/etc/freshclam.conf"
 # ...skipped...
 DNSDatabaseInfo current.cvd.clamav.net
 # ...skipped...
 DatabaseMirror db.XY.clamav.net
 DatabaseMirror database.clamav.net
 ```

 Replace *XY* in *DatabaseMirror* with your country code, for example: *CH*.

2. Run *freshclam* once manually to initially load the definitions. Observe possible errors. It is expected that this call runs successfully without errors.

 ```
 freshclam
 ```

3. Configure a nightly *cronjob* to update the virus database files regularly.

 ```
 echo "0 5 * * * sudo /usr/bin/freshclam \
     --quiet -l /var/log/clamav/freshclam.log 2>/dev/null" \
     >> /var/spool/cron/nvluser
 ```

## Monitoring ClamAV

The *freshclam* utility loads the new database files from the internet (e.g., from current.cvd.clamav.net server) and signals the ClamAV daemon to reload its configuration.

You can poll the ClamAV status using SNMP, see also the chapter Monitoring using SNMP.

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceCicapDStatus.1`

 Indicates whether the C-ICAP instance is running (=1) or not (=0).

* `iso.org.dod.internet.private.enterprises.adnovum.nevis.nevismib.applianceTable.applianceEntry.instanceApplianceFreshClamStatus.1`

 Shows whether the virus signature database is up to date (newer than 3 days).
--------------------------------------------------------------------------------
Section: ### Requirements.md
---
sidebar_position: 7
---

# Requirements

## Interfaces

The nevisAppliance supports one or multiple physical network interfaces. The first interface (eth0) must always be connected to the intranet network. The primary IP address of this network interface shall represent the server and is used for administrative access as well as to open connections from the nevisAppliance to the application servers.

A second interface (eth1) can be used to connect to an internet firewall when the nevisAppliance is acting as a nevisProxy instance. Make sure to define a proper routing on the server if you are using more than one interface connected to different layer 3 networks.

## Routing

The routing is usually set as follows:

* A single-homed (only one Ethernet interface is used) nevisAppliance has only the default route to the gateway within the layer 3 network the nevisAppliance is connected to.
* You need to add static routes as well when using a failover cluster. See the nevisAdmin reference guide for more information.
* A dual-homed (two Ethernet interfaces are used) nevisAppliance has a default route to the gateway connected to the internet. Several host and/or network routes are defined for the intranet interface to route traffic to the application server, nevisAuth, nevisAdmin, NTP/SNMP/SNMTP/SYSLOG and other service hosts.

## NTP

The nevisAppliance requires a network time protocol server (NTP server) to synchronize its system clock. The time zone is set to CET by default. Link the file `/etc/localtime` to the appropriate time zone in `/usr/share/zoneinfo` if you have to change it.
--------------------------------------------------------------------------------
Section: ### Subinterfaces
Your server may have multiple IP addresses to support multiple services. For example, one IP address is used by your company website, the other one by the company's web mail application and a third one by the company's online trading platform.

The nevisappliance command can be used to assign the server's main IP address to the Ethernet interface eth0. Additional addresses are either configured automatically by nevisAdmin/nevisAgent if you are using a failover cluster, or manually by creating additional `ifcfg-eth*` files within the `/etc/sysconfig/network-scripts/` directory.

Example of a server with three IP addresses assigned to its first Ethernet interface eth0:

```
# cat /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=static
ONBOOT=yes
HWADDR=00:0C:29:24:BA:BF
IPADDR=172.16.254.133
NETMASK=255.255.255.0
USERCTL=no
NM_CONTROLLED=no

# cat /etc/sysconfig/network-scripts/ifcfg-eth0:0
DEVICE=eth0:0
BOOTPROTO=static
ONBOOT=yes
IPADDR=172.16.254.134
NETMASK=255.255.255.0
USERCTL=no
NM_CONTROLLED=no

# cat /etc/sysconfig/network-scripts/ifcfg-eth0:1
DEVICE=eth0:1
BOOTPROTO=static
ONBOOT=yes
IPADDR=172.16.254.135
NETMASK=255.255.255.0
USERCTL=no
NM_CONTROLLED=no

```
--------------------------------------------------------------------------------
Section: ### Bonding
Multiple Ethernet interfaces can be used in active/standby mode to have a fault-tolerant network connection.

The following steps are necessary to configure two interfaces to share one IP address and to run in an active/standby mode.

* Define a new virtual interface called `bond0` within the `/etc/modprobe.d/bond0.conf` file. Setting `mode` to `1` enables the active/standby mode (you can also use another mode, e.g., `2` for load balancing):

```
alias bond0 bonding
options bond0 miimon=100 mode=1

```

* Create a new interface which specifies the IP address to be used:

```
# cat /etc/sysconfig/network-scripts/ifcfg-bond0
DEVICE=bond0
BOOTPROTO=none
ONBOOT=yes
IPADDR=172.16.254.133
NETMASK=255.255.255.0
USERCTL=no

```

* Configure the two Ethernet interfaces to be slave of this bond interface:

```
# cat /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
USERCTL=no

# cat /etc/sysconfig/network-scripts/ifcfg-eth1
DEVICE=eth1
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
USERCTL=no
```

* Last, activate the new settings:

```
# systemctl restart network.service
```

Example of a running configuration (ifconfig command output):

```
bond0: flags=5187<UP,BROADCAST,RUNNING,MASTER,MULTICAST> mtu 1500
        inet 172.16.254.32 netmask 255.255.255.0 broadcast 172.16.254.255
        inet6 fe80::20c:29ff:fe3c:47ee prefixlen 64 scopeid 0x20<link>
        ether 00:0c:29:3c:47:ee txqueuelen 0 (Ethernet)
        RX packets 82 bytes 6768 (6.6 KiB)
        RX errors 0 dropped 6 overruns 0 frame 0
        TX packets 63 bytes 9058 (8.8 KiB)
        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0

eth0: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST> mtu 1500
        ether 00:0c:29:3c:47:ee txqueuelen 1000 (Ethernet)
        RX packets 705 bytes 69546 (67.9 KiB)
        RX errors 0 dropped 0 overruns 0 frame 0
        TX packets 501 bytes 140174 (136.8 KiB)
        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0

eth1: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST> mtu 1500
        inet6 fe80::20c:29ff:fe3c:47ee prefixlen 64 scopeid 0x20<link>
        ether 00:0c:29:3c:47:ee txqueuelen 1000 (Ethernet)
        RX packets 6 bytes 360 (360.0 B)
        RX errors 0 dropped 6 overruns 0 frame 0
        TX packets 8 bytes 648 (648.0 B)
        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0
```
--------------------------------------------------------------------------------
Section: ### Architecture-overview.md
---
sidebar_position: 4
---

# Architecture overview

This chapter provides a high-level, feature-oriented view of the nevisMeta component and provides information about the context in which nevisMeta is used.

## Features

nevisMeta is designed to facilitate the setup of federation protocols within the Nevis framework. It offers the following features:

* A central management point of metadata for setups of particular protocols. Each protocol is handled by a dedicated module.
* All necessary information for participants of setups to fulfill roles as defined by the particular protocol. This information is provided in the form of JSON documents that can be retrieved via REST services. The documents enable participants to configure themselves dynamically according to the description of the setup.
* A REST interface that allows retrieving, creating, modifying and deleting setups and entities. The rest interface will return data at the time of the call or, if a date is provided, at a specific point in time (see the chapter REST API V2).
* All modifications are dated: Any changes may be defined to take effect immediately or at any point in the future. Consumers of the nevisMeta REST service (typically participants in those same managed setups) receive instructions on how long to maximally cache the data they received. This enables coordinated changes of setup configuration between all interested participants without the need for explicit coordination communication or deployment windows (see the chapter Entities and states).

## Web console

 The nevisMeta web console offers an easy-to-use administration interface for the module setups that are managed in nevisMeta (see the chapter "Main screen"). It offers the following functionalities:

* creating new setups
* adding new entities with module-specific types to a setup
* editing general properties of the setup that affect all participants
* editing and deleting entities
* specifying the validity date for each modification

These functionalities are protected from unauthorized access.

For an overview of all supported web browsers, see the chapter "Browser Support Policy in Nevis" in the Nevis Product Lifetime and Platform Support Matrix Guide.

## REST API

The REST API provides a well-defined interface for exchanging information with participants of a setup and with other services. Because it is feature-complete, it can also be used to implement a custom, specialized front-end for managing nevisMeta functionality (e.g., custom configuration point). A detailed description of the REST API can be found in the chapter REST API V2.

## Persistence

 nevisMeta offers persistence based on MariaDB and PostgreSQL.

* MariaDB is an SQL-based relational database. The setup of MariaDB is described in "MariaDB setup".
* PostgreSQL is an SQL-based relational database. The setup of PostgreSQL is described in "PostgreSQL setup".

## Supported protocols

 Currently, nevisMeta implements a module for OAuth 2.0. It supports the following protocols:

* OAuth 2.0 [2]
* OpenID Connect Core [3]

## Deployment architecture

The following illustration shows nevisMeta in an abstract architecture:

* Admin users have access directly to the nevisMeta web GUI, where they can edit data of setups and entities.
* Custom Configuration Points may provide a tailored user interface, which allows a Protocol Specialist to interact with nevisMeta using the REST interface (note that such a service is not provided by nevisMeta but must be implemented separately).
* Participant Services consume metadata from nevisMeta to configure themselves dynamically.
* End-users interact with the Participant Services only (i.e., not directly with nevisMeta).

<img className="boxed" src={require('../attachments/7823282/65964896.png').default} alt="nevisMeta abstract architecture"/>

 In the illustrated setup two nevisMeta instances are employed for high availability (failover) but the backup connections for the *Participant Services* and the *Custom Configuration Point* are omitted for clarity. The nevisMeta instances are backed by a database cluster of two nodes.
--------------------------------------------------------------------------------
Section: ### Configuring outage resilience on MariaDB
This chapter is about resilience towards outages of database nodes, which differs from resilience towards failures of nevisMeta instances. To achieve resilience towards failures of nevisMeta instances, two nevisMeta instance addresses must be configured in nevisProxy. Such a configuration enables failover to the second nevisMeta instance if nevisProxy cannot connect to the first nevisMeta instance. For more information, see the nevisProxy reference guide (*InetAddress* parameter of the *HttpConnectorServlet)*.
--------------------------------------------------------------------------------
Section: ### `nevismeta config`
The command *nevismeta* *config* opens the main configuration file *nevismeta.properties* for editing in a console editor.

| Parameter name                                | Default | Description                                                                                                                                                                                                                                                                          |
|-----------------------------------------------|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| fileimportsize                                | 5242880 | Maximum size of importable files in bytes. For example, "5242880" means 5 MB.                                                                                                                                                                                                        |
| maxCacheDuration                              | 600     | Maximum cache duration for REST interface responses in seconds.For example, "600" means 10 min.                                                                                                                                                                                      |
| module.oauthv2.import.regenerate.clientsecret | false   | Regenerates client secrets when importing OAuthV2 client entities. <code>{true &vert; false}</code>                                                                                                                                                                                  |
| expiredDataCleaningInterval                   | 3600    | Interval after which expired data will be cleaned, in seconds. For example, "3600" means 60 minutes or one hour.                                                                                                                                                                     |
| expiredDataCleaningTolerance                  | 120     | Minimum time needed to delete data after expiration, in seconds. For example, "120" means 2 minuses. In majority of cases this value should not be changed. If this value is set too high, it could lead to performance issues.                                                      |
| responseCacheExpiry                           |         | Specifies the expiry time in milliseconds for the GET entities endpoint response cache. If left unset, caching will not be used. If set, the value should be less than nevisAuth's <code>nevismeta.maxAge</code>. Setting it too high can cause usage of outdated data in nevisAuth. |
| server.auth.ninja.truststore                  |         | Specifies the truststore file to use for Ninja to parse the SecToken.                                                                                                                                                                                                                |
| server.auth.ninja.user-getter                 |         | Defines how Ninja gets the user ID from the SecToken.                                                                                                                                                                                                                                |
| server.auth.ninja.role-getters                |         | Defines how Ninja gets user role from the SecToken.                                                                                                                                                                                                                                  |
| server.auth.ninja.sec-role-mapping            |         | Maps SecToken roles to groups or to role principals. Syntax: <code>group &vert; role</code> Recommended setting: "group". See also chapter Configuration of the Web Application in the Ninja reference guide.                                                                        |

In the majority of cases 

For more details, see chapter User ID and Roles in the Ninja reference guide.
--------------------------------------------------------------------------------
Section: ### concept-description.md
---
sidebar_position: 3
---

# Concept Description

This chapter describes the main concepts on which nevisAuth is based.

## What is it about

<img className="boxed" src={require('./assets/nevisauth-concept.drawio.png').default} alt="nevisAuth overview"/>

nevisAuth implements strong user and system authentication for the Nevis identity and access management solution. The product complements nevisProxy, Nevis' entry gateway and web application firewall. Where nevisProxy filters the *content* of user requests to protect your company's online applications against internal and external threats, nevisAuth focuses on the user's *identity*. Its task is to verify whether the user is who he claims to be, to prevent unauthorized users from accessing your applications.

In this context, identification, authentication and authorization play a central role. *Identification* means claiming that you are user X, e.g., by entering your username "userX". *Authentication* is how the system proves if you really are user X. For this, the system can use up to three authentication factors, either separately or combined: something you know (e.g., password or PIN), something you own (e.g., grid card or a third-party token) and something you are (refers to biometrics, e.g., your fingerprint or your typing habits). *Authorization* takes place after the system has successfully identified and authenticated you as really being user X. It is the step that determines what you are allowed to do in the application, your roles and permissions.

nevisAuth covers the whole process of identification, authentication and authorization. If the authentication was successful, nevisAuth copies all relevant security data on a signed security token, the SecToken. This token is the user's *Proof of Authentication* towards nevisProxy and the business applications in the back end.

To be able to perform its tasks, nevisAuth works closely together with nevisProxy. For the verification of the user credentials and retrieval of user roles and permissions, the ideal partner of nevisAuth is nevisIDM, Nevis' product for identity management. However, nevisAuth can also cooperate with LDAP-based directory servers or other authentication services. Also, a request to authenticate a user must not necessarily enter nevisAuth via nevisProxy. nevisAuth provides several other interfaces (APIs), such as the WS-Trust API, to integrate VPN gateways or specific Microsoft services.

Additionally, nevisAuth supports other token formats besides Nevis' proprietary SecToken, such as the SAML assertion, the X.509 user certificate or the JWT claim (OpenID Connect). Thus, nevisAuth enables identity federations with external networks or security domains.

## Main features

* Modular and customizable setup
* Support of a wide range of authentication methods, such as user name/password authentication, X.509 client certificates, security questions, challenge/response procedures, one-time passwords
* Integration of identity federation protocols, such as SAML2, WS-Federation and OpenID Connect
* Support of various token formats, e.g., SAML assertion, the X.509 user certificate or the JWT claim (OpenID Connect)
* Availability of flexible interfaces, e.g. the WS-Trust facade, to easily integrate external systems
* Possibility to create realms/domains to enable single sign-on
* Dynamic adjustment/upgrade of authentication strength to improve security
* Facility to include user roles and permissions to establish a detailed and fine-grained authentication system

## Authentication process including GUI generation

<img className="boxed" src={require('./assets/authentication-process-gui-generation.drawio.png').default} alt="nevisAuth authentication process"/>

The core task of nevisAuth is user identification and authentication. Its goal is that no unauthorized user will access your web applications. In this context, the burden of proof lies with the user. That is, the user must provide information to prove that he is who he claims to be.

This is how it works. A user wants to access a web application protected by Nevis (1) in the preceding figure.
--------------------------------------------------------------------------------
Section: ### SAML assertion
The SAML (2.0) assertion is very similar to the Nevis SecToken*,* but with the following differences:

* It is a standard, defined by [www.oasis-open.org](http://www.oasis-open.org) and supported by major vendors (e.g., Oracle WLS 10.3, IBM WAS 6.1).
* It additionally allows encryption and uses corresponding standards (XML signature and XML encryption, as defined by [www.w3c.org](http://www.w3c.org)).
* It can be federated to a different domain if used in conjunction with the SAML 2.0 protocol.
* XML overhead is huge compared to the Nevis SecToken. The SAML assertion is therefore not suitable for per-request propagation. Instead, use SAML for non-interactive SSO session transfer.

The SAML assertion is appropriate in a federated architecture, where Nevis works together with external third-party services. Together with these external services, Nevis builds an *identity federation*. These are some possible use cases:

* nevisAuth issues a SAML 2.0 assertion as an *identity provider (IdP)*, to allow secure hand-over of the user's identity to an external trusted party.
* As a consumer or service provider (SP), nevisAuth accepts a SAML assertion issued by an external trusted party as the user's proof of authentication. nevisAuth uses the assertion to establish an authentication session in the local environment and to allow the user access to applications in the back end.

:::info

For further details about SAML tokens and plug-in, see [SAML AuthStates](setup-and-configuration/authentication-plugins-and-authstates/saml-authstates/saml-authstates.md).
:::

## Session management

Upon the start of the authentication nevisAuth creates a session. This is an *initial session* as long as nevisAuth did not yet finish the user authentication. Whenever a user is successfully authenticated, nevisAuth upgrades the initial session to an *authenticated session*. It also issues the SecToken. If the authentication failed, the initial session is discarded.

The session data is stored in a session cache, together with the data on the SecToken (or another proof of authentication). To track the authenticated user, Nevis sends a cookie to the client browser, which the browser must submit on any subsequent request. By means of the cookie as well as all information on the SecToken and in the session cache, the session management facilities of nevisAuth and nevisProxy can detect inactivity of the user and trigger a re-authentication. It is possible to terminate the session as well, e.g., if the SecToken is expired.

## Single sign-on

nevisAuth also facilitates *single sign-on (SSO)*. Single sign-on means that the user has to log in only once to be able to access multiple web applications in the back end.

To set up single sign-on within Nevis, you have to group your applications into something we call an SSO *realm*. The authentication happens per SSO realm. If a user is granted access to one application in a realm, he has access to all applications within this realm.

This concept not only allows the user to have to authenticate just once. It also supports upgrading of the authentication strength, such that the authentication method used for the realm is stronger than the in

Nevis recognizes the applications belonging to a realm by their URLs (internet addresses). See the following figure; The SSO realm "Extranet" consists of the applications "app1", "app2" and "app3". To access application "app1", a user will enter the URL `https://extranet.ch/app1` in his browser (to access application "app2", the user must enter `https://extranet.ch/app2`, and so on).

<img className="boxed" src={require('./assets/nevisauth-sso.drawio.png').default} alt="nevisAuth single sign on"/>

To authenticate the user, nevisAuth only needs the user's password for the realm Extranet. Upon successful authentication, the user has access to all three applications app1, app2 and app3. But because of the application path ".../app1" in the URL, Nevis knows that the user wants to use application app1. Thus, nevisProxy is able to forward the user's request to the right application within the realm.

## APIs

To access the authentication service of nevisAuth, Nevis offers various secure interfaces or *APIs*.

Most requests to authenticate a user enter nevisAuth via nevisProxy and the Nevis Authentication Interface, which is a SOAP service (see the following figure. SOAP stands for *Simple Object Access Protocol* and is a network protocol to exchange data.

<img className="boxed" src={require('./assets/nevisauth-apis.drawio.png').default} alt="nevisAuth APIs"/>

But there are several other possibilities to access nevisAuth directly. For example, Microsoft clients using the WS-Trust protocol may access nevisAuth through the WS-Trust facade.

## Architecture – how does it work?

nevisAuth's core responsibility is to process authentication requests. Basically, nevisAuth consists of a broad range of plug-ins, the *AuthStates*. The AuthStates are the building blocks of the authentication process and can be combined in all kinds of variations and sequences. This allows you to implement exactly the kind of authentication you need to protect your applications in an optimal way: as strong as required and as user-friendly as possible.

During the authentication process, the user's login data passes different AuthStates. Each AuthState has one particular responsibility, e.g., to authenticate a user against a certain authentication back end, to manipulate a request, to store information, etc. The AuthState also forwards the data to the next step in the authentication process.

Basically, each AuthState receives input, processes it and produces output (which is the input for the next AuthState). This goes on and on, until the last AuthState within the authentication process is reached.

A specific combination of AuthStates with an entry AuthState, a last AuthState and several AuthStates in between, builds a *domain* (see the following figure. A domain may perform the authentication process for just one application in the back end, or for several applications at once. The latter case facilitates single sign-on. Here, the domain resembles the SSO realm.

<img className="boxed" src={require('./assets/nevisauth-architecture.drawio.png').default} alt="nevisAuth architecture"/>

An authentication process starts as soon as an authentication request enters nevisAuth via nevisProxy, or via one of the other interfaces/APIs. The Authentication Engine, or *AuthEngine*, is responsible for dispatching the request to the first AuthState, as well as transitioning the request from one AuthState to the next. The AuthEngine also identifies whether an AuthState requires more information from the user.

Eventually, the AuthEngine constructs a response for nevisProxy. There are three types of responses:

* `AUTH_CONTINUE`

  The AuthEngine requires more input from the user to continue processing. This results in the generation of a new GUI descriptor and page, which is sent to the user.
* `AUTH_DONE`

  The AuthEngine could finish the authentication successfully. This results in the issuing of a SecToken.
* `AUTH_ERROR`

  The AuthEngine detects an error. No user input can circumvent this error. nevisAuth stops the authentication process. This results in an error message.
--------------------------------------------------------------------------------
Section: ### auditing.md
---
sidebar_position: 115
---

# Auditing

This chapter deals with the auditing of authentication-related events.

## Audit events

Audit events are generated under the following circumstances:

| Event          | Generated by       | Condition                                                                                                                                                                                                                                                    |
|----------------|--------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *authenticate* | AuthEngine         | When during an authentication the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.                                                                                                |
| *stepup*       | AuthEngine         | When during a step-up the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.                                                                                                        |
| *stepdown*     | AuthEngine         | When during a step-down the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.                                                                                                      |
| *unlock*       | AuthEngine         | When during an unlock the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.                                                                                                        |
| *logout*       | AuthEngine         | When during an explicit logout of the user the response status from an AuthState execution is either `AUTH_DONE` (with or without error), `AUTH_CONTINUE` or `AUTH_ERROR`.This event can also be triggered by an AuthState in case a session is invalidated. |
| *timeout*      | SessionCache       | The session has been removed from the local session store. If no other session termination event is present, the local reaper finally removed the session.                                                                                                   |
| *terminate*    | SessionCoordinator | The session is going to be killed locally.                                                                                                                                                                                                                   |
| *custom*       | AuthState          | A plug-in generates its own audit events. Check the section "Audit" in the AuthState documentation chapter.                                                                                                                                                  |

## Audit data

The AuthEngine is called by an access proxy or caller and receives various information about the proxy, the user-agent (e.g., browser) in addition to the user's authentication data. After authentication, data from the AuthState plug-ins is also available. The following table lists the possible audit entry data. All this data may be consumed by an audit channel:

| Field                                  | Provided by                                          | Content                                                                                                                                                                                                                                                                                                                      |
|----------------------------------------|------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *Timestamp*                            | System                                               | Audit events are immediately delivered to the audit channel. The timestamp of the event therefore needs to be extracted from the system clock by the audit-channel.                                                                                                                                                          |
| *Event*                                | AuthEngine, SessionCoordinator or AuthState plug-ins | See the column "Generated by" in the table Audit events.                                                                                                                                                                                                                                                                     |
| *Severity*                             |                                                      | *NOTICE*: A successful uncritical event.<br/>*ALERT*: a critical event that requires administrator attention.<br/>*ERROR*: A failed, possibly critical event.                                                                                                                                                                |
| *Detail*                               |                                                      | Additional information describing the event.                                                                                                                                                                                                                                                                                 |
| *SecRoles*                             | AuthState                                            | The user's current security role(s) displayed as a comma-separated list of role identifiers.                                                                                                                                                                                                                                 |
| *AuthLevel*                            | AuthState or configuration                           | The user's authentication level, e.g., "auth.weak".                                                                                                                                                                                                                                                                          |
| *ClientIP*                             | caller (access proxy)                                | Usually the (unverified) user's workstation IP address as passed by the access proxy. If the proxy is installed behind non-transparent network infrastructure (load balancers, firewalls), which replace the source address in the TCP packages, this field is not really useful, as it always contains the same IP address. |
| *ClId*                                 | caller (access proxy)                                | The network channel ID, as generated by the access proxy. This field is used to correlate messages that are sent over the same channel.                                                                                                                                                                                      |
| *ClientSec*                            | caller (access proxy)                                | The security attributes of the network channel (e.g., used SSL protocol and cipher).                                                                                                                                                                                                                                         |
| *ClientType*                           | user-agent                                           | The user-agent (HTTP header), as forwarded by the access proxy.                                                                                                                                                                                                                                                              |
| *Domain*                               | caller (access proxy)                                | The authentication realm, which the access proxy wants to use to authenticate its clients.                                                                                                                                                                                                                                   |
| *DomainMap*                            | AuthState                                            | A list of identity mappings for back end applications.                                                                                                                                                                                                                                                                       |
| *EntryId*                              | caller (access proxy)                                | A unique identifier that allows to distinguish between different access zones or access proxy instances.                                                                                                                                                                                                                     |
| *AuthId*                               | nevisAuth(configuration)                             | A unique identifier that allows to distinguish between different authentication zones or nevisAuth instances.                                                                                                                                                                                                                |
| *LoginId*                              | user                                                 | The user name, visible to and known by the accessing user.                                                                                                                                                                                                                                                                   |
| *Url*                                  | caller (access proxy)                                | The resource, which the user wants to use, and which triggered the authentication.                                                                                                                                                                                                                                           |
| *SessId*                               | nevisAuth(SessionCache)                              | The authentication session, as generated by nevisAuth.                                                                                                                                                                                                                                                                       |
| *ConversationId*                       | AuthEngine                                           | The identifier of the conversation. All requests/response contexts share this identifier until `AUTH_DONE`.                                                                                                                                                                                                                  |
| *Principal*                            | AuthState                                            | The (global) authenticated user principal.                                                                                                                                                                                                                                                                                   |
| *TraceId* (only in SOAP deployment) | caller(access proxy)                                 | Unique transfer ID supplied by nevisProxy or other clients. This ID links the audited operation to the issuing request at the client.                                                                                                                                                                                        |
| List of Authentication Markers         | AuthEngine/ AuthState                                | An Authentication Marker or *auth marker* represents a successfully completed operation that is relevant for the authentication and authorization process. Each auth marker belongs to an AuthState.An *auth marker* has the following form:*`<technology>`:`<type>`".                                                       |

## Audit channels

Audit channels are output-handlers for audit events. They have the following characteristics:

* They define, what (available) data to use and how to format it.
* They implement, where to output the data (file, MQ, ...).

Currently, the nevisAuth standard distribution includes the `NevisAuditChannel`.

:::info

It is also possible to implement a custom `AuditChannel` interface. For a description of the `AuditChannel` interface, see [AuditChannel interface](#auditchannel-interface)
:::

## NevisAuditChannel

This channel outputs all fields, listed in chapter ["Audit data"](#audit-data) and writes them (via log4j) to a file. The file can be rotated based on a size or time-policy. The output is formatted as follows (single line format, newlines added for better readability):

```
2015-04-24 09:08:24,683 INFO
  Domain="SSO"
  LoginId="xxx"
  Principal="xxx"
  Event="authenticate"
  Detail=""
  AuthLevel="auth.weak"
  SecRoles="auth.weak,webmail"
  DomainMap=""
  ClientIP="10.22.214.122"
  ClientSec="TLSv1.2;DHE-RSA-AES256-SHA"
  ClientType="Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36"
  EntryId="extranet.siven.ch"
  ClId="59a4000aacccNFBkB7OwKRjuD5SpPsL/UccBmRn4TM9f+ySOc0F+Zpw="
  Url="https://extranet.siven.ch/jira/secure/MyJiraHome.jspa"
  AuthId="I1"
  SessId="0L1c-sHdIRRcNKG410z0b1DsqZFX6KLmNhhBx4g-YKw"
  TraceId="1d7bf899ab6ca912dd27fdf777bd90a6"
  ConversationId="805056107136"
Trail: SSOLdapLogin{2015-04-24 09:08:24; LDAP:username/password(uid=xxx,ou=people,o=siven,c=ch)}
```

The keys in the log entry names can be mapped as follows to the field entries in section [Audit data](#audit-data):

| Keys in NevisAuditChannel | Available audit data                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|---------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Event                     | Event                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Detail                    | Detail                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| SecRoles                  | ActualRoles                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| AuthLevel                 | AuthLevel                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ClientIP                  | ClientAddress                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ClId                      | ClientId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ClientSec                 | ClientSecurityInfo                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ClientType                | ClientType                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Domain                    | Domain                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| DomainMap                 | DomainMappings                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| EntryId                   | EntryId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| AuthId                    | EsAuthId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| LoginId                   | LoginId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Url                       | Resource                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| SessId                    | SessionId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Principal                 | UserId                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| TraceId                | TraceId (only in SOAP deployment)                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Trail                     | (list of) Authentication Markers.<br/>A *Trail* entry consists of a sequence of Authentication Markers or *auth markers*. Together, these auth markers show the route of the user through various AuthStates during a specific authentication and/or authorization event. A trail can contain just one auth marker or several auth markers. A *Trail* entry has the following form: Trail: `<AuthState1>{<date and time>; <auth marker1>}-><AuthState2>{<date and time>; <auth marker2>}->…` |

```text title="Trail examples"
Trail: SSOLdapLogin{2015-04-24 09:08:24; LDAP:username/password(uid=xxx,ou=people,o=siven,c=ch)}
Trail: SSOIdmUserIdPasswordLogin{2015-10-20 09:31:47; nevisIDM:username/password(pbu)}-->SSOIdmPostProcessing{2015-10-20 09:31:47; nevisIDM:selection(profile: Profile-pbu/1000)}
```

## AuditChannel interface

The *AuditChannel* interface contains two methods:

| AuditChannel Methods                                                 | Description                                                                                                                                                               |
|----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *init(Properties cfg)*                                               | This method is called by the AuthEngine upon initialization of the *AuditChannels*. Properties configured in the nevisAuth configuration are handed to the *init* method. |
| *audit(String event, String detail, AuditEntry entry, int severity)* | This method is called to deliver audit events. The channel should format and deliver the events according to the audit event destination.                                 |

Each *AuditChannel* is initialized upon nevisAuth start. The configuration properties from the *esauth4.xml* file are handed to the *init(…)* method. The *audit(…)* method is called whenever an audit event is handled.

To write the audit log into a custom storage, implement the *AuditChannel* interface. Configure the *classpath* for the custom *AuditChannel* implementation in the *AuthEngine* *classpath* configuration (see [Plugging authentication infrastructures](../use-cases-and-best-practices/use-cases/plugging-authentication-infrastructures.md)). In common cases, the *classpaths* are put into the */var/opt/nevisauth/`<inst>`/plugin* directory.
--------------------------------------------------------------------------------
Section: ### Kerberos Login Integration
The following steps are needed to integrate a backend service into a Kerberos realm:

1. Register a Service Principal Name (SPN) at the Key Distribution Center (KDC) of the Kerberos realm. Use the following SPN format: `HTTP/<hostname>[:port]` where:
  * `<hostname>` is the fully-qualified virtual host name of the access proxy 
  * `[:port]` is an optional port number
2. Generate a keytab file containing the long-term Kerberos key belonging to the SPN and make it accessible to nevisAuth. This is the point where the used encryption types could be defined, see also [supported encryption types](#supported-encryption-types).
3. Configure the *KerberosLoginAuthState* to use the keytab file as a kerberos credential, for further details please consult [KerberosLoginAuthState](../../setup-and-configuration/authentication-plugins-and-authstates/kerberos-authentication-authstates.md#kerberosloginauthstate)

For further details regarding how to register an SPN at the KDC or how to generate a keytab file with specific encryption types please consult the documentation of the used Kerberos KDC.
--------------------------------------------------------------------------------
Section: ### Step 1: Registering the proxy host in AD
Use the active directory administration to register a new (functional) user, representing the proxy virtual host. Proceed as follows:

1. When registering the new user, enter a user login name. For example, "HTTP/`<proxy-host-name>`", where `<proxy-host-name>` is the hostname used by the clients.
2. Set a password (to be used for the key export later).
3. In the *Account* tab of the user's *Properties* window (see the figure below, go to the *Account options* section and make the following required settings:

* Deactivate *User must change password at next logon*.
* Activate *Password never expires*.
* Select *This account supports Kerberos AES 128 bit* or *This account supports Kerberos AES 256 bit* (see also [Encryption types](#encryption-types)).

4. If you want to use pass-through authentication, go to the *Delegation* tab of the *Properties* window.

* Either activate the option *Trust this user for delegation to any service (Kerberos only)*, or
* List the applications, which Nevis should be allowed to delegate to, under *Trust this user for delegation to specified service only*.

<img className="boxed" src={require('../../assets/properties-window-example-user-configuration.png').default} alt="Properties window - Example user configuration"/>
--------------------------------------------------------------------------------
Section: ### session-cache-scaling.md
---
sidebar_position: 133
---

# Session cache scaling

The session cache inside nevisAuth is configured to have an upper limit to enforce a maximum of parallel user sessions at a time. As session termination notifications may be lost due to network problems, the session cache should be sized to approximately twice the size of the maximum number of parallel user sessions.

1. To configure the session cache, execute the following command:

  ```bash
  nevisauth config
  ```

2. The following parameters are relevant for session cache configuration. Adapt them according to your needs:

  ```xml
  <SessionCache name="SessionCache" size="100000" initialInactivityTimeout="300" inactivityTimeout="43200" maxLifetime="43200">
  ```

The configuration in the previous code snippet provides 100'000 sessions with an initial timeout of 300 seconds. This means that multi-step authentication has to be completed within 5 minutes (the multi-step authentication creates the global authentication session after the first successful step). If the user is too slow in completing the next step, he is forced to start over.

After the authentication is completed, the session lifetime is raised to 12 hours. This time-out enforces a maximum possible session lifetime. Note that idle and screen saver time-outs are enforced by the nevisProxy.

When nevisAuth failure safety is enabled, the number of parallel sessions remains the same, but the initial cache synchronization may need to be disabled as each established session triggers a call to the fallback instance (`syncPullInitial="false"`).
--------------------------------------------------------------------------------
Section: ### failure-safety-and-load-balancing.md
---
sidebar_position: 9
---

# Failure Safety and Load Balancing

This section shows how nevisAuth implements failure safety and load-balancing. It also briefly discusses the global session store.

## Failure safety

nevisAuth manages a global session. As a consequence, the server is stateful and failure safety support requires that the corresponding session cache is synchronized, so that failover-aware clients are able to access it at a different physical location.

The failure safety pattern in nevisAuth is based on a vertical line concept with horizontally paired failure safety. The figure below shows this pattern:

<img className="boxed" src={require('../assets/nevisauth-failure-safety-pattern.drawio.png').default} alt="Failure safety pattern in nevisAuth"/>

The design in the shown pattern has the following advantages:

* The cost of failure safety does not increase dramatically with the number of nevisAuth server instances (synchronization overhead multiplies if the number of synchronized nodes is larger than 2).
* Configuration remains maintainable.

The restrictions include:

* Session stickiness between clients and nevisAuth

  For optimal performance and to prevent session loss, an established session context (e.g., the user is authenticated and the corresponding channel is associated with a client, i.e., a reverse proxy instance) should be handled over the same communication channel. In case of a failure, the client failover (e.g., the reverse proxy) should address the nevisAuth instance that holds the backup of the session state (slave instance). Failover to another nevisAuth instance will result in an error (unknown session exception).

* Session stickiness between clients and reverse proxy:

  Session loss arises when the load balancer in front of the reverse proxy does not route the user's established channel to the same reverse proxy (e.g., based on the SSL session ID, cookies or source IP address).

## Load balancing

nevisAuth gets about two to ten hits per user session, for example for a login, a step-up, and a logout. In other words, failure safety is a big issue (as nobody is able to work when login is not possible), while load balancing is far less important. When considering the session synchronization above, a client may distribute calls to the two nevisAuth instances. If every (distributed) client does this, session synchronization delays may lead to sessions that have been modified on both instances. In this case, synchronization fails as sessions are protected (using an optimistic locking scheme). This problem is solved by synchronous synchronization (setting the synchronization delay to 0 seconds), but this increases the overhead and callers are forced to wait a little longer.

## Global Session Store

To be able to synchronize sessions between nevisAuth instances, nevisAuth must store sessions in a JDBC database. This allows session sharing within nevisAuth clusters of arbitrary sizes. See [Session management](../setup-and-configuration/components/session-management.md) for details on how to configure the JDBC global session store.
--------------------------------------------------------------------------------
Section: ### session-termination-polling-and-actor-identification.md
---
sidebar_position: 8
---

# Session Termination Polling and Actor Identification

Upon receiving an `AUTH_DONE` response state together with a *SecToken*, nevisProxy identifies the user session as an authenticated session. Further requests may only cross nevisProxy. Therefore, nevisProxy holds the master session. This means, if a logout is detected, either instructed by the user or a back-end application. nevisProxy is then responsible for sending a logout or kill request to nevisAuth.

However, it is also possible that nevisAuth decides to terminate the session. This might happen, for example, if the nevisAuth session reaper detects a timed-out session. In this case, the session coordination between nevisProxy and nevisAuth can be achieved using the `poll_terminated_sessions` method.

An external server (usually nevisProxy) can use this method to collect notifications of terminated sessions. The method handler will postpone sending a response until at least a minimal duration has passed (since this notification mechanism is understood to be near-real-time only) and, if no sessions have been terminated since the last call, it will wait up to a maximal duration for the termination of new events. Both minimal and maximal durations can be specified with the request.

To keep track of termination notifications and administer which notifications have been consumed by which actor, each external server must be identified with a unique `actorId`. This is done via the HTTP header `actorId` (in SOAP deployment) or, as a fallback, via the `SubjectDN` in the transport layer client certificate used by the actor.
--------------------------------------------------------------------------------
Section: ### Connectivity
* `service.maintainSession` (boolean, "false")

  Whether to maintain the HTTP session from one request to another in a bound service client.

* `service.poolingMode` ({load balancing,failover}, "failover")

  This property sets the handling of multiple connection URLs. Load balancing is sticky in for a bound service client.

* `service.binding` ({thread, none}, "thread")

  Whether and how to bind a service client. None will create the client for every request. The thread option will store the client in the ThreadLocal therefore it can be reused for subsequent outgoing requests in the same nevisAuth request processing.

* `service.discardInterval` (time in seconds, "10")

  Time in seconds to disregard URLs when communication resulted in a non-application error (that is, an error that indicated a system problem at the service).

* `ervice.retryDiscardedResources` (boolean, "false")

  If all services are marked as discarded, then this property defines whether to nevertheless retry a service. If activated, this forms an "emergency mode" where services are accessed despite the discard interval. The next service to be retried will be selected according to the configured pooling mode.

* `service.retries` (number, defaults to number of connection URLs)

  Number of retries to attempt when experiencing connectivity errors before assuming all services are unavailable.

* `service.httpclient.tls.trustStoreRef`
* `service.httpclient.tls.keyObjectRef`
* `service.httpclient.tls.hostnameVerification`
* `service.httpclient.proxy.host`
* `service.httpclient.proxy.port`

  :::info

  HttpClient properties work the same as described [here](/nevisauth/setup-and-configuration/components/http-client#httpclient-configuration), however this AuthState uses a JAX-WS soap client. So only the configuration options specified above are applicable.

  :::
--------------------------------------------------------------------------------
Section: ### Properties
* `servicePrincipal` (string or "auto", -)

  The Service Principal Name (SPN) reflects the fully-qualified virtual host name of the access proxy (i.e., the host name in the URL, accessed by the browser client). It has the format `HTTP/<hostname>@<REALM>`.

  The Kerberos realm (i.e., the Active Directory domain) needs to be configured in UPPERCASE. It is mandatory to specify the realm.

  If the special value "auto" is configured, the AuthState will extract the SPN from incoming SPNEGO/Kerberos tokens and will look for a related Kerberos credential. Use this feature in scenarios where nevisAuth has to impersonate many SPNs and configuring many AuthStates is not acceptable, or where deciding on the ServicePrincipal to impersonate for a particular request is difficult.

* `kerberosCredentials` (path, "conf/kerberos-credentials.properties")

  Path to a properties file containing service principal name and keytab file path pairs. A keytab file stores the long-term Kerberos key of one or more principals. If `servicePrincipal` defines a specific service principal name then a related entry with the defined SPN has to be present. If `servicePrincipal` is configured to "auto" then after extracting the SPN from incoming SPNEGO/Kerberos token the AuthState will look for a suitable keytab file using this property file.

    <details>
    <summary>Example <b>kerberos-credentials.properties</b> file content:</summary>
    <div>
      HTTP/service1.hostname@REALM=conf/kerberos.keytab
      <br/>
      HTTP/service2.hostname@REALM=conf/kerberos.keytab
      <br/>
      HTTP/service3.other-hostname@OTHER.REALM=conf/other.keytab
    </div>
  </details>

* `permittedRealms` (whitespace-separated list of realms or `*`, defaults to realm of service principal)

  A whitelist of trusted realms, only users from listed realms are allowed. In a multi-realm setup with cross-realm trust this parameter could be used to limit and exclude some realms from the auth flow which are otherwise trusted by the Key Distribution Center (KDC).

  The default behavior allows users only from the realm of the configured service principal. If `servicePrincipal` is configured to "auto" then default can not be used. Using an asterisk completely disables this check and allows authentication of users irrespective of their realm.

  The `permittedRealms` property supports variable expressions.

* `userIdFormat` (string {full | unqualified}, "full")

  The format of the user ID set upon successful authentication.

  <details>
    <summary>Example assuming a Kerberos user: <b>username@REALM</b></summary>
      <table>
        <tr>
          <th>UserIdFormat</th>
          <th>UserId</th>
          <th>LoginId</th>
        </tr>
        <tr>
          <td>full</td>
          <td>username@REALM</td>
          <td>username@REALM</td>
        </tr>
        <tr>
          <td>unqualified</td>
          <td>username</td>
          <td>username@REALM</td>
        </tr>
      </table>
  </details>

  The `userIdFormat` property supports variable expressions.

* `limitSessionLifetime` (boolean, "false")

  If configured to "true" then the lifetime of the underlying Kerberos service ticket used by the client during the SPNEGO negotiation will be considered when determining the lifetime of Nevis session. In this case the expiration time of Nevis session can not be longer than the expiration time of the Kerberos service ticket.
--------------------------------------------------------------------------------
Section: ### Properties
* `ServicePrincipal` (string or "auto", -)

  The principal name reflects the fully qualified virtual host name of the access proxy (i.e., the host name in the URL, accessed by the browser client). It has the format `HTTP/<hostname>@<REALM>`.

  The Kerberos realm (i.e., the Active Directory domain) needs to be configured in UPPERCASE. It is mandatory to specify the realm.

  If the special value "auto" is configured, the AuthState will extract the SPN from incoming Kerberos tokens and will look for a suitable credential. Use this feature in scenarios where nevisAuth has to impersonate many SPNs and configuring many AuthStates is not acceptable, or where deciding on the ServicePrincipal to impersonate for a particular request is difficult.

* `UserIdFormat` (string {full,unqualified}, "full")

  The format of the user ID set upon successful authentication.

  ```text title="Example"
  //Assuming a Kerberos user username@REALM:

  full: UserId="username@REALM", LoginId="username@REALM"
  unqualified: UserId="username", LoginId="username@REALM"
  ```

* `PermittedRealms` (whitespace-separated list of realms or "*", defaults to realm of principal)

  Only users from realms listed are allowed. The default allows only users from the realm of the principal (HTTP/hostname@REALM).
  An asterisk disables this check and allows authentication of users irrespective of their realm.

* `BackendServices` (whitespace-separated list of service principals, -)

  Each service principal must be of the format `HTTP/<hostname-of-backend>@<REALM-OF-BACKEND>`.
--------------------------------------------------------------------------------
Section: ### Properties
* `connection.N` (string, required)

  One or several connection strings may be configured with postfixes of the form `.N` (N being a consecutive numbering). The connection string is a comma-separated list of key/value pairs. The following keys are supported:

  * `host` Host name of the RADIUS server (required)
  * `authPort` Port for authentication requests. Default: 1812
  * `acctPort` Port for accounting requests. Default: 1813
  * `secret` Shared secret required to communicate with the server (required). Use nevisCred (with the neviscred://... syntax) to protect the value in the configuration.
  * `timeout` Server communication time-out in milliseconds. Default: 10000 (10 seconds)

  This AuthState uses the UDP protocol to send messages to backend servers. It is thus susceptible to SOCKS proxies, as described in the chapter [Configuring proxies](../../use-cases-and-best-practices/use-cases/configuring-proxies.md).

* `poolingMode` ({failover,load balancing}, failover)

  Defines the handling of multiple configured connections.

* `discardInterval` (duration in seconds, 10)

  Sets the interval during which a backend service will not be connected to when connectivity problems occurred.

* `retryDiscardedResources` (boolean, false)

  When all configured connections are blocked by the `discardInterval`, enabling this setting will have the AuthState retry connections before the `discardInterval` has passed. The next connection to retry will be selected according to the pooling mode configured.

* `request.type` (string {Access-Request,Accounting-Request}, required)

  The RADIUS RequestType that shall be sent to the server.

  Note that Access-Request has a special behavior:

  * If no User-Name attribute is configured: the `loginId` or `${inargs:isiwebuserid}` will be set (if applicable).
  * If no User-Password attribute is configured: `${inargs:isiwebpasswd}` will be set (if applicable).
  * If no State attribute is configured: The state received in the last RADIUS response (`${sess:radius.State}`) will be set (if applicable).

* `request.attributes` (comma-separated list, -)

  The RADIUS attributes to send in the request packet. Each attribute must be specified in the form `<attr-type>=<attr-value-expression>`.
  Example: `User-Name=${request:userId}, User-Password=${inargs:passwd},State=${}`

* `authenticateOn` (string, -)

  RADIUS _ResponseType_ that signals authentication. If the server responds with this type of packet, the AuthState will signal authentication with the user ID that was used in the request.

* `scope` (string {outargs, notes, session, inctx, inargs, roles}, "outargs")

  Variable scope where attributes of incoming response are stored.
--------------------------------------------------------------------------------
Section: ### Properties
* `host` (string, "localhost")

  A comma- or space-separated list of hostnames to be used as backend servers. Load balancing is not supported. Fail-safety to the next server in the list is done upon any (technical) failures. The last backend successfully used is remembered.

  This AuthState uses the UDP protocol to send messages to backend server. It is thus susceptible to SOCKS proxies, as described in the chapter [Configuring proxies](../../use-cases-and-best-practices/use-cases/configuring-proxies.md).

* `authPort`  (number, 1812)

  Port of the authentication server.

* `secret` (string, -)

  Shared secret required to communicate with the server. The secret must be generated on the ACE server using the administration tools of the ACE installation.

  Use nevisCred (with the neviscred://... syntax) to protect the value in the configuration.

* `timeout` (number [sec], 60)

  Server communication time-out in seconds.

* `retryTime` (number [sec], 120)

  This period defines how long a failed back-end server is ignored before it is used again for failover.

* `retryCount`  (number, 3)

  Specifies the number of retries before aborting. Retries are not done on the failed back-end server but on the next host in the list (round-robin failover). Retries are aborted if all servers in the list have been tried.

* `userIdMapper` (string, "${inargs.isiwebuserid}")

  This attribute allows to change the input argument sent by the user.

* `passwordMapper` (string, "${inargs.isiwebpasswd}${inargs.tokencode}")

  This attribute allows to specify the value used as passcode.

* `propagateResponse` (string, -)

  A list of response attribute names that should be propagated to the notes. If set to all, all RADIUS response attributes will be propagated. Disabled by default.

* `customTransitionMessagePattern_[0-n]`  (string, -)

  A message template (a pattern) that is matched against the _AccessChallenge_ _reply-message_ delivered by the server. If it matches, the result will be set to `customTransition_[0-n]`. The pattern must be a Java regular expression.
--------------------------------------------------------------------------------
Section: ### useridpasswordauthenticatestate.md
---
sidebar_position: 76
---

# UseridPasswordAuthenticateState

## Introduction and overview

The JNDI-based *UseridPasswordAuthenticateState* AuthState permits performing simple authentication (e.g., password login) to any LDAP directory via LDAP or LDAPS.

The AuthState supports the following features:

* Simple login (login ID, password).
* Prospect login (the directory is queried for the user's existence, but no credential is checked).
* Password change (the user's *userCredential* attribute can be updated with a new password).
* Password expiration detection (SunONE, Novell eDirectory, AD and OpenLDAP).
* Direct directory bind, in case of a flat directory structure (see the `userDN` property).

During a login, the AuthState processes the following steps:

1. The AuthState checks that all input fields configured in the GUI are provided by the user. Otherwise, the GUI is displayed (If the AuthState is final the GUI is always displayed).
2. If no `userDN` is configured, the AuthState opens a connection to the LDAP and searches for the user with either the configured `userBaseDN` and `userFilter` or with a `baseDN` and filter derived from the configured LDAP dialect (via the property `dirStyle`).
If a `userDN` is configured, this connection will use the DN and password specified in the connection string.
3. If no user was found, the result `usernotfound` is returned. If multiple users were found and `userSelectAttr` is configured, the AuthState will display a selection of users based on the values of the attribute. If multiple users were found but `userSelectAttr` is not defined, the transition `usernotunique` is returned.
4. The AuthState uses the `userDN` and the user password to bind to the LDAP. If this bind succeeds, the user is authenticated. Depending on the dialect of the server (set in property `dirStyle`), a required password change can be signaled by a special error code. If `userCheckOnly` is enabled, this step is omitted. If the bind failed, the AuthState will stop processing with the result `default`.
5. If new passwords are provided (properties `newPw1Source` and `newPw2Source`), a password change is attempted using the connection bound to the user in step 3. The details of the password change depend on the dialect configured. This step is ommitted if `userCheckOnly` is enabled.
6. The user attributes are fetched. This query will be performed according to the `delegate`` properties configured, but some additional, dialect-specific attributes that are used for password expiration detection are also fetched.
7. The user roles are fetched and transformed according to the `role`` properties configured.
8. If a password expiration has been detected in step 3 or 5, the result `pwchangerequired` (if a matching transition is configured) or `pwchange` is selected. Otherwise, the result `ok` is returned.

## Structured user sub-tree in LDAP

Indirect directory bind by first locating the user anonymously or with a functional LDAP account (see `userBaseDN` property).

## Authorization support

Coarse-grained authorization support on nevisProxy by retrieving role or group information from the directory and propagate them as Nevis security roles (see `roleBaseDN` property).

## User-profile support

User profile support by retrieving further attributes from the directory and `delegateBaseDN` property.

## Fail-safety

The LDAP connector is failsafe, performing a failover when the client library (JNDI) throws a communication exception.Note: Old releases may perform a failover on any exception, i.e., a user providing an invalid passphrase is authenticated against every directory. If the directory uses a failure counter, bookkeeping of user login failures may therefore be wrong.

## Description

The following table and chapters describe the characteristics of the AuthState.

| Topic    | Description                                                        |
|----------|--------------------------------------------------------------------|
| Class    | `ch.nevis.esauth.auth.states.jndi.UseridPasswordAuthenticateState` |
| Logging  | JNDIState, JNDI                                                    |
| Auditing | none                                                               |
| Marker   | LDAP:username/password                                             |
| Methods  | authenticate, setup                                                |

## Properties
--------------------------------------------------------------------------------
Section: ### Network
* `connection1, ..., connection9` (url, -)

  This property configures the network connection and simple (functional) authentication when the authentication needs to query the LDAP to have access to directory subtrees (login information is required if required data is not visible, i.e., authorized to an anonymous client). If two-way SSL is used, the LDAP directory may perform authentication based on the client certificate. As JNDI is used as a client library, connection parameters, keystores and truststores must be configured as system properties.

  Connections are used in the indexed order for fail-safety, i.e., load balancing and stateful target discarding are not supported at the time. The general syntax is:

  ```
  (ldap|ldaps)://<host-or-ip>:<port>
   [<functional-user-DN> (neviscred://<neviscred-alias>|secret://<obfuscated-password>|<plain-password)]
  ```

  This AuthState uses the LDAP protocol when establishing a connection with an LDAP server. The AuthState is thus susceptible to SOCKS proxies, as described in the chapter [Configuring proxies](../../../use-cases-and-best-practices/use-cases/configuring-proxies.md).

  Examples:

  ```
  ldap://ldap.siven.ch:389
  ldaps://ldap.siven.ch:636 CN=admin,O=siven,C=ch secret://Ll41Zsw54rmeNi2ZeoZD
  ```

  The following (backward compatible) properties are available too:

  * url (URL): URL part of the connection
  * user (DN): User part of the connection above
  * password (string): Password part of the connection

  The default connection time-out is five seconds (com.sun.jndi.ldap.connect.timeout=5000).
  The JNDI client sets the following system properties by default (see Sun documentation for details).
  To configure different behavior, set the appropriate values in `JAVA_OPS`.

  ```
  com.sun.jndi.ldap.connect.pool.maxsize=8
  com.sun.jndi.ldap.connect.pool.timeout=300000 // cache connections for up to 5 minutes
  com.sun.jndi.ldap.connect.pool.protocol="plain ssl"
  com.sun.jndi.ldap.connect.pool.authentication=none // only cache unauthentic connections
  ```

  The following per-pool defaults will be set and may be overridden by defining equivalent properties for the AuthState:

  ```
  com.sun.jndi.ldap.connect.pool=true // turn on connection pooling
  com.sun.jndi.ldap.connect.timeout=5000 // 5sec connect time-out
  com.sun.jndi.ldap.read.timeout=10000 // 10sec read time-out
  ```

* `searchSizeLimit` (int, 256)

  This property limits the number of results returned by an LDAP search. This way, you can control resources such as memory and network bandwidth.
--------------------------------------------------------------------------------
Section: ### directresponsestate.md
---
sidebar_position: 67
---

# DirectResponseState

## Introduction and overview

This AuthState can be used to send a direct HTTP response to an end user / client by forcing nevisProxy to directly forward the response.

An example is a situation where nevisAuth needs to send a JSON response to a web application. As the *DirectResponseState* does nothing but generating a response, it should be used as a final AuthState and the *resumeState* flag should be set to false.

A typical example where the *DirectResponseState* can be used is in the context of a mobile application: Depending on whether the authentication was successful or not, nevisAuth will send different JSON content in the HTTP response.

## Description

The following table and chapters describe the characteristics of the AuthState.

| Topic    | Description                                                      |
|----------|------------------------------------------------------------------|
| Class    | `ch.nevis.esauth.auth.states.directResponse.DirectResponseState` |
| Logging  | DirectResponseState                                              |
| Auditing | none                                                             |
| Marker   | none                                                             |
| Methods  | process, generate                                                |

## Properties

* `contentType` (string, - )

  This optional property defines the Content-Type header field of the HTTP response. It must be set if the content property is set.

* `content` (string, - )

  This optional property defines the content of the HTTP response. The value can be a URL of a file, starting with file://. For example:
  `<property name="content" value="file://path/to/my/file"/>`.

  nevisAuth does not have to be restarted when the file content changes.

* `statusCode`  (string, "200")

  This property defines the status code of the HTTP response status line.

* `header.<header-field>` (string, -)

  Optional properties to define custom HTTP response header fields.

## Input

none

## Transitions

none (should only be used as final AuthState)

## Output

An HTTP response containing the fields and content defined in the properties.

## Errors

none

## Notes

none

## Example

The following _DirectResponseState_ definition is used when the processing has failed. It sends a JSON response with an attribute called ErrorCode, whose value is 150:  `{ErrorCode: "150"}`

```xml
<AuthState class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState" final="false" name="GenMob-AuthErrGeneric" resumeState="false">
     <Response value="AUTH_ERROR">
     <!-- This is not necessary but is kept here to avoid a warning -->
     <Gui name="DummyGui" />
     </Response>
     <property name="content" value="{ "ErrorCode":"150" }" />
     <property name="contentType" value="application/json" />
     <property name="statusCode" value="401" />
</AuthState>
```

The following _DirectResponseState_ definition can be used when the processing was successful and sends a JSON response with an attribute called message whose value is login successful: `{message: "login successful"}`

```xml
<AuthState
name="GenMob-Ok" class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState" final="true" resumeState="false">
     <Response value="AUTH_DONE"/>
     <property name="contentType" value="application/json"/>
     <property name="content" value="{"message":"login successful"}"/>
     <property name="header.Expires" value="Tue, 15 Nov 2020 08:12:31 GMT"/>
</AuthState>
```

The AuthStates can be referenced by other AuthStates. For example, the following AuthState will use the previously defined _DirectResponseStates_, which depends on the result condition:

```xml
<AuthState class="ch.nevis.esauth.auth.states.xml.DocumentProcessor" final="false" name="GenMob-Ok" resumeState="true">
         <ResultCond name="default" next="GenMob-AuthErrGeneric" />
         <ResultCond name="ok" next="GenMob-Ok" />
...
```

```xml
<AuthState name="DirectResponse" class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState" final="true" resumeState="false">
     <Response value="AUTH_ERROR"/>
     <property name="contentType" value="application/json"/>
     <property name="content" value="{"Error Message":"${notes.lasterrorinfo}"}"/>
     <property name="statusCode" value="401"/>
     <property name="header.Expires" value="Tue, 15 Nov 2020 08:12:31 GMT"/>
</AuthState>
```

The following example uses the contents in the session to generates a JSON response providing the authentication level stored in the notes in the JSON status attribute:

```xml
<AuthState
class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState" final="false" name="GenMob-RegNewDevAuthDoneResponse" resumeState="false">
     <Response value="AUTH_DONE">
     <Gui name="AuthDoneDialog" />
     </Response>
     <property name="content" value="{ "status":"${notes:authlevel}" }" />
     <property name="contentType" value="application/json" />
     <property name="header.isiwebauthstate" value="valid" />   
     <property name="statusCode" value="200" />
</AuthState>
```
--------------------------------------------------------------------------------
Section: ### relyingpartystate.md
---
sidebar_position: 96
---

import REUSE from '/docs/reusable-md/_new-auth-http-client-information.md'

# RelyingPartyState

<REUSE/>

## Designated usage of the RelyingPartyState and integration with nevisProxy

The AuthState *RelyingPartyState* implements the authorization code flow and can be used to implement login in a Nevis-protected web application via an OpenID Connect identity provider. This is achieved by configuring nevisProxy to intercept unauthenticated requests to the web application and requiring authentication by nevisAuth. A nevisAuth instance configured with the *RelyingPartyState* will issue an authentication request to the OpenID Connect provider via an HTTP redirect. The OpenID Connect provider will then require the end user to authenticate. If successfully completed, the provider will redirect the end user back to the relying party with an authorization code. Upon receipt of an authorization code, the *RelyingPartyState* will redeem it for an ID and access token at the provider. The ID token returned by the provider will then be verified by the *RelyingPartyState*, the user ID will be set to the subject claim in the ID token and further claims contained in the ID token will be propagated in the session. nevisAuth will respond to nevisProxy with *AUTH_DONE* and a SecToken, which nevisProxy can then delegate to the originally requested web application. This flow is also depicted in the following figure.

```plantuml
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}


title Nevis and Open ID Connect Relying Party: Authorization Code Flow

participant "End-user / Resource Owner" as client

box "Open ID Connect Relying Party"

participant nevisProxy as proxy
participant "nevisAuth (RelyingPartyState)" as auth
participant "Nevis protected Webapp/Resource" as resource

end box

participant "Open ID Connect IdP" as idp

client -> proxy: GET WebApp (original request)
proxy -> auth: authenticate()
auth -> client: Authentication Request
client -> idp: Authentication Request
idp -> idp: Authenticate End-user
idp -> client: Authentication Response \n (Authorization Code)
client -> auth: Authentication Response \n (Authorization Code)
auth -> idp: Token Request \n (Authorization Code)
idp -> auth: Token Response \n (ID Token, Access Token)

group Key Renewal Process only if required
auth -> idp: Get Verification Key
idp -> auth: Verification Key
end group

auth -> auth: validate ID Token / extract claims
auth -> auth: write claims to session
auth -> auth: authenticate user as subject in ID Token
auth -> proxy: authentication done
proxy -> auth: pass through original request with authentication token
auth -> client: response

@enduml
```

## Preconditions and limitations

The following preconditions and limitations exist:

* The *RelyingPartyState* AuthState requires the OpenID Connect provider to provide a [metadata document](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
* Required key material must be provided as a JWK document under the URL provided in the `jwks_uri` field of the metadata document.
* Only ID tokens provided as plain JWT or JWS (signed with RSA signature scheme) are supported.
* `acr` claims are ignored.

## Description

The following table describes the characteristics of the *RelyingPartyState* AuthState.

| Topic    | Description                                                                                                                                                                                                          |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Class    | `ch.nevis.esauth.auth.states.oauth2.openid.rp.RelyingPartyState`                                                                                                                                                     |
| Logging  | OIDCRelyingParty                                                                                                                                                                                                     |
| Auditing | none                                                                                                                                                                                                                 |
| Marker   | none                                                                                                                                                                                                                 |
| Methods  | process Issues an authentication request and a token request upon receipt of a successful authentication response. Authenticates end user and propagates claims if authentication response contains valid ID token.  |

## Properties

* `redirectURI` (string (URL))

  The _redirect_uri_ used in the authentication request. A valid URL or a variable which is substituted with a valid URL during runtime is supported.

* `clientId` (string)

  The client_id used in the authentication and token request.

* `clientSecret` (string)

  The _client_secret_ used in the token request. The AuthState supports both a fixed client secret and a variable that is substituted during runtime.

* `scope` (space-separated string)

  Requested scope used in the authentication request.

* `claimsRequest` (string)

  The _claims_ request parameter.  This value is expected to be formatted in JSON and does not accept trailing spaces nor tabs.

* `providerConfiguration` (string)

  Supported values are

  * the URL of the provider metadata document,
  * a string containing provider metadata as per specification, or
  * a variable containing a provider metadata document.

  This AuthState uses the HTTP protocol to fetch the metadata document (depends on the URL configured). It is thus susceptible to HTTP proxies, as described in chapter [Configuring proxies]([Configuring proxies](../../../../use-cases-and-best-practices/use-cases/configuring-proxies.md)).

* `maxAge` (integer in seconds)

  The _max_age_ request parameter used in the authentication request

  :::info

  The _max_age_ property is not supported by Google IdP (they return an invalid expire time), so do not add this property while using Google as IdP.
  :::

* `acr_values` (string)

  Requested Authentication Context Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request. The Authentication Context Class satisfied by the authentication performed is returned as the acr Claim Value. The acr Claim is requested as a Voluntary Claim by this parameter.

* `arbitraryAuthRequestParam.[paramName]` (string)

  Arbitrary additional request parameters used in the authentication request.
  The property supports variable substitution.

  ```xml title="Example"
  <property name="arbitraryAuthRequestParam.[paramName]" value="[paramValue]" />
  ```

* `userId` (string, "${sess:[AuthStateName].idTokenClaim.sub}")

  The user ID by which the user will be authenticated. The AuthState supports both a fixed user ID or a variable one that is substituted during runtime.

* `clientAuthMethod` (string, "client_secret_basic")

  The secret can be sent to the token endpoint in two ways:

  * `client_secret_basic` (default)

    The client secret and clientID are sent to the token endpoint with the HTTP Basic authentication scheme.

  * `client_secret_post`

    The client secret and clientID are sent to the token endpoint with the HTTP Post scheme.

* `responseMode` (string, "query")

  The way to handle authorization callback (to nevisAuth)

  * `query` (default)

    The callback via GET request

  * `form_post`

    The callback via POST request

* `allowRedirect` (boolean, true)

  After receiving a response from the OpenID Connect identity provider, RelyingPartyState will automatically set redirect to the original request URL. Set this variable to "false" to disable this behavior.

  :::info

  After you disable the redirect here, add another AuthState for redirecting back to the original request URL.
  :::

* `httpclient.*` (String)

  Configure the outgoing HTTP communication towards the metadata provider. For a list of valid HTTP properties, see [HTTP Client](/nevisauth/setup-and-configuration/components/http-client).

## Input

none

## Transitions

* `failed`

  Authentication was not successful, the ID token was not valid or an internal error occurred.

* `ok`

  Authentication was successful and the ID token is valid.

## Output

* `session:[AuthStateName].tokenResponse.[field]`

  The value of fields of the received token response. For example:

  ```
  RelyingParty.tokenResponse.id_token = [encodedIDToken]
  RelyingParty.tokenResponse.access_token = [encodedAccessToken]
  ```

* `session:[AuthStateName].idTokenClaim.[claimName]`

  The value of the claims present in the ID token. For example:

  ```
  RelyingParty.idTokenClaim.sub = [username]
  ```

## Errors

none

## Notes

none

## Example

```xml
<AuthState name="RelyingParty" class="ch.nevis.esauth.auth.states.oauth2.openid.rp.RelyingPartyState" final="false">
        <ResultCond name="ok" next="AuthDone"/>
        <ResultCond name="failed" next="AuthError"/>   
        <property name="redirectURI" value="[redirectURI]" />
        <property name="clientId" value="[clientId]" />
        <property name="scope" value="openid email" />
        <property name="claimsRequest"
            value="{&quot;id_token&quot;:{&quot;given_name&quot;:null}, &quot;userinfo&quot;:{&quot;address&quot;:null}}" />
        <property name="clientSecret" value="[clientSecret]" />
        <property name="providerConfiguration" value="[providerMetadataDocumentURI]" />
        <property name="maxAge" value="3600" />
        <property name="arbitraryAuthRequestParam.access_type" value="offline" />
        <property name="arbitraryAuthRequestParam.new_value" value="#{StringUtils.contains(inargs['auth-strength'],'2') ? 'qoa2':'qoa1'}" />
</AuthState>
```

If not present yet, add the root certificate to the truststore (`-Djavax.net.ssl.trustStore`) that is defined in the `JAVA_OPTS` configuration option in the *env.conf* file. See also the following sample code snippet. The root certificate is used to *prove* the authenticity of the provider configuration and to *verify* the authenticity of the token and authorization endpoints.

```
keytool -import -keystore /var/opt/keybox/default/truststore.jks -file GeoTrustGlobalCA.pem
```
--------------------------------------------------------------------------------
Section: ### introduction-to-openid-connect-relying-party.md
---
sidebar_position: 94
---

# Introduction to OpenID Connect relying party

An "OpenID Connect relying party" is an OAuth 2.0 client application requiring end-user authentication and claims from an OpenID Connect provider (as defined in [the Specification](http://openid.net/specs/openid-connect-core-1_0.html). Put in other words, a relying party relies on authentication information and claims issued by another entity. A common use case is to support login in a web application via an identity provider such as e.g., Google and PayPal.

In nevisAuth this functionality is implemented with the AuthStates *OIDCProviderMetadataFetcherState*, the *RelyingPartyState* and the *UserinfoClientState*.
--------------------------------------------------------------------------------
Section: ### introduction-to-oauth2-authstates.md
---
sidebar_position: 99
---

# Introduction to OAuth2 AuthStates

## Introduction

An OAuth2 AuthState is a collection of OAuth 2.0 client applications requiring end-user authentication and claims from an OAuth2 provider (as defined in [RFC 6749](http://datatracker.ietf.org/doc/html/rfc6749). In this situation, the client relies on authorization information and claims issued by another entity. A common use case is to support login to a web application via an identity provider such as, for example, Facebook and GitHub.

In nevisAuth, this functionality is implemented with the following AuthState: [OAuth2ClientState](oauth2clientstate.md).

Designated usage of the OAuth2 AuthState(s) and integration with nevisProxy

The OAuth2 AuthState(s) implement the authorization code flow. You can use the OAuth2 AuthState(s) to implement the login to a Nevis-protected web application with an OAuth2 identity provider. This is what happens:

1. nevisProxy intercepts an unauthenticated request to the web application and requires authentication by nevisAuth.
2. The nevisAuth instance, which is configured with the OAuth2 AuthState(s), issues an authorization request to the OAuth2 identity provider via an HTTP redirect.
3. Subsequently, the OAuth2 identity provider requires the end user to authorize.
4. Upon successful completion of the authorization, the provider redirects the end user back to the client with an authorization code.
5. After receiving the authorization code, the OAuth2 AuthState redeems the code for an access token at the provider.
6. The OAuth2 AuthState asks for the user's information with another HTTP GET request, and propagates the user information in the session.
7. nevisAuth responds to nevisProxy with `AUTH_DONE` and a SecToken.
8. nevisProxy delegates the SecToken to the originally requested web application.

The following figure shows the described flow:

```plantuml
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}


title Nevis and OAuth 2 client: Authorization Code Flow

participant "End-user / Resource Owner" as client

box "OAuth2 Client"
participant nevisProxy as proxy
participant "nevisAuth (OAuth2ClientState)" as auth
participant "Nevis protected Webapp/Resource" as resource
end box

participant "OAuth2 IdP" as idp

client -> proxy: GET WebApp (original request)
proxy -> auth: authenticate()
auth -> client: Authentication Request
client -> idp: Authentication Request
idp -> idp: Authenticate End-user
idp -> client: Authentication Response \n (Authorization Code)
client -> auth: Authentication Response \n (Authorization Code)
auth -> idp: Token Request \n (Authorization Code)
idp -> auth: Token Response \n (ID Token, Access Token)
auth -> idp: User information \n Authorization: Bearer <Access Token>
idp -> auth: User information

group Only when email endpoint is configured
auth -> idp: User email \n Authorization: Bearer <Access Token>
idp -> auth: User email
end group

auth -> auth: write user info / email to session
auth -> auth: authenticate user by user ID from user info
auth -> proxy: authentication done
proxy -> auth: pass through original request with access token
auth -> client: response

@enduml
```

## A note on the root certificate

The root certificate is used to *prove* the authenticity of the provider configuration and to *verify* the authenticity of the token and authorization endpoints.

If not present yet, add the root certificate to the truststore (`-Djavax.net.ssl.trustStore`) that is defined in the `JAVA_OPTS` configuration option in the *env.conf* file. See also the following sample code snippet:

```
keytool -import -keystore /var/opt/keybox/default/truststore.jks -file GeoTrustGlobalCA.pem
```
--------------------------------------------------------------------------------
Section: ### authorization-server.md
---
sidebar_position: 89
---

# Authorization server and Open ID Connect provider plug-ins

The nevisAuth OAuth2 authorization server and Open ID Connect provider plug-ins basically implement the two roles authorization server and resource server as defined by the OAuth 2 specification in the [AuthorizationServer](authorizationserver.md) and the [AccessTokenConsumer](accesstokenconsumer.md). The *AuthorizationServer* issues access tokens to third-party clients with the approval of the resource owner. The *AccessTokenConsumer* accepts access tokens issued by the *AuthorizationServer* and grants access to protected resources if the access token could be successfully verified.

The designated usage of the *AuthorizationServer* and *AccessTokenConsumer* are illustrated in the following figure:

<img className="boxed" src={require('../../../../assets/nevisauth-authorization-code-flow.drawio.png').default} alt="Authorization code flow with Nevis"/>

The previous figure depicts an authorization code flow as it takes place in a typical Nevis environment consisting of nevisProxy and nevisAuth:

1. An end user requests a page from a third-party web application.
2. As the web application requires access to the OAuth2 protected resource to fulfill the request in this scenario, the web application redirects the end user to Nevis with an authorization request.
3. nevisProxy intercepts the request and sends it to nevisAuth via the internal SOAP interface, where it is validated by the *AuthorizationServer* AuthState (hereby implementing the authorization endpoint). After authenticating the end user and establishing the user's consent (interaction not shown in this figure), an authorization response including an authorization code is sent to the web application via an HTTP redirection.
4. After receiving the authorization code, the web application sends a token request including the authorization code to Nevis.
5. nevisProxy intercepts the request and sends it to nevisAuth via the internal SOAP interface, where it is validated by the *AuthorizationServer* AuthState (hereby implementing the token endpoint). After successfully verifying the authorization code, a token response including an access token and if requested an ID token and refresh token are issued directly to the web application.
6. Now being in possession of an access token, the web application requests the OAuth2 protected resource. This request is intercepted by nevisProxy and sent for authentication to nevisAuth, which verifies the submitted access token.
7. After successfully verifying the access token, the resource request is passed to the resource, which then responds to the web application.

n the designated usage scenario, multiple sessions are established in the process of the authorization code flow. In step 3, a session with the end user's browser is established as the end user will be authenticated (user ID = end user's ID). In step 5, a session with the web application is established as the client will be authenticated (user ID = client_id). In step 7, a virtual session bound to the access token will be established with the web application (user ID = end user's ID associated with the submitted access token). I.e., whenever the web application requests a resource and supplies an access token, the session previously established when sending the same access token will be selected.

:::info

The most productive setups include two or more nevisAuth instances in a load balancing or failover configuration (or a combination of both). In such a scenario, a nevisAuth instance must be able to consume authorization codes issued by any of the other instances. To enable this, a common OutOfContextDataServices (see chapter [Shared out-of-context data](../../../components/shared-out-of-context-data.md)) must be used. Note that all instances must use the same key to sign token responses for this scenario to work.
:::
--------------------------------------------------------------------------------
Section: ### Properties
* `accessTokenLifetime` (seconds, 3600)

  Defines how long an access token issued by the authorization server should be valid per default (can be overwritten by client policies).

  :::info

  Note that the calculation of the expiration time is based on the issuing time of the authorization code, not on the time the access token is returned in the AuthorizationServer's response.
  :::

* `refreshTokenLifetime` (seconds, 1 year)

  How long a refresh token issued by the authorization server should be valid per default (can be overwritten by client policies).

* `authCodeLifetime` (seconds, 600)

  How long an authorization code issued by the authorization server should be valid.

* `keystoreref` (string, "DefaultKeyStore"), `keyobjectref` (string, "DefaultSigner")

  This property configures the key and certificate to use when issuing tokens. The access token is encrypted using the configured public key. The ID token is signed using the configured private key. Currently, RSA and Elliptic Curve (EC) keys are supported.

  If the nevisAuth instances are configured in a load balancing or load balancing configuration, the `keystoreref` of all the instances should reference the same keys.

* `keyID` (string, - )

  This property configures the kid JOSE header value of the issued access and ID tokens. It allows the authorization server to explicitly signal a change of key material to recipients. The meaning of the `kid` header is slightly different for [signed](https://tools.ietf.org/html/rfc7515#section-4.1.4) and [encrypted](https://tools.ietf.org/html/rfc7516#section-4.1.6) tokens.

  **Note:**
  * kid JOSE header value will be generated automatically (if `keyID` is not set) from the key which is used to sign or encrypt the token using JWK thumbprint (RFC 7638) method.
  * ID Token encryption is using JWKS, therefore the keyID for the encrypted ID Token will contain the keyID belonging to the key used from the JWKS. Setting this keyID property has no effect on ID Token encryption.

* `dataSource` (string, "local")

  Determines what data source should be used to configure OAuth 2.0 clients and scopes. With dataSource=local, client and scope configuration data is supplied via configuration properties. With `dataSource=nevismeta`, client and scope configuration data is supplied via nevisMeta.

* `propagationScope` (string, "session")

  Define propagation scope to store information for following AuthStates.

* `encryptAccessToken` (boolean, true)

  This property defines the format of the Access Token. If set to:

  * true, the Access Token will be encrypted (JWE).
  * false, the Access Token will not be encrypted (JWS).

* `nestedJWSAccessToken` (boolean, false)

  This property defines how JWS Access Token is generated. If set to:

  * true, the JWS Access Token is nested (JWS inside JWS Access Token).
  * false, the JWS Access Token is not nested.

  This property can only use when encryptAccessToken set to false to generate JWS Access Token.

* `rotateRefreshToken` (boolean, false)

  This property defines if a new Refresh Token is issued together with the Access Token on the Token Endpoint while exchanging a refresh token for a new access token (`grant_type=refresh_token`).

  * true, a new Refresh Token is issued, the existing Refresh token is deleted.
  * false, the existing Refresh token is returned and remains valid.

* `absoluteRefreshTokenLifetime` (boolean, false)

  This property defines if a new Refresh Token in a token rotation sequence is issued with the same expiration time as the initial Refresh Token.

  * true, the expiration time of the new Refresh Token will be the same as the old Refresh Token.
  * false, the expiration time of the new Refresh Token will be the current time plus `refreshTokenLifetime`.

* `removeEmptyClaimsInToken` (boolean, false)

  This property defines whether empty claim(s) will appear in the Access Token and ID Token.

  * true, the ID Token and Access Token will not include empty claim(s).
  * false, the ID Token and Access Token may include empty claim(s).

* `openid.jwks.httpclient.*` (String)

  Configure the outgoing HTTP communication to the jwksUri specified for the client, to download keys for ID Token encryption. For a list of valid HTTP properties, see [HTTP Client](/nevisauth/setup-and-configuration/components/http-client).

* `openid.jwks.addx5c` (boolean, false)

  This property defines whether `x5c` field will appear in the ID Token header.

  * `true`, the ID Token will include `x5c` field in the token header.
  * `false`, the ID Token will not include `x5c` field in the token header.

* `jwt.bearer.aud` (String)

  Configure the accepted audience for validating JWTs in JWT Bearer flow. If left unset any non-null and non-empty value will be accepted for audience.
--------------------------------------------------------------------------------
Section: ### AuthState / Instance HTTP client
The "instance" HTTP client is **used by most auth states** and allows a per-auth-state configuration of the HTTP client in the _esauth4.xml_ file.
For example, adding the `httpclient.tls.keyObjectRef` property to the auth state configures the key object references for this specific auth state.
The benefit of using this client is having fine-granular control over its behaviour and configuration, for example configuring individual trust stores only used by this client.

```java title="Intance HTTP client"
import ch.nevis.esauth.util.httpclient.api.HttpClient;
import ch.nevis.esauth.util.httpclient.api.HttpClients;
import ch.nevis.esauth.util.httpclient.api.Http;

Properties properties = new Properties();
HttpClient httpClient = HttpClients.create(properties);
Http.get().url("nevis.net").build().send(httpClient); 
```
--------------------------------------------------------------------------------
Section: ### session-management.md
---
sidebar_position: 36
---

# Session management

The session coordinator is responsible for managing the session lifecycle using the _local_ and _remote_ session stores.

The two key phases or states of the nevisAuth session are:

1. Unauthenticated session (also mentioned as initial session)
2. Authenticated session

The authentication engine uses two different inactivity timeouts depending on the authentication phase. The session coordinator enforces the current inactivity timeout and an absolute session lifetime.

The different timeouts are:

* **initial** inactivity timeout

  The user is performing a multistep authentication and has not yet fully established an authenticated session. This timeout is compared against the last access time.

* **established** inactivity timeout

  The user has successfully logged in. This timeout is compared against the last access time during the authentication process.

* **absolute** session timeout

  The session cannot be valid longer than the specified timeout. This timeout is compared against the creation time. This timeout is overridden by the time-to-live attribute of the *[TokenAssembler](/nevisauth/setup-and-configuration/components/token-assemblers-and-keystores#token-assembler)*, if the session was created via the AuthEngine.

When nevisAuth does not receive any session "hits", the established inactivity timeout needs to be equal to the absolute session timeout (the longest acceptable global session lifetime). Session hits may be performed by any client that gets requests from the authenticated user.

As nevisProxy instances know about every request a user is sending, the global authentication session is usually controlled by nevisProxy instances. The above session timeouts therefore are only relevant for limiting unauthenticated sessions and for clearing sessions where no termination notifications from nevisProxy instances arrive.

A simple session store configuration, in conjunction with the timeouts enforced by the AuthEngine, looks as follows:

```xml title="Session store configuration example"
<SessionCoordinator
  sessionInitialInactivityTimeout="600"
  sessionInactivityTimeout="28800"
  sessionInitialMaxLifetime="1200"
  sessionMaxLifetime="28800"
  sessionIdRandomBytes="32">
  
  <LocalSessionStore
     maxSessions="100000"
     reaperPeriod="60" />
  
  <TokenAssembler name="default">
     <Selector default="true"/>
     <TokenSpec version="CSSO-1.0" ttl="28800" algorithm="SHA256withRSA">
     ...
  </TokenSpec>
  
  <Domain name="SSO1" default="true"
     reauthInterval="0"
     inactiveInterval="1800">
     ...
  </Domain>
```

This example enforces:

* A maximum inactivity timeout to perform a login step of 600 seconds (only relevant for stateful multistep authentications), to be enforced by nevisAuth.
* The "screen lock" timeout (i.e., the inactivity timeout, that triggers a reauthentication on an existing session with some minimal credential requirements) is disabled.
* An inactivity timeout of 1800 seconds (i.e., the reverse proxy or client terminates the session and notifies nevisAuth, if the user does not send any requests during this period), to be enforced by the nevisProxy. Note that this setting only applies if the InactivePolicy of the IdentityCreationFilter is set to "global".
* A maximum session lifetime of 1200 seconds for Unauthenticated sessions.
* A maximum session lifetime of 28800 seconds for authenticated sessions, enforced by the lifetime of the security token. This is also the maximum lifetime for the authentication state within the session in nevisProxy.

:::info

Re-authentication (lock/unlock) can be enabled by setting `reauthInterval` to a value higher than 0 (zero). However, note that spontaneously locking sessions during application usage is non-trivial for many modern web applications and compatibility with this behavior should therefore be examined for each application.
:::

## SessionCoordinator configuration

The following list provides an overview of the `SessionCoordinator` configuration attributes for the two main groups regarding session management: lifetime and identifier.

* `sessionInitialInactivityTimeout` (Integer, seconds, optional, 600)

  Default value: `600`

  The session's initial inactivity timeout, which is raised to inactivityTimeout as soon as the initial login is completed. A user needs to perform a login step within this period. Otherwise, the user is forced to start over.

* `sessionInactivityTimeout` (Integer, seconds, optional, 28800)

  Default value: `28800`

  The session's inactivity timeout. When nevisAuth does not get any session events during this period, the session is killed.

  Kill the session if: lastAccessTime + inactivityTimeout <= now

  :::caution

  This attribute must have the same value as the maxLifeTime attribute.
  :::

* `sessionInitialMaxLifetime` (Integer, seconds, optional, 1200)

  Default value: `1200`

  The session's initial absolute timeout (applies to unauthenticated sessions), which is raised to maxLifetime as soon as the initial login is completed (e.g. when the authentication flow reaches `AUTH_DONE`). A user needs to complete the login within this period. Otherwise, the user is forced to start over.

* `sessionMaxLifetime` (Integer, seconds, optional, 28800)

  Default value: `28800`

  The session's absolute timeout. (applies to authenticated sessions)

  Kill the session if: creationTime + maxLifeTime <= now

  This attribute must have a value that is greater than or equal to the maximum of all TokenAssembler's ttl attribute because expired SecTokens already define the maximum lifetime of an authentication session.

* `sessionIdRandomBytes` (Integer, byte, optional, 32)

  Default value: `32`

  The session generates session IDs that are being used as global session identification and are part of the SecToken. The ID is generated by base64 encoding the specified number of true random bytes. The default of 16 bytes therefore represents 128 true random bits. The session ID length therefore is: sessionIdRandomBytes * 4 / 3 + $instance name length$

  :::info

  The session ID inside nevisAuth is prefixed with the nevisAuth instance ID to distinguish sessions generated by different nevisAuth instances.
  :::

* `sessionIdPreGenerate` (Boolean, optional, true)

  Default value: `true`

  Under normal circumstances, a session receives its final ID only after the state `AUTH_DONE` is reached for the first time. At this point, the previous (temporary) session ID is changed to a randomly generated ID as configured using `sessionIdRandomBytes`.

  Under some circumstances, it is desirable to know the final session ID during the authentication process. This can be achieved by setting `sessionIdPreGenerate` to "true". The session variable `ch.nevis.esauth.sess.id.pregenerate` will then be filled with the future session ID upon creation of the session.
--------------------------------------------------------------------------------
Section: ### Terminated session polling
As mentioned before different session lifetime configuration in nevisProxy and nevisAuth requires syncrhonization.

An other use-case where nevisProxy is not aware of session modifications done in nevisAuth is when you use a nevisAuth REST service or nevisAdapt to kill sessions in nevisAuth. In such case you should set `EnablePollTerminatedCalls` to true in the `esauth4Connector` in nevisProxy to synchronize sessions.

Technically nevisProxy calls nevisAuth using the `poll_terminated_sessions` soap operation where nevisAuth will wait for maximum 30 seconds to respond. In case there are session terminations initiated by the caller nevisProxy instance, the reponse with terminated sessions will be returned immediately. In case there are no expired sessions, nevisAuth will send an empty response once 30 seconds passed. nevisProxy will remove the received sessions itself and it will reconnect again to listen for more sessions to be removed.

## Session indexing

nevisAuth sessions can be indexed by a configurable session attribute. Enable indexing by adding the `SessionIndexing` element, see [Session indexing](#session-indexing) for further information.

* `attribute` (String, "$session attribute name$", optional, `ch.nevis.session.loginid`)

  Default value: `ch.nevis.session.loginid`

  Enable indexing on a configured session variable.  

* `attributeMapping` (Enum {none, unicodeEscape, hash}, optional, `hash`)

  Default value: `hash`

  Defines the format in which the session index value is written into the remote session store in case [Session indexing](#session-indexing) is turned on.
  Available mappings are:

  * `none`
  
    The value of the session index is stored as it is in the session without any change (legacy behavior).
  
  * `unicodeEscape`
  
    Non-Latin 1 (ISO 8859-1) characters in the session index value are unicode-escaped (\uxxxx), for example, `abçdefğ` is stored as `ab\u00E7def\u011F`.
  
  * `hash`
  
    The SHA-256 (hex) hash of the session index value is stored, for example, `abçdefğ` is stored as `20c76ac7893952f0d6993b1977ec13893f76cc5fdf4eb4d00f788e89c9101785`.

## Local session store

nevisAuth uses an in-memory session store to hold authentication sessions. This session store uses an inactivity timeout mechanism with a session reaper mechanism to get rid of expired sessions. The session store has an upper limit to prevent uncontrolled session creation and heap space growth.

The use of the `LocalSessionStore` is **required** for the operation of nevisAuth, it cannot be disabled.

The following list provides an overview of the `LocalSessionStore` configuration attributes.

* `maxSessions` (Integer, maximum number, optional, 100000)

  Default value: `100000`

  The maximum number of session entries allowed. This parameter is the upper limit for parallel global authentication sessions. If the reverse proxy is solely using nevisAuth as an authentication infrastructure, only this number of authenticated clients are able to pass the reverse proxy at a time.
  
  Note that once the maximum amount is reached no new session will be created until an existing session expires. In kubernetes based deployments this might not be desired as nevisAuth might look healthy, but actually cannot receive new load.

* `reaperPeriod` (Integer, seconds, optional, 60)

  Default value: `60`

  The reaper thread locks the session cache regularly (defined by this period) to clean up expired sessions.

## Remote session store

Typical reasons for storing sessions remotely are, to provide resilience, and to share sessions between nevisAuth instances.

Whenever a session event is fired, for example when a session is deleted or updated, all session listeners are informed about the recent change. As a listener the remote session store will attempt to synchronize the current state of the session with the remote session database.

The `RemoteSessionStore` element encapsulates the configuration options for the database connection, synchronization features and the cleanup of expired sessions. The remote session store is enabled by defining the `RemoteSessionStore` element. To disable it, either remove the element or comment it out.

By default, setting both authenticated and unauthenticated sessions are synchronized. This can be changed, so only authenticated session are stored.
--------------------------------------------------------------------------------
Section: ### Multiple nevisAuth instances with resilience
More resilience can be achieved by using a replicated MariaDB setup and increasing retry failure. Note that increasing the rerty period and number will have some affects on memory usage in case of high load and prolonged syncronization issues.

```xml title="Example with replicated remote session store databases and retries" {12,17}
<SessionCoordinator
 ...>
 
 <LocalSessionStore 
  maxSessions="100000"/>

 <RemoteSessionStore
  provider="jdbc"
  connectionUser="nss_auth"
  connectionPassword="nss_auth"
  connectionUrl="jdbc:mariadb:sequential//host-db1:3306,host-db2:3306/NSS"
  syncPullInitial="false"
  syncFailRetryPeriod="200"
  syncFailRetryCount="3"
  storeUnauthenticatedSessions="true"/>
```

## Configuring Resilient Session Sharing with MariaDB

This chapter is about resilience towards outages of session sharing database nodes, which differs from resilience towards failures of nevisAuth instances. To achieve resilience towards failures of nevisAuth instances, configure two nevisAuth instance addresses in nevisProxy. Such a configuration enables failover to the second nevisAuth instance if nevisProxy cannot connect to the first nevisAuth instance. For more information, see the nevisProxy reference guide (`InetAddress` parameter of the *HttpConnectorServlet*).
--------------------------------------------------------------------------------
Section: ### Resilience to Database Instance Outage
This chapter explains how to set up two MariaDB instances for session sharing with replication . The advantages of this solution are:

* Sharing of sessions between nevisAuth instances and support of nevisProxy for failover for the nevisAuth instances.
* Resilience towards outage of one of the MariaDB instances or its host (e.g., in case of a power outage).
* Resilience towards a failure of the network infrastructure between nevisAuth and one of the MariaDB instances (e.g., in case of a data center outage).

:::info

The above statements hold only as long as at least one of the two MariaDB instances is running and reachable. Simultaneous outage of both database instances hinders nevisAuth from sharing sessions.
:::
--------------------------------------------------------------------------------
Section: ### certificates-keys-and-public-key-infrastructure.md
---
sidebar_position: 26
---

# Certificates keys and public key infrastructure

Key material is used for various tasks in nevisAuth:

* Data signing (e.g., identity token signing)
* Data encryption (e.g., SAML response encryption)
* Transport security (SSL/TLS) in the front end (server)
* Transport security (SSL/TLS) in the back end (e.g., LDAPS or HTTPS connections)
* Certificate validation (expiration checking, trust validation, revocation checking)

Key material can be stored in the filesystem, on an HTTP webserver, on LDAP or on a hardware security module (HSM). Certificates stored on the file system, on an HTTP server or on LDAP will be frequently updated if not specified otherwise. It is also possible to use resource pools instead of directly configuring the path or URL to the resources. This enables failover or load balancing functionality.
--------------------------------------------------------------------------------
Section: ### rest-service-implementations.md
---
sidebar_position: 46
---

# REST service implementations

## TAN service

The TAN service is a REST service that sends TAN messages to recipients and responds to the client with the TAN code that it sent to the recipient. This service can access any session parameter when given the SecToken of the user. Alternatively, it can also operate stateless. The following list depicts the configuration properties of the TAN REST service:

* Class

  `ch.nevis.esauth.rest.service.TANService`

* Logging

  `REST`

* Default base path

  `/tan`

* Properties

  * `tanTemplate` (string, "6{ABCDEFGHIJKLMNOPQRSTUVWXYZ}")

    The template from which the TAN is formed. Defaults to 6 uppercase characters.

  * `sender` (string, -)

    The sender of the TAN. Can be overridden by query or form parameters.

  * `recipient` (string, -)

    The recipient of the TAN. Depending on the TAN channel this might be a mobile phone number or an e-mail address. Can be overridden by query or form parameters.

  * `messageTemplate` (string, "MTAN authentication code: ${notes:mtan.challenge}")

    The message template sent to the recipient. The actual message can be overridden by query or form parameters.

  * `channel` (string, "SMTP")

    The channel used to send the TAN message. Valid channels are "smtp", "aspsmssoap", "ucp", "http", "Swissphone", "null". The channel properties are described in [TAN authentication plug-ins](../../authentication-plugins-and-authstates/standard-authentication-authstates-and-plugins/tan-authentication-plugins.md).

  * `customerField` (string, -)

    This string can only be used with the _SwissPhone_ channel. It is optional. According to the IMASYS specification its maximum length is 254 chars with the "iso-8859-1" charset.

```xml title="Example"
<RESTService name="tanService" class="ch.nevis.esauth.rest.service.TANService" path=" /tan">
      <property name="rolesAllowed" value="nevisAuth.tanUser"/>
      <property name="channel" value="HTTP"/>
      <property name="httpUrl" value="http://www.smsbooster.com/send.asp"/>
      <property name="httpHeader.Referer" value="https://intranet.nevis.com/sms_service/index.htm"/>
      <property name="httpSuccessStatus" value="200-399" />
      <property name="httpParam.SMSTelefon" value="${notes:tan.http.receivers}"/>
      <property name="httpParam.smsMessage" value="${notes:tan.http.message}"/>
      <property name="httpParam.USERID" value="<yourID>" />
      <property name="httpProxyHost" value="proxy.nevis.com"/>
      <property name="httpProxyPort" value="3128"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of a TAN service:

* `GET`

  Path: `generate`

  MIME response type: `application/xml`,`application/json`

  Generates a TAN, sends it to the defined recipients and responds to the client with the generated TAN code.

  * `sender` (string, -)

    The sender of the TAN message. This will override the "sender" property if defined.

  * `recipient` (string, -)

    The recipient of the TAN message. This will override the "recipient" property if defined.

  * `message` (string, -)

    The message template of the TAN message that is sent to the recipient through the channel.
    This will override the "messageTemplate" property if defined.

  * `lang` (string, -)

    The language of the message template. If this parameter is not set, the default language of the authEngine is selected.

    Furthermore, channel-specific properties can be overridden by handing a parameter with the same name.
    This works for the following channel-specific properties:

    * smtpSubject
    * smtpHost
    * smtpPort
    * smtpUser
    * smtpPass

    See [TAN authentication plug-ins](../../authentication-plugins-and-authstates/standard-authentication-authstates-and-plugins/tan-authentication-plugins.md) for a detailed description of the channel-specific properties.

* `POST`

  Path: `generate`

  MIME response type: See corresponding `GET` method

## SAML metadata service

The SAML metadata service provides a document describing the available *IdentityProvider* entities for the nevisAuth instance. The service complies with the specification "Metadata for the OASIS SAML V2.0". For details, see [Metadata for the OASIS SAML V2.0](https://docs.oasis-open.org/security/saml/v2.0/saml-metadata-2.0-os.pdf).
The metadata can be used by *ServiceProviders*, for example if the *ServiceProvider* supports automatic importing of IdP information. The following information is provided:

* A unique ID that identifies the `idpDescriptor`.
* The supported protocol (SAML 2.0).
* Public signature and encryption key info material.
* Supported SAML bindings.
* List of issued SAML attributes.
* `NameID` descriptions.

The provided metadata will be signed with the configured signer key.

The following list describes the SAML metadata service:

* Class

  `ch.nevis.esauth.rest.service.SAMLMetadataService`

* Logging

  `REST`

* Default base path

  `/meta/SAML2.0`

  The REST service is available under the "/nevisauth/meta/SAML2.0" URL using the GET method.

* Properties

  * `state.<name>` (string, -)

    The name of the state of which metadata should be published..

  * `signatureKeyInfo` (string, "certificate")

    The content of the keyinfo which should be delivered when requesting SAML metadata.

  * `keystoreref` (string, "DefaultKeyStore")

    The keystore which contains the keyobject that should be used to sign the metadata.

  * `keyobjectref` (string, -)

    The signer with which the metadata should be signed with.

```xml title="Example"
<RESTService name="SAMLMetadataService"
          class="ch.nevis.esauth.rest.service.SAMLMetadataService"
          path="/rest/samlmeta">
     <property name="state.MyIdentityProvider1"
          value="https://nevisauth.com/idp1"/>
     <property name="state.MyIdentityProvider2"
          value="https://nevisauth.com/idp2"/>
     <property name="out.keystoreref" value="SAMLMetadataKeyStore"/>
     <property name="out.keyobjectref" value="SAMLMetadataSigner"/>
</RESTService>
```

The following list shows the available HTTP methods for the REST interface of a SAML metadata service:

* `GET` `/nevisauth/meta/SAML2.0`

  MIME response type: `application/samlmetadata+xml`

  Retrieves the metadata of all known entities.

* `GET` `/nevisauth/meta/SAML2.0/{id}`

  MIME response type: `application/samlmetadata+xml`

  Retrieves metadata by ID (SAML 2.0 Entity Descriptor entity ID).
  In case of an IdentityProviderState, the entity ID will be the out.issuer parameter by default.

  * `id` (string, -)

    The entity ID of a SAML 2.0 Entity Descriptor.

## OAuth 2.0 token introspection service

The OAuth 2.0 token introspection service as defined in the [RFC 7662](https://tools.ietf.org/html/rfc7662) is:

> [...] a method for a protected resource to query an OAuth 2.0 authorization server to determine the active state of an OAuth 2.0 token and to determine meta-information about this token.

nevisAuth provides this service out-of-the-box.  The resource, which is the HTTP client of the service, must provide the name of the authorization server to be used to validate the token. This is the [AuthorizationServer](../../authentication-plugins-and-authstates/oauth-2.0-and-openid-connect-plugins/authorization-server-and-open-id-connect-provider-plugins/authorizationserver.md) AuthState that generates the tokens to protect the resource. The name of the *AuthorizationServer* AuthState is provided as a path parameter in the URL of the HTTP request.

The following list describes the OAuth 2.0 token introspection REST service:

* Class

  `ch.nevis.esauth.rest.service.tokenintrospection.TokenIntrospectionService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/oauth/introspect`

* `authstates` (string, -)

  Comma-separated list of names of [AuthorizationServer](../../authentication-plugins-and-authstates/oauth-2.0-and-openid-connect-plugins/authorization-server-and-open-id-connect-provider-plugins/authorizationserver.md) AuthStates that are exposed by the token introspection service. If this list does not include the name of a specific AuthorizationServer, the service will report all tokens for this authorization server as being invalid.

* `authentication` (string {"BASIC"}, -)

  Space-separated list of methods accepted for authentication using the request header. For more information see OAuth 2.0 Token Introspection. More info how to do authentication with token introspection service here.

```xml title="Example"
<RESTService name="tokenIntrospection" class="ch.nevis.esauth.rest.service.tokenintrospection.TokenIntrospectionService" path="/oauth/introspect">
        <property name="authstates" value="AuthorizationServer1, AuthorizationServer2"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of the OAuth 2.0 token introspection service:

* `POST` `/nevisauth/oauth/introspect/{AuthorizationServerName}`

  Retrieves the state of a token for a given AuthorizationServer.

  See the [Token Introspection specification](https://tools.ietf.org/html/rfc7662#section-2.1) for details.

  * `AuthorizationServerName` (string, -)

    The name of the authorization server against which to validate the token (that is, the name of the respective AuthorizationServer AuthState).

* `POST` `/nevisauth/oauth/introspect/`

  Retrieves the state of a token for a given AuthorizationServer.

  See the [Token Introspection specification](https://tools.ietf.org/html/rfc7662#section-2.1) for details.

  :::info
  This endpoint can only be used when only one AuthorizationServer AuthState is configured in the RESTService
  :::
--------------------------------------------------------------------------------
Section: ### Request and response examples using cURL
* **Example 1 - Invalid refresh token**

  The following command line example queries nevisAuth. It asks whether the refresh token with value *2YotnFZFEjr1zCsicMWpAA* is valid for the *AuthorizationServer* named *authServer*. The server answers that the token is not valid.

  ```
  curl 'https://siven.ch:8991/nevisauth/oauth/introspect/authServer' -i -X POST \
    --insecure --cert /var/opt/keybox/public/node_keystore.pem:password \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    -d 'token=2YotnFZFEjr1zCsicMWpAA&token_type_hint=refresh_token'

  HTTP/1.1 200 OK
  Date: Mon, 08 Jul 2019 10:15:18 GMT
  Content-Type: application/json
  Content-Length: 17
  {"active": false}

  ```

* **Example 2 - Valid access token**

  The following command line example queries nevisAuth. It asks whether an access token is valid for the *AuthorizationServer* named *sivenAuthServer*. The client does not provide any information on the token type (there is no attribute *token_type_hint*). The server answers that the token is valid and provides some additional information (note that the output of the cURL command line is modified for the sake of clarity):

  ```

  curl 'https://siven.ch:8991/nevisauth/oauth/introspect/sivenAuthServer' -i -X POST \
    --insecure --cert /var/opt/keybox/public/node_keystore.pem:password \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    -d 'token=eyJlbmMiOiJBMjU2R0NNIiwiYWxnIjoiUlNBLU9BRVAtMjU2In0.eiIwgVmejF087iqtrXjQ-xvRByUVyNuiHpxZn5VUfKuW1U3NP8EtSjnGfrcYm7M-uzdaUxmOwAD_c_PerHjPEpERQ91uxCACPQiY23IyzJKaPp9QByRptZLdyd8cwSg4u5OBAq9R1RDO4vTdHpn5E8K7jmQILXnASC_s9DrHsy0.64RgOvcQgqz8Eoff.oKUt3euLvn9AUKuE6IIu62Pz2slX4X68_G6j48B7xb1Bjcti4wIfpuY0Sr8X6KU-miHOY6BTLVUg2hmkzHAX4Mu65HG98UgmiEnOmru5qnzWzXBqOxxUAKSgoo-VZAYrDblSjTDOIZ-Q3n2n_eYDtnh2_lGZEjbGuMRsHhQu-qWoO3I_PSRSh9_w-Aia8XItE0p1tGz4fD7AG8Ox0LQfnA_Lx2an76elVpJFF6ZAFHnR5U1r9DFuFGgBayEi2N8qHiyrSsr214SA_36vpraUaEqg1rKkkIAmt0_QNI9beMAp7HEU-8dUs6ovHniUVkvU-_NkaIuGsddwUjXwSFH0MH70bAP_Y_aTtL5SJa9TMVs7yy31pIg6NCg4OIBABgLlVAa1W3scEb5bXPNSR6O2fPnt0SURi0QRzRJlz778zWYzagqjhtGUoM6nKt1fYdCOwhgvXZajgZHQUBy4FGS_76WTYauXgAVaV_6XbRG4JM9FNZHK1TaiNJiiCu_jDUsQERu9JfLLOHRmB9JhTmLPAxh6Vcx4dd7dkYPH.gbcKRDPaXAGA3fKaXEu8uA'
  HTTP/1.1 200 OK
  Date: Mon, 16 Jul 2019 18:11:54 GMT
  Content-Type: application/json
  Content-Length: 243
  {
      "active": true,
      "client_id": "sdfo2992342335232",
      "username": "michel",
      "scope": "user:read user:write",
      "sub": "1231sdwraewerwee",
      "aud": "https://siven.ch/resource",
      "iss": "https://www.siven.ch",
      "exp": 1563295046,
      "iat": 1563294446
  }

  ```

## OAuth 2.0 token revocation service

The OAuth 2.0 token revocation service as defined in the [RFC 7009](https://datatracker.ietf.org/doc/html/rfc7009) is as follows:

> [...] allows clients to notify the authorization server that a previously obtained refresh or access token is no longer needed. This allows the authorization server to clean up security credentials.

nevisAuth provides this service out of the box. The resource, which is the HTTP client of the service, has to provide the name of the authorization server to be used to revoke the token. The same *AuthorizationServer* AuthState that generated the tokens is used to revoke them. The name of the *AuthorizationServer* AuthState is provided as a path parameter in the URL of the HTTP request.

The following list describes the OAuth 2.0 token revocation REST service:

* Class

  `ch.nevis.esauth.rest.service.tokenrevocation.TokenRevocationService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/oauth/revoke`

* Properties

  * `authstates` (string, -)`

    Comma-separated list of names of AuthorizationServer AuthStates that are exposed by the token revocation service. If this list does not include the name of a specific AuthorizationServer, the nevisAuth logs error, and does not start.

  * `authentication` (string {"BASIC"}, -)

    Space-separated list of methods that will be accepted for authenticating using the request header. For more information, see [RFC 7009](https://datatracker.ietf.org/doc/html/rfc7009#section-2.1). More info how to do authentication with token revocation service here.

```xml title="Example"
<RESTService name="tokenRevocation" class="ch.nevis.esauth.rest.service.tokenrevocation.TokenRevocationService" path="/oauth/revoke">
        <property name="authstates" value="AuthorizationServer1, AuthorizationServer2"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of the OAuth 2.0 token revocation service:

* `POST` `/nevisauth/oauth/revoke/{AuthorizationServerName}`

  Revokes a token of a given AuthorizationServer.

  See the [RFC 7009](https://datatracker.ietf.org/doc/html/rfc7009#section-2.1) for details.

  * `AuthorizationServerName` (string, -)

    The name of the authorization server against which to revoke the token (that is, the name of the respective AuthorizationServer AuthState).

* `POST` `/nevisauth/oauth/revoke/`

  Revokes a token of a given AuthorizationServer.

  See the [RFC 7009](https://datatracker.ietf.org/doc/html/rfc7009#section-2.1) for details.

  This endpoint can only be used when only **one** AuthorizationServer AuthState is configured in the RESTService

:::info

When multiple instances of nevisAuth having the same OAuth2/OIDC flow, you need to setup the MariaDB OOCDs to share revoked token(s) between instances.
:::

## JSON Web Key Set (JWKs)

The OAuth 2.0 JSON Web Key Set as defined in the [RFC 7517](https://datatracker.ietf.org/doc/html/rfc7517) is:

> [...] JWKs and JWK Sets are used in the JSON Web Signature [[JWS](https://datatracker.ietf.org/doc/html/rfc7517#ref-JWS)] and JSON Web Encryption [[JWE](https://datatracker.ietf.org/doc/html/rfc7517#ref-JWE)] specifications.

nevisAuth provides this service out of the box. The resource, which is the HTTP client of the service, has to provide the name of the authorization server to be used to expose the JWKs.

The following list describes the JWKs service:

* Class

  `ch.nevis.esauth.rest.service.jsonwebkey.JWKSService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/.well-known/jwks.json`

* Properties

  * `authstates` (string, -)

    Comma-separated list of names of AuthorizationServer  AuthStates that are exposed by the JWKs. If this list does not include the name of a specific [AuthorizationServer](../../authentication-plugins-and-authstates/oauth-2.0-and-openid-connect-plugins/authorization-server-and-open-id-connect-provider-plugins/authorizationserver.md), the nevisAuth logs error, and does not start.

```xml title="Example"
<RESTService name="jwks" class="ch.nevis.esauth.rest.service.jsonwebkey.JWKSService" path="/.well-known/jwks.json">
 <property name="authstates" value="AuthorizationServer1, AuthorizationServer2"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of the JWKs service:

* `GET` `/nevisauth/.well-known/jwks.json`

  Get JWKs of a given AuthorizationServer.

  See the [JWKs RFC](https://datatracker.ietf.org/doc/html/rfc7517) for details.

## OAuth 2.0 Authorization Server Metadata

The OAuth 2.0 Authorization Server Metadata as defined in the [RFC 8414](https://datatracker.ietf.org/doc/html/rfc8414) is:

> [...] The metadata for an authorization server is retrieved from a well-known location as a JSON [[RFC8259](https://datatracker.ietf.org/doc/html/rfc8259)] document, which declares its endpoint locations and authorization server capabilities.

nevisAuth provides this service out-of-the-box. The resource, which is the HTTP client of the service, must provide the name of the authorization server and necessary endpoints to be used to expose the Authorization Server Metadata.

The following list describes the Authorization Server Metadata:

* Class

  `ch.nevis.esauth.rest.service.oauthdiscovery.DiscoveryService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/.well-known/openid-configuration`

* Properties

  * `authstate` (string, -)

    AuthState that contains the information to be used by the Authorization Server Metadata (e.g: scopes, grant_type, response_type,...). If it is not the name of an existing AuthorizationServer, the nevisAuth will log error and won't start.

  * `issuer` (string: URI, -)

    The authorization server's issuer identifier, which is a URL that uses the "https" scheme and has no query or fragment components. If this property is not set, the Issuer will be automatically extracted from the AuthorizationServer AuthState. If no issuer is found neither from the AuthorizationServer nor from the configuration, nevisAuth will show an error.

  * `authorizationEndpoint` (string: URI, -)

    URL of the authorization server's authorization endpoint [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749). This is REQUIRED unless no grant types are supported that use the authorization endpoint (authorization code grant and implicit grant are using authorization endpoint).

  * `tokenEndpoint` (string: URI, -)

    URL of the authorization server's token endpoint [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749). This is REQUIRED unless only the implicit grant type is supported.

  * `registrationEndpoint` (string: URI, -)

    URL of the authorization server's OAuth 2.0 Dynamic Client Registration endpoint. (more info)

  * `jwksService` (string, -)

    Name of the [JWKs Service](#json-web-key-set-jwks). If this property is configured, the jwks_uri will be automatically generated using the nevisAuth root context.

  * `jwksUri` (string: URI, -)

    URL of the authorization server's JWK Set [JWK](https://datatracker.ietf.org/doc/html/rfc8414#ref-JWK) document. If this property is not set, the jwks_uri will be automatically extracted from the jwksService configured above.

  * `revocationService` (string, -)

    Name of the [Revocation Service](#oauth-20-token-revocation-service). If this property is configured, the revocation_endpoint will be automatically generated using the nevisAuth root context.

  * `revocationEndpoint` (string: URI, -)

    URL of the authorization server's OAuth 2.0 revocation endpoint [RFC7009](https://datatracker.ietf.org/doc/html/rfc7009). If this property is not set, the revocation_endpoint will be automatically extracted from the revocationService configured above.

  * `introspectionService` (string, -)

    Name of the [Introspection Service](#oauth-20-token-introspection-service). If this property is configured, the _introspection_endpoint_ will be automatically generated using the nevisAuth root context.

  * `introspectionEndpoint` (string: URI, -)

    URL of the authorization server's OAuth 2.0 introspection endpoint [RFC7662](https://datatracker.ietf.org/doc/html/rfc7662). If this property is not set, the introspection_endpoint will be automatically extracted from the introspectionService configured above.

  * `parService` (string, -)

    Name of the [PAR Service](https://github.com/nevissecurity/docs.nevis.net/blob/integration/2023-05-IS-release/docs/nevisauth/setup-and-configuration/components/rest-service-api/rest-service-implementations.md#pushed-authorization-requests-service). If this property is configured, the _pushed_authorization_request_endpoint_ will be automatically generated using the nevisAuth root context.

  * `parEndpoint` (string: URI, -)

    URL of the authorization server's OAuth 2.0 Pushed Authorization Request Endpoint [RFC9126](https://datatracker.ietf.org/doc/html/rfc9126). If this property is not set, the _pushed_authorization_request_endpoint_ will be automatically extracted from the parService configured above.

  * `userinfoEndpoint` (string: URI, -)

    URL of the authorization server's [OAuth 2.0 UserInfo Endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo).

```xml title="Example"
<RESTService name="discovery" class="ch.nevis.esauth.rest.service.oauthdiscovery.DiscoveryService" path="/.well-known/openid-configuration">
 <property name="authstate" value="AuthorizationServer"/> 
 <property name="issuer" value="https://nevis.net"/>
 <property name="authorizationEndpoint" value="https://nevis.net/auth"/>
 <property name="tokenEndpoint" value="https://nevis.net/token"/>
</RESTService>
```

The following list shows the HTTP methods available for the REST interface of the Authorization Server Metadata service:

* `GET` `/nevisauth/.well-known/openid-configuration`

  Get metadata of a given AuthorizationServer.

  See the [Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414)

## Pushed Authorization Requests Service

The OAuth 2.0 Pushed Authorization Requests as defined in the [RFC 9126](https://datatracker.ietf.org/doc/html/rfc9126) is:

> [...] JWT-Secured Authorization Request (JAR) [RFC9101](https://datatracker.ietf.org/doc/html/rfc9101) provides solutions for the security challenges by allowing OAuth clients to wrap authorization request parameters in a Request Object, which is a signed and optionally encrypted JSON Web Token (JWT) [RFC7519](https://datatracker.ietf.org/doc/html/rfc7519).

To cope with the size restrictions, JAR introduces the request_uri parameter that allows clients to send a reference to a Request Object instead of the Request Object itself.

nevisAuth provides this service out of the box. The resource, which is the HTTPS client of the service, has to provide the name of the authorization server to be used to expose the PAR.

The following list describes the PAR service:

* Class

  `ch.nevis.esauth.rest.service.par.PARService`

* Logging

  `REST` and `OAuth2`

* Default base path

  `/par`

* Properties

  * `authstate` (string, -)

    Name of AuthorizationServer AuthStates that is using for PAR. 
If this property does not include the name of a specific [AuthorizationServer](../../authentication-plugins-and-authstates/oauth-2.0-and-openid-connect-plugins/authorization-server-and-open-id-connect-provider-plugins/authorizationserver.md), the nevisAuth logs error, and does not start.

  * `lifetime` (duration in seconds, 90)

  Maximum duration in seconds for PAR request URI to be valid. The config value from 5 to 600.

  * `authentication` (string {"BASIC"}, -)

    Space-separated list of methods accepted for authentication using the request header.

```xml title="Example"
<RESTService name="par" class="ch.nevis.esauth.rest.service.par.PARService" path="/par/">
 <property name="authstate" value="AuthorizationServer1"/>
</RESTService>
```

The following list shows the HTTPS methods available for the REST interface of the PAR service:

* `POST` `/nevisauth/par`

  Send Authorization Data to PAR Service of a given AuthorizationServer.

  See the [PAR](https://datatracker.ietf.org/doc/html/rfc9126) for details.

## Session management and termination API

Using the Session management and termination API, you can terminate and remove one or more sessions in nevisAuth. Using the API does not trigger logout in federation use cases.

:::info Experimental feature
API and implementation are likely going to change in the future.
:::
--------------------------------------------------------------------------------
Section: #### Terminated session polling
Whenever nevisAuth terminates a session, nevisProxy is not automatically aware. To keep nevisProxy in the loop, the *EnablePollTerminatedCalls* has to be set to *true* in the *Esauth4ConnectorServlet* in the nevisProxy instances connected to the nevisAuth instance. By default, the feature is turned off.

## Session Management REST Endpoint

* Class

  `ch.nevis.esauth.rest.service.session.ManagementService`

* Logging

  `REST`

* Default base path

  `/management/session`

```xml title="Example"
<RESTService name="ManagementService" class="ch.nevis.esauth.rest.service.session.ManagementService" />
```

The following list shows the HTTP methods available for the REST interface of the nevisAuth session management service:

* `DELETE` `/nevisauth/management/session/<sessionId>`

  Deletes session based on sessionId.

  HTTP status codes:
  * `204` OK
  * `400` Missing input
  * `404` Missing / invalid session
  * `500` Error

* `DELETE` `/nevisauth/management/session`

  Query parameter: `attributeName`, `attributeValue`

  Deletes sessions based on provided query parameters.

  * `attributeName` has to match the attributeName used for Session indexing, defaults to `loginId`
  * `attributeValue` the value used to find sessions

  HTTP status codes:
  * `204` OK
  * `400` Missing input
  * `404` Missing / invalid session
  * `500` Error
--------------------------------------------------------------------------------
Section: ### authstate-integration.md
---
sidebar_position: 600
---

# Plugin Deployment

In the [Quickstart](quickstart) chapter, we already learned how to integrate a simple custom AuthState into our nevisAuth instance. This chapter provides more insight into how to deal with specific situations.

## Plugin Packaging

A nevisAuth Plugin should bring all its required dependencies, except the `nevisauth-authstate-api`.
By default the `pom.xml` generated by the Maven archetype uses the [Apache Maven Assembly Plugin](http://maven.apache.org/plugins/maven-assembly-plugin) to create a `ZIP archive` file containing the Plugin `jar` file and all its transitive `compile` and `runtime` dependencies in the subfolder `lib`.
Additionally, the files `README`, `LICENSE`, and `NOTICE` are included if they exist in the project base directory.

## Plugin Classpaths

nevisAuth plugins are loaded when the nevisAuth instance starts. The AuthEngine checks specific paths on the filesystem to find the configured AuthStates and their dependencies.

The paths that are investigated by the AuthEngine are configured in the nevisAuth configuration:

```xml
<AuthEngine name="AuthEngine"
    classPath="/opt/nevisauth/plugin:/var/opt/nevisauth/default/plugin"
    classLoadStrategy="PARENT_FIRST"
    useLiteralDictionary="true"
    addAutheLevelToSecRoles="true"
    compatLevel="none"
    inputLanguageCookie="LANG"
>
```

The plugins that are delivered with the nevisAuth package are located in the `/opt/nevisauth/plugin` directory.
We recommend putting instance-specific plugins into the instance directory: `/var/opt/nevisauth/<instance-name>/plugin`.

The classloading strategy defines how the classes are discovered by the classloader. With `PARENT_FIRST`, the AuthEngine classloader first checks whether the class has already been loaded by a parent classloader (which is the container's classloader). With `PARENT_LAST`, the AuthEngine classloader will try to discover and load the class, but delegate the class loading to the parent if it cannot be found.

Different strategies have different effects. With `PARENT_FIRST`, you reduce the amount of the MetaSpace memory of the Java virtual machine. However, if you are using libraries that also exist in the web application server classpath it is recommended using `PARENT_LAST` to avoid classloading conflicts.

## Classpath Conflict Resolution

Similar to the problem of loading classes from the AuthEngine's classpath first vs. loading classes from the web application server's classpath first, different plugins may also produce library conflicts.
Therefore, it is sometimes necessary to configure a classpath on the AuthState to avoid library dependency confusion. This will lead to a separate classloader being used for that AuthState (an AuthState classloader).

The problem can be illustrated as follows:

Imagine an AuthState A, which depends on library_v1 and an AuthState B, which depends on library_v2. If the libraries contain the same classes but implement different functionality or method signatures, nevisAuth may fail during runtime because AuthState A and B expect a
different behavior of the library.

This can be solved by configuring a separate classloader per AuthState, as the following example shows:

```xml
<AuthState name="UseridPasswordState" class="ch.example.UseridPasswordFileAuthState"
        classPath="/var/opt/nevisauth/default/plugin/auth-state-example-1.0-SNAPSHOT"
        classLoadStrategy="PARENT_LAST">
    <ResultCond name="ok" next="AuthDone"/>
    <ResultCond name="failed" next="AuthError" />
    <property name="passwordFileLocation" value="/var/opt/nevisauth/default/conf/passwords.txt"/>
</AuthState>
```

In this case, the `ZIP archive` `auth-state-example-1.0-SNAPSHOT.zip` containing the AuthState `ch.example.UseridPasswordFileAuthState` must be extracted into the directory `/var/opt/default/plugin`.
Due to the `PARENT_LAST` class loading strategy, the directory `/var/opt/nevisauth/default/plugin/auth-state-example-1.0-SNAPSHOT` will be consulted first before checking the AuthEngine's classpath for loading classes.

Note that with some libraries you cannot have multiple jar entries on various classloading levels. (either the same or different version)
Such example is the Slf4j API using log4j2 as implementation. Define such dependencies in your dependency list as provided.
--------------------------------------------------------------------------------
Section: ### GUI Generation
As a general rule, a GUI is always generated if an AuthState responds with an `AUTH_CONTINUE` or `AUTH_ERROR` response.
nevisAuth does not generate GUIs itself. Instead, it builds a _GUI descriptor_ which is sent back to the client.
If the client is nevisProxy, it in turn forwards it to nevisLogRend, the login renderer application.
The login renderer then responds with an HTML document that implements the GUI described in the GUI descriptor. This rendered GUI will then be forwarded by nevisProxy to the end-user's user agent.

The GUI descriptor is configured in the AuthState configuration as part of the response element of an AuthState.
It guides the login renderer to create a certain GUI by describing the content, but not the layout, of the GUI.

The following code snippet shows an example of the GUI descriptor as part of an AuthState configuration.

Refer to [Response generation](/nevisauth/setup-and-configuration/components/authentication-engine/authentication-processing-authstates-and-state-flow#response-generation) for more detailed information.

```xml
<Gui name="LoginPage" label="UIDPWDialog">
  <GuiElem name="isiwebuserid" type="text" label="Username" value="" />
  <GuiElem name="isiwebpasswd" type="pw-text" label="Password" value="" />
  <GuiElem name="submit" type="button" label="Login" value="Login" />
</Gui>
```

## Technology Stack

nevisAuth is a web application written in Java. We are using the following technologies:

| Technology       | Version | Description                                                                                                                                                                          |
|------------------|---------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Linux            |         | Operating System                                                                                                                                                                     |
| Java             | 17      | Compile and runtime environment. As a runtime environment, newer Java versions can (and are) used, because the JVMs are typically backwards compatible.                              |
| Java Servlet API | 5       | The Java Servlet API specifies how HTTP requests are received and how HTTP responses are sent back to the client. nevisAuth implements filters and servlets to handle such requests. |
| Jax-WS           | 4.x     | The web service stack used to retrieve SOAP web service requests and respond with SOAP responses.                                                                                    |
| Jax-RS           | 3.x     | The web service stack used to accept and respond to REST web service calls.                                                                                                          |
--------------------------------------------------------------------------------
Section: ### response-fields.md
| Attribute | Type | Description |
| --------- | ---- | ----------- |
| `statusCode` | `Number` | UAF status code for the authentication operation, see UAF Status Codes. |
| `description` | `String` | Detailed message containing a user-friendly description of the authentication result. This is the stringified representation of the JSON described in the [Authentication Server Response]. |
| `additionalTokens` | `Array` | New authentication or authorization token(s) for the client that are not natively handled by HTTP transport. |
| `location` | `String` | If present, indicates to the client web application that it should navigate to the URI contained in this field. |
| `postData` | `String` | If present, and in combination with `location`, indicates the client should POST the contents to the specified location. |
| `newUAFRequest` | `String` | Server may return a new UAF protocol message with this field. This might be used to supply a fresh request to retry an operation in response to a transient failure, to request additional confirmation for a transaction, or to send a deauthentication message in response to a permanent failure. |
--------------------------------------------------------------------------------
Section: ### response-fields.md
| Attribute | Type | Description |
| --------- | ---- | ----------- |
| `statusCode` | `Number` | UAF status code for the operation, see UAF Status Codes. If the client provided a `dispatchTarget` in the `SendUAFResponse` context, the validation of the FIDO UAF contents was successful, but the dispatch target could not be created, nevisFIDO will return a UAF status code `UNACCEPTABLE_CONTENT` (1498). |
| `description` | `String` | Detailed message containing a user-friendly description of the registration result and the dispatch target ID (if one was created). This is the stringified representation of the JSON described in the [Registration Server Response]. |
| `additionalTokens` | `Array` | New authentication or authorization token(s) for the client that are not natively handled by HTTP transport. |
| `location` | `String` | If present, indicates to the client web application that it should navigate to the URI contained in this field. |
| `postData` | `String` | If present, and in combination with `location`, indicates the client should POST the contents to the specified location. |
| `newUAFRequest` | `String` | Server may return a new UAF protocol message with this field. This might be used to supply a fresh request to retry an operation in response to a transient failure, to request additional confirmation for a transaction, or to send a deregistration message in response to a permanent failure. |
--------------------------------------------------------------------------------
Section: ### Technical architecture
<img className="boxed" src={require('./assets/68816657.png').default} alt="System overview"/>

* *Client tier*: Interface for user interaction, either via the web application or via SOAP calls from a third-party component.
* *Access tier*: Secure reverse proxy (nevisProxy), single point of entry for applications that enables a physical separation of networks. Manages user authentication and authorization in cooperation with the authentication service.
* *Presentation tier*: Visualization of data from business tier.
* *Business tier*: Implementation of the business logic as a set of services and modules.
* *Resource tier*: Persistency management via a directory service (LDAP) or a database (for example MySQL or Oracle).

## Installation and Integration
--------------------------------------------------------------------------------
Section: ##### Content-only view
The nevisWorkflow GUI is designed to be embedded into other web applications on the browser-side within either an iframe or a pop-up window. For proper embedding, it's usually desired to show only the *task form* or *process starting form* without the surrounding menu items and page header. This can be achieved by inserting the "contentonly" part within the URL.

```
/neviswf/contentonly/showTask.xhtml?taskId=1652
```
--------------------------------------------------------------------------------
Section: ##### Failover/Load balancing
Web service endpoint properties (e.g., *ws.adminservice.endpoint, ws.adminservice.clientcert.endpoint*) take a comma-separated list of URLs. If load balancing is *true*, then requests to web services are issued to different endpoints, chosen by a round-robin algorithm. However, after a logged-in user made his/her first request to one of the endpoints, subsequent requests go to the same endpoint afterwards (sticky session).

When a web service call fails due to connection error, the next web service endpoint is taken from the list. Connection to the failed endpoint is retried after a defined retry timeout interval.
--------------------------------------------------------------------------------
Section: #### With manual DB upgrade
:::info Not recommended!
Both Activiti as well as nevisWorkflow DB upgrades might require running a piece of java code packed with the new version of nevisWorkflow. This Java code can handle tasks that cannot be done with pure SQL scripts. For example prefilling a new column with some user information where the information comes from NevisIDM. For Activiti, nevisWorkflow have no control over this requirement. Upgrading the DB manually might cause an inconsistent DB.
:::

1. Install new RPM package of nevisWorkflow

 Install RPM of new version

 ```
 rpm -i neviswf-newversion.rpm
 ```

2. Stop nevisWorkflow

 ```
 neviswf stop
 ```

3. Upgrade database by running the DB upgrade scripts manually
   1. Find the upgrade scripts in the folder `/opt/neviswf/resources/database/sql/<database-type>/upgrade`
      * Prior to nevisWF 1.4.1.0, the database upgrade files are shipped in the neviswf-db-version.tar.gz file*
   2. Find the current version of Activiti and nevisWorkflow database in the ACT_GE_PROPERTY table:
      * *schema.version* – for Activiti
      * *neviswf.schema.version* – for nevisWorkflow
   3. Upgrade the Activiti tables by gradually executing the upgrade scripts starting from the version number in the database to the new Activiti version number. The Activiti DB upgrade scripts can be found in `/sql/<db-type>/upgrade/org/activiti/db/upgrade` folder.
   4. Execute the different components in the following order:
      1. *upgradestep.513.to.515.engine.sql*
      2. *upgradestep.513.to.515.history.sql*
      3. *upgradestep.513.to.515.identity.sql*
   5. Upgrade the nevisWorkflow tables by gradually executing the upgrade scripts found in `/sql/oracle/upgrade/ch/adnovum/neviswf/datamodel/upgrade` in a similar manner.
   6. To keep track of the current database version and for the sake of a later automatic upgrade to work, the `neviswf.schema.version` property is stored in `ACT_GE_PROPERTY` table. For versions prior to `1.2.1.0` this property does not exist, so it first needs to be inserted.

    ```
    INSERT INTO ACT_GE_PROPERTY(NAME_,VALUE_,REV_)
    VALUES('neviswf.schema.version','1.2.1.0', 1);
    ```

      * The `neviswf.schema.version` property is automatically updated, when the nevisWorkflow database upgrade script is executed.
      * The neviswf.schema.version does always correspond to the newest nevisWorkflow version number. The property indicates the last nevisWorkflow version number, where the database has changed (not including Activiti tables).
4. Start nevisWorkflow
   * Start nevisWorkflow with the `start` command. After the new RPM install, the new version of the web application will be deployed.

    ```
    neviswf start
    ```

## Configuration - Workflows

Workflows are standard Activiti workflows. Documentation can be found on the homepage of Activiti.org.
--------------------------------------------------------------------------------
Section: #### nevisIDM
The following table lists the parameters related to nevisIDM.

| Parameter name | Description |
| --- | --- |
| ws.adminservice.endpoint |  Mandatory. Comma-separated list of endpoint URIs of the nevisIDM admin service used. |
| ws.adminservice.wsdl.resource | WSDL resource of the nevisIDM admin service. Default: `/wsdl/nevisidm_adminservice_v1.wsdl`. |
| ws.adminservice.class | Class used as nevisIDM admin service client. Default: `ch.adnovum.nevisidm.ws.services.v1.AdminServiceV1`. |
| ws.adminservice.request.timeout | Request timeout when communicating with the nevisIDM admin service. Default: `120000`. |
| ws.adminservice.connect.timeout | TCP connection timeout when establishing the connection to the nevisIDM admin service. Default: `15000`. |
| ws.adminservice.token.encoding | Forwarded SecToken encoding options Possible values: `automatic` or `null`: Lets the framework encode the password property (re-encode in UTF-8). `forward`: Forwards the whole HTTP authorization header unchanged. You may need to set the TokenEncoding attribute of the Ninja configuration. `character encoding`, for example: `UTF-8`: Converts basic auth header bytes as encoding then converts to Base64.  |
| nevisidm.cache.enabled | Enables caching of nevisIDM results. Used to optimize the performance and reduce the load on nevisIDM. Default: `true`. |
| nevisidm.cache.maxentries | Number of entries stored in the nevisIDM result cache. This number should correspond to the expected number of simultaneous users. Default: `100`. |
| nevisidm.cache.ttl | Lifetime of an entry in the nevisIDM result cache in milliseconds. Default: `60000`. |
| ws.adminservice.loadbalancing | Enable round-robin load balancing between endpoints, when more endpoints are defined. Default: false. |
| ws.adminservice.clientcert.endpoint | Comma-separated list of endpoint URIs of the nevisIDM admin service that use client certificate-based authentication. This endpoint is used by the technical user. |
| ws.adminservice.clientcert.keystore | Path to JKS keystore to be used for two-way SSL, when the *ws.adminservice.clientcert.endpoint* is defined. If this configuration is empty, then `javax.net.ssl.keyStore` is used. Default: empty. |
| ws.adminservice.clientcert.keystore.password | Password for JKS file defined in *ws.adminservice.clientcert.keystore* Default: empty. |
| ws.adminservice.clientcert.alias | Alias of the certificate in `javax.net.ssl.keyStore` used by technical user to connect *ws.adminservice.clientcert.endpoint*. |
| ws.selfadminservice.endpoint | Comma-separated list of endpoint URIs of the nevisIDM self admin service used. |
| ws.selfadminservice.wsdl.resource | WSDL resource of the nevisIDM self admin service. Default: `/wsdl/nevisidm_adminservice_v1.wsdl`. |
| ws.selfadminservice.class | Class used as nevisIDM self admin service client. Default: `ch.adnovum.nevisidm.ws.services.v1.SelfAdminServiceV1`. |
--------------------------------------------------------------------------------
Section: ### Storing passwords in nevisCred
Passwords appearing in neviswf.properties can be stored in nevisCred. Simply use the following syntax where applicable:

```
password.property=neviscred://<passwordId>
```

where `<passwordId>` is the same as it is stored in nevisCred. Example:

```
mail.server.password=neviscred://smtpPassword
```

Prerequisite is to have the nevisCred client available on the same machine where nevisWorkflow is installed. If ncclient is in the default location *(/opt/neviscred/bin/ncclient),* no configuration is needed. To set non-default location, add the following argument to vmargs.conf:

```
-Dch.nevis.neviscred.client=/neviscred/client/location/ncclient
```

Another valid prefix for passwords is *"plain://".* This is only used to mark in the configuration that the password is in plain text. It is the same as without the prefix.

To mark a plain text password, use the following syntax:

```
password.property=plain://<plainTextPassword>
```

where `<plainTextPassword>` is the password itself. For example:

```
mail.server.password=plain://smtpPassword
```

is exactly the same as:

```
mail.server.password=smtpPassword
```

## Operation and Administration - Embedded container deployment

From version 1.11.0.0 on, nevisWorkflow can be deployed in the following ways:

| Deployment Type | Remarks | State |
| --- | --- | --- |
| Wildfly | nevisWorkflow deployed as a web application. | Stable |
| GlassFish | nevisWorkflow deployed as a web application. | Stable |
| Standalone | nevisWorkflow deployed as a web application including an embedded container. | Stable, recommended deployment type |

The following sections describe the configuration of the standalone deployment type.
--------------------------------------------------------------------------------
Section: #### Adnwildfly instance parameters gathering
The recommended way to migrate from containers to standalone is to use the property file. The same property file can be used to create the standalone instance. See the following sample property file:

```script title="Sample property file"
db_type=oracle
db_user_app_password=unwf02
db_user_app_username=******
db_user_adm_username=unwf01
db_user_adm_password=******
db_connection_host=acme.adnovum.ch
db_connection_port=8884
db_connection_db_name=ACME_DB
db_connection_pool_id=neviswfDs
db_connection_url=jdbc:oracle:thin:@acme.adnovum.ch:8884:ACME_DB
db_admin_connection_pool_id=neviswfAdminDs
ws.adminservice.endpoint=https://acme.adnovum.ch:8080/nevisidm/services/v1_39/AdminService
JVM_KEYSTORE_PASSWORD=******
JVM_TRUSTSTORE_PASSWORD=******

```

:::info
From version 1.13.x and above, standalone deployment only uses the property `db_connection_url` to establish a database connection instead of the properties `db_connection_host, db_connection_port` and `db_connection_db_name`. This is to provide more flexibility to the user for further advanced connection configuration, such as load balancing, connection attributes, etc.
:::

If there is no property file, it is suggested to create one, as all settings can be gathered in one place. Also, you can reuse the file later to create the instance.

The */var/opt/neviswf/.setup.defaults* file of the last created instance is a good starting point. As reference, use `/var/opt/adnglassfish/.setup.<instance_name>`  or `/var/opt/adnwildfly/.setup.<instance_name>`. Those files contain all the settings used to create the instance.

On instance creation, it is adviced gathering the property values in the following order:

1. The package defaults
2. The provided property file
3. The properties provided on the command line

This means that first the package defaults will be considered, then the values from the given property file (if any) and finally the properties provided on the command line (if any).
--------------------------------------------------------------------------------
Section: ##### Using the property file during the instance creation
Once you have the property file, you can start with the instance creation. Eexecute one of the following commands:

```
neviswf inst create <new_instance_name> <property_file_location> WF_DEPLOY_TYPE="standalone" NEVISWF_SERVER_URL="<neviswf endpoint>"
```

Some notes:

* It is important to set *WF_DEPLOY_TYPE* correctly to create an **standalone** instance.
* The *NEVISWF_SERVER_URL* parameter is mandatory and specifies whether HTTP or HTTPS has to be used to access the nevisWorkflow web application and the host and port. To find out the endpoint of nevisWorkflow (*neviswf*) on *adnwildfly* - which has to be reused for the new instance - executing the command `neviswf <instance name> status`.

```
neviswf inst create <instance> <property file location> WF_DEPLOY_TYPE="standalone" NEVISWF_SERVER_URL="<neviswf endpoint>"
```
--------------------------------------------------------------------------------
Section: ### glossary.md
---
sidebar_position: 500
---

# Glossary

This page is an alphabetical list of terms and concepts that are useful in understanding Nevis Authentication Cloud functionality. Use the sidebar on the right to browse the page, or your internet browser's **find** (`Ctrl+F` / `⌘+F`) function to search for specific terms.

## Access Key

Access keys are API tokens that allow you to communicate with the Authentication Cloud API. Each access key is a unique identifier that identifies an application or user when making an API request.

## API

API stands for Application Programming Interface. APIs are mechanisms that enable two software components to communicate with each other using a set of definitions and protocols. In the context of APIs, "application" refers to any software with a distinct function. "Interface" can be thought of as a contract of service between two applications. This contract defines how the two communicate with each other using requests and responses.

## Assertion

When a user wants to log into a service, the server sends a challenge and the authenticator signs it with a key pair previously registered to that service. This creates the assertion. The format of the assertion is always the same regardless of the device being used.

## Attestation

Attestation is the process of verification of a generated key pair that is specific to a device. Once the key pair is verified (attested) it can be used to cryptographically prove that the device is genuine. 

## Authentication

Authentication is the process of verifying a user through their registered authenticator before allowing access to a resource. This ensures only those with authorized credentials gain access to secure systems.

The process involves the server providing the authenticator with a challenge, which they cryptographically sign with the key pair created in registration, and then return to the server to confirm authenticity. 

## Biometrics

Biometrics are measurements of physical characteristics that uniquely identify individuals. This includes fingerprint mapping, facial recognition, retina scans etc. Using technologies that can create and compare biometric measurements with very high precision, biometrics can be used to identify and securely authenticate users.

## Cross-platform authenticators

A type of passkey authenticator also referred to as roaming authenticators, it is a portable hardware device that can be used to verify a user's identity across multiple platforms, examples are a security key or a mobile device.

Cross-platform devices allow a user to authenticate on new devices, where a credential does not exist. Therefore allowing users to authenticate into a service even when there existing workstation is lost or corrupted.

## Challenge

A challenge, in terms of challenge-response authentication is a security step, where the client that wants to access a system has to provide evidence, that they have the right to access. The challenge can take the form of a password prompt, a request for biometric authentication, or even a CAPTCHA request.

## Discoverable credentials

Discoverable credentials is a mechanism used in passkeys, that allows a user to authenticate into a service without the need to enter a username or password, providing a significant ease of use advantage to the user.

When used, a user is provided a list of the available, discovered credentials on their authenticator, from which they can select the one to be used.

This mechanism supports the feature Conditional UI or autofill.

## FIDO

FIDO is an abbreviation for Fast Identity Online, and refers to the FIDO Alliance, an open-industry association that promotes passwordless authentication and device attestation solutions. The FIDO UAF and FIDO2 specifications are industry standards that define secure, passwordless authentication solutions.

## Introspection

Token introspection is a mechanism that allows resource servers to get information about access tokens. Through this, resource servers can check the validity of access tokens and discover other information, such as which user and which scopes are associated with the token.

## Mobile app

In the context of Nevis Authentication Cloud, mobile app refers to an app on a mobile device that bears Authentication Cloud functionality, that is used for secure authentication. This can either be a customer application with a Nevis Mobile Authentication SDK integration, or a custom-branded Access App provided by Nevis.

## Multi-device passkeys

Multi device passkeys (MDC) are credentials that can be moved and synced between devices. This means that if a user has multiple devices, they can use the built in authenticator to validate a credential regardless if they are using the device that was used to create the credential.

This offers a higher degree of usability as users can utilize any of their devices to authenticate into services without having to individually enroll each one. MDC’s may also be shared between different users. For example you can AirDrop your passkey to another person in the case of shared accounts.

MDC’s are commonly embedded into devices like a mobile phone, or laptop. Platforms that support MDCs are Windows Hello, Apple iCloud Keychain, and Google password manager.

## One-time password (OTP)

A one-time password is a machine-generated security code that is used as a second factor in traditional multi-factor authentication scenarios. OTPs are typically provided via SMS messages, and they are only valid for a given time period, after which they expire.

SMS OTPs have the advantage of allowing multi-factor authentication that relies on only cell-service on the user device. On the other hand, they provide poor protection in scenarios, when an attacker is in posession of a device.

## Passkey

A passkey is a digital credential, tied to a user account and a website or application. Passkeys allow users to authenticate without having to enter a username or password, or provide any additional authentication factor. This technology aims to replace legacy authentication mechanisms such as passwords.

When a user wants to sign in to a service that uses passkeys, their browser or operating system helps them select and use the right passkey. The experience is similar to the way saved passwords work. To make sure only the rightful owner can use a passkey, the system asks them to unlock their device. This may be performed with a biometric sensor (such as a fingerprint or facial recognition), PIN, or pattern.

## Passkey autofill

The passkey autofill feature is intended to provide an experience for passkeys similar to that of traditional autofill to ease the user experience, and transition users to passwordless authentication.

Passkey autofill integrates passkey options directly into the browser's familiar autofill suggestions. When a user taps on a username field on a website that supports passkeys, the browser shows the available passkeys for that service. The passkey can then be selected, and the browser automatically completes the sign-in process using the device's authentication mechanism e.g. Face ID or fingerprint.

This streamlined approach eliminates the need to search for passkeys or remember which one to use, making passkey authentication more user-friendly and encouraging wider adoption for enhanced security.

## Payment Service Directive 2 (PSD2)

The Revised Payment Services Directive (PSD2) is a European directive introduced in 2009 with the aim to create a more open, competitive, and secure payments landscape in the EU and EAA.

To improve competition in the payments landscape, Payment Services Directive (PSD2) allows non-bank financial institutions to access bank data and bank accounts. This is based on the idea that users own the data and accounts rather than banks, and so they can make the decisions on who should have access to their data. 

## Phishing

Phising is an attempt to steal sensitive information, such as passwords or credit-card numbers in order to gain access to protected resources, or sell the acqiured information. In a phising attempt, the attacker typically impersonates a reputable source to trick users into revealing sensitive information.

## Platform authenticators

Platform authenticators are built-in security features on devices like smartphones and laptops that provide strong authentication without the need for external hardware. They leverage the device's inherent capabilities, such as fingerprint sensors, facial recognition cameras, or PIN codes, to verify the user's identity. Common examples include Apple's Touch ID and Face ID, Windows Hello, and the fingerprint scanners found on many Android devices. These authenticators offer a convenient and secure way to access devices and online services, eliminating the need for passwords and providing a seamless user experience.

## Public key cryptography

Public key cryptography is a method of encrypting or signing data using two encryption keys: a public key, that is available for anyone to use, and a private key, that is kept secret. The public key is used for encryption and signature verification, while the private key is used for decryption and signing. The main benefit of the method is that no secret is stored on the server side, which eliminates the security issues associated with server-side data breaches.

## Push bombing

Push bombing is a multi-factor authentication (MFA) fatigue attack, in which the attacker triggers multiple login attempts to a service, using leaked passwords against a traditional multi-factor authentication setup involving a password plus a second factor. The attacker types in the stolen password, which triggers a push notification on the user authenticator device to complete the authentication using the second factor.

The method is often successful, because - especially in work scenarios - users have to re-authenticate to various services many times a day, which can create a habit of approving second-factor push messages without too much thought.

## Registration

Authenticator registration is the process of setting up a new authenticator, such as a security key or an authenticator app, to allow a user to authenticate using FIDO methods to access a service.

This process involves linking the authenticator to an account through a simple process, such as scanning a QR code on a secondary device or initiating the process from the primary device. Once registered, the authenticator can be used to verify the identity of the user and provide a strong authentication mechanism to access their account.

## Relying party

In the context of Passkeys, the relying party is the web application or service that offers the option for users to log in using passkeys.

## Response signing

Response signing is a security measure to ensure the authenticity of information received from a web application server API. This is an additional measure for when requests to the API are made on devices that you do not control. In practice, the signature is sent along with the API response, and in case an attacker modifies the response body, the signature gets broken. This can be detected in your application backend, so that you can block it.


## REST API

REST API is an interface that two computer systems use to exchange information securely over the internet. REST stands for Representational State Transfer, and it is a software architecture with defined conditions on how the API should work. Using the REST API architecture brings several benefits. An important one is scalabilty. Systems that use REST APIs optimize client server interactions. REST APIs are stateless, meaning that servers do not retain past request data. This reduces server load. RESTful APIs are also independent of the programming languages used to create the server applications.

## REST API requests and responses

The basic function of a REST API is similar to browsing the internet. An API call happens through the following steps:

1. The clients contacts the server through sending a request when it needs a resource. The client uses the correct format for the request, as explained in the API documentation of the web application.
2. The server performs the authentication of the client to make sure it has permission to make the request.
3. If the authentication is successful, the server receives and processes the request.
4. The server returns a response to the client. This response contains information about whether the request was successful, and if yes, then also the data requested.

## SDK

SDK stands for Software Development Kit, and it is a set of software-building tools in one installable package. An SDK can be used by developers to easily integrate their apps with third party services.

## Single-device passkeys

Single-device passkeys or single device credentials (SDCs) are passkeys that are bound to a specific device, meaning they can only be used to sign in from the device from which they were created. This enhances security by preventing the credential from being copied or transferred to another device.

While they offer strong protection against phishing and account takeovers, their limitation lies in the lack of flexibility for users who frequently switch between devices.

## Strong Customer Authentication (SCA)

Strong Customer Authentication (SCA) is a European regulatory requirement to reduce fraud and make online and contactless offline payments more secure. It applies to all customer-initiated online and contactless offline payments within the EU, EEA and the UK.

SCA requires authentication to employ at least two of the following three elements: 

* Something the user knows, such as a pin or password
* Something the user has, such as a mobile device or a hardware token
* Something the user is, meaning biometric measurements 

## Token

An authentication token is a computer-generated code that is used to verify the identity of a user. The use of tokens allows users access to resources, without having them re-enter their login credentials each time they visit. Auth tokens are encrypted and machine-generated. They can expire and can be revoked, which provides better protection against attack scenarios like brute-force attacks or stolen passwords.

## Transaction signing

Transaction signing is a security measure, where a user authenticates again when reviewing the transaction they are making. This marks it as valid and authentic. In terms of secure authentication, this means that when committing to a sensitive transaction - such as transferring money through a banking application, the user is asked to authenticate using their pre-registered secure authentication method. This ensures that no sensitive transaction is processed without the explicit permission of the authenticated user, even if the user has already authenticated for login to the application.

## Two-factor authentication (2FA)

Two-factor authentication (2FA) is a security measure that requires two separate forms of authentication to allow access to a resource. Two-factor authentication can be used to strengthen the security of a system.

## User presence

With user presence (UP), the intent is to ensure that a user is physically present and in control of the authenticator. For example, an external hardware device used for authentication might have a touch sensor that cannot be controlled by software. The primary function of user presence is to provide some indication that a user was physically in control of the device during an authentication or registration ceremony.

## User verification

User verification (UV) serves to ensure that the person authenticating to a service is in fact who they say they are for the purposes of that service. The relying party directs the authenticator to perform user verification, the authenticator performs user verification locally and signals to the application whether user verification was successful. User verification can take various forms, such as password, PIN, fingerprint, face scan, etc. The point is for the user to not only prove physical possession of the device, but ownership of it.

## WebAuthn

WebAuthn, or the Web Authentication API is a specification written by W3C and FIDO as part of the FIDO2 framework. The API allows servers to register and authenticate users without passwords, instead using public key cryptography. With this method, servers can integrate with the strong authenticators built into devices, such as Windows Hello or apple's Touch ID or Face ID, and leverage them for easy and secure authentication.
--------------------------------------------------------------------------------
Section: ### azure-ad-b2c-integration.md
---
sidebar_position: 5
---

import Vimeo from '../../../../src/components/Vimeo';

# Azure AD B2C integration overview

In this tutorial, you learn how to extend your Azure AD B2C (AD B2C) signup and login process with Authentication Cloud, so that your Customers can use passwordless authentication.

Authentication Cloud offers passwordless signup and login for websites and web applications with your Access App. The Access App is branded to match your corporate identity, is built using a hardened SDK, and is FIDO UAF-certified. The solution complies with the Payment Services Directive 2 (PSD2) requirements and provides Strong Customer Authentication (SCA).

**Time to complete the tutorial**: If you are also setting up your AD B2C properties, it takes about 2 hours to complete this tutorial.

:::note Azure AD B2C tutorials
Our Azure AD B2C documentation is based on the official [Microsoft Azure Active Directory B2C documentation](https://learn.microsoft.com/en-us/azure/active-directory-b2c/). In our tutorials, you can find links to the relevant Microsoft pages. In case of discrepancies between the two, refer to the official Microsoft documentation.
:::

Get a glimpse with the following screencast of how cool the passwordless experience for the customers of Muvonda is, once it is integrated to Authentication Cloud.

<Vimeo src="https://player.vimeo.com/video/483106262?badge=0&autopause=0&player_id=0&app_id=58479&h=6f2123e58e" title="Azure AD B2C Biometric Login"/>
--------------------------------------------------------------------------------
Section: ### register-web-app.md
---
sidebar_position: 35
---

import Vimeo from '../../../../src/components/Vimeo';

# Register a web application

<Vimeo src="https://player.vimeo.com/video/694831438?badge=0&autopause=0&player_id=0&app_id=58479&h=6f2123e58e" title="Registering a Web Application"/>

1. Make sure you are using the directory that contains your Azure AD B2C tenant.
2. In the Azure portal, search for and select **Azure AD B2C**.
3. Select **App registrations**, and then select **New registration**.
4. Enter a **Name** for the application. For example, `webapp1`.
5. Under **Supported account types**, select **Accounts in any identity provider or organizational directory (for authenticating users with user flows)**.
6. Under **Redirect URI**, select **Web**, and then enter `https://jwt.ms` in the URL textbox.
7. Under **Permissions**, select the **Grant admin consent to openid and offline_access permissions** checkbox.
8. Select **Register**.

For a web application, you need to create an application secret. The client secret is also known as an application password. The secret is used by your application to exchange an authorization code for an access token.

1. On the **Azure AD B2C - App registrations** page, select the application you created, in our example, `webapp1`.
2. In the left menu, under **Manage**, select **Certificates & secrets**.
3. Select **New client secret**.
4. Enter a description for the client secret in the **Description box**. For example, `clientsecret1`.
5. Under **Expires**, select a duration for which the secret is valid, and then select **Add**.
6. Record the secret Value for use in your client application code. This secret value is never displayed again after you leave this page. You use this value as the application secret in your application code.

Connect the `webapp1` app with the `https://jwt.ms/` app for testing a user flow or custom policy by enabling the implicit grant flow in the app registration:

1. In the left menu, under **Manage**, select **Authentication**.
2. Under **Implicit grant and hybrid flows**, select both the **Access tokens (used for implicit flows)** and **D tokens (used for implicit and hybrid flows)** checkboxes.
3. Select **Save**.

For more information, see [Tutorial: Register a web application in Azure Active Directory B2C](https://docs.microsoft.com/en-us/azure/active-directory-b2c/tutorial-register-applications?tabs=app-reg-ga) in the Microsoft Azure documentation.
--------------------------------------------------------------------------------
Section: ### temenos-registration.md
---
sidebar_position: 10
sidebar_label: Registration with Temenos
---

# Register an authenticator with Temenos

If a user already exists in the customer-side system, you can initiate an authenticator registration that creates the same user in Infinity Fabric and Authentication Cloud and creates a new FIDO UAF authenticator tied to this user. On this page, you can find two main registration use cases: registration using only a mobile banking app, and registration using a mobile banking app and your web banking application.

## Registration using mobile banking app

In this use case, a mobile banking app is used to register an authenticator. The following step list shows the high-level workflow:

1. The user opens the mobile banking app and enters their username and password.
2. The user chooses to register a second-factor authenticator.
3. The user receives an SMS with a code and enters the code into the mobile banking app.
4. The mobile banking app registers the new authenticator with the help of Nevis Mobile Authentication SDK and Authentication Cloud.
6. The mobile banking app receives the registration confirmation.

The following diagram shows a more detailed example of an end-to-end sequence of registering a new PIN or biometric authenticator through a mobile banking app. The diagram includes customer, Temenos, and Authentication Cloud functions, with the following color coding:

* <font color="#F0AC00">Yellow</font>: Temenos functions
* <font color="#168CA9">Blue</font>: Nevis Mobile Authentication SDK and Authentication Cloud functions

:::note Nevis Mobile Authentication SDK
The SDK is integrated into the mobile banking app.
:::

Authentication Cloud functions include API calls to initiate the registration, verify a status token, and optionally, to get the `username`. For more information about these calls, see [Register a mobile app](../../api-doc/api-use-cases/mobile-app/register-mobile-app) and [Retrieve a user](../../api-doc/api-use-cases/manage-users-and-authenticators/retrieve-user).

```plantuml
@startuml

skinparam sequenceMessageAlign direction
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

actor "End-user" as user
participant "Mobile banking app" as app
participant "Infinity Fabric" as infinity
participant "Authentication Cloud" as authcloud
user -[#F0AC00]> app: Enter username and password
app -[#F0AC00]> infinity: Send user credentials
infinity -[#F0AC00]> infinity: Verify credentials
infinity --[#F0AC00]> app: Return result: verification successful
infinity -[#F0AC00]> infinity: Generate SMS challenge
infinity -[#F0AC00]> user: Send SMS
user -[#F0AC00]> app: Enter SMS code
app -[#F0AC00]> infinity: Forward the code
infinity -[#F0AC00]> infinity: Verify the code
infinity -> authcloud: Initiate registration
authcloud --> infinity: Registration initiated
infinity --[#F0AC00]> app: Send the dispatch token and \nthe code verification response
app -> app: Forward the dispatch token to the Nevis Mobile Authentication SDK
app -> app: Register PIN or biometric authenticator, \nand generate public-private key pair
app -> authcloud: Initiate authenticator registration using the dispatch token and the public key
authcloud --> app: Authenticator registered
app -[#F0AC00]> infinity: Send status token to verify the registration
infinity -> authcloud: Check token validity with the status endpoint
authcloud --> infinity: Return token status response
group Optional
    infinity -> authcloud: Get ""username"" by ""userId""
    authcloud --> infinity: Return ""username""
end
infinity --[#F0AC00]> app: Authenticator registration completed

@enduml
```

## Registration using a mobile banking app and a web application

In this use case, both the web banking application and a mobile banking app are used to register an authenticator. The following step list shows the high-level workflow:

1. The user opens the web banking application and enters their username and password.
2. The user chooses to register a second-factor authenticator.
3. The web banking application presents a QR code to start the registration.
4. The user reads the QR code with the mobile banking app.
5. The mobile banking app registers the new authenticator with the help of Nevis Mobile Authentication SDK and Authentication Cloud.
6. The web banking application sends the registration confirmation to the mobile banking app.

The following diagram shows a more detailed example of an end-to-end sequence of registering a new FIDO UAF authenticator using a mobile banking app and your web application. The diagram includes customer, Temenos, and Authentication Cloud functions, with the following color coding:

* <font color="#6F7C80">Gray</font>: Customer functions
* <font color="#F0AC00">Yellow</font>: Temenos functions
* <font color="#168CA9">Blue</font>: Nevis Mobile Authentication SDK and Authentication Cloud functions

:::note Nevis Mobile Authentication SDK
The SDK is integrated into the mobile banking app.
:::

Authentication Cloud functions include API calls to initiate the registration, verify a status token, and optionally, to get the `username`. For more information about these calls, see [Register a mobile app](../../api-doc/api-use-cases/mobile-app/register-mobile-app) and [Retrieve a user](../../api-doc/api-use-cases/manage-users-and-authenticators/retrieve-user).

```plantuml
@startuml

skinparam sequenceMessageAlign direction
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

actor "End-user" as user
participant "Mobile banking app" as app
participant "Web banking \napplication frontend" as webapp
participant "Infinity Fabric" as infinity
participant "Authentication Cloud" as authcloud
user -[#6F7C80]> webapp: Enter username and password
user -[#6F7C80]> webapp: Initiate registering a new authenticator
webapp -[#F0AC00]> infinity: Send registration request
infinity -> authcloud: Initiate registration
authcloud --> infinity: Return QR code and status token
infinity --[#F0AC00]> webapp: Forward QR code
webapp -> webapp: Display QR code
app -[#6F7C80]> webapp: Read QR code
app -> app: Forward the token to the SDK
app -> app: Register PIN or biometric authenticator, \nand generate public-private key pair
app -> authcloud: Store public key
authcloud --> app: Return result: public key saved
webapp -[#F0AC00]> infinity: Poll for status check
infinity -> authcloud: Check token validity with status endpoint
authcloud --> infinity: Return token status
group Optional
    infinity -> authcloud: Get ""username"" by ""userId""
    authcloud --> infinity: Return ""username""
end
infinity --[#F0AC00]> webapp: Confirm successful registration
@enduml
```
--------------------------------------------------------------------------------
Section: ### test-access-app.md
---
sidebar_position: 30
---

import Vimeo from '../../../src/components/Vimeo';

# Test the Access App

Your Authentication Cloud instance comes with a single-page test web application so that you can discover the basic functionality of the Authentication Cloud using the Access App.

<Vimeo src="https://player.vimeo.com/video/674778995?badge=0&autopause=0&player_id=0&app_id=58479&h=6f2123e58e" title="Azure AD B2C Biometric Login"/>

## Install the test Access App
--------------------------------------------------------------------------------
Section: ### qr-codes-overview.md
---
sidebar_position: 30
---

import Vimeo from '../../../src/components/Vimeo';

import REUSE from '/docs/reusable-md/_registration-and-authentication-flow.md'
import REUSE01 from '/docs/reusable-md/_usernameless-info.md'

# QR codes

In the branded Access App, we use QR codes to register users and authenticators, and also as a secure and versatile transaction authentication method.

<img className="centered" src={require('../assets/auth_method_1-QR_code.png').default} alt="QR code login"/>

## QR codes overview

QR code based transaction approval is one of the most reliable authentication methods as it does not rely on communication with a specific device. This makes it ideal in cases where more convenient mechanisms, such as push notifications are not acceptable.

We recommend QR codes as an authentication method, if the following are true for your business:

- You want secure authentication to work with the widest range of devices.
- You do not want to rely on the availability of push services on user devices.
- You want the option for usernameless authentication.
- You do not want to invest in major technical development.

For authentication with QR codes, you do not rely on specific device capabilities, or settings on the user side. Your users can register any Android or iOS device as an authenticator, and use them to authenticate transactions.

When the web application calls for authentication, it presents a QR code. Users scan the QR code using the Access App on one of their registered authenticator devices, and sign the transaction with either a PIN, or biometrics.

:::info
QR code based requests, like push messages, can also be fetched directly from a user device. For more information, see [Fetch ongoing operations](./push-notifications-overview#fetch-ongoing-operations)
:::

<Vimeo src="https://player.vimeo.com/video/803022968" title="QR Code based authentication"/>

## Registration and authentication flow

<REUSE
authmethod="QR codes"
/>

1. [Register a mobile app](../api-doc/api-use-cases/mobile-app/register-mobile-app)
2. [Authenticate with QR codes](../api-doc/api-use-cases/mobile-app/authenticate-QR-code)

<REUSE01
authmethod="QR codes"
/>

Read more about QR codes in the [QR Code](../../nevisaccessapp/features/channels/qr_code) section of the Access App documentation.
--------------------------------------------------------------------------------
Section: ### FIDO2-prerequisites.md
---
sidebar_position: 20
sidebar_label: Prerequisites
---

# FIDO2 integration prerequisites

To get started, you need the following information available:

* Instance ID
* Access Key

For more information on the instance ID and the Access Key, see the [Developer documentation](../../api-doc/api-doc.md).

## Relying party

Before you can integrate WebAuthn, provide the following information about your web application, the relying party:

**Relying party name**: The name of your choosing, for example: `Siven Chocolate Factory`.

**Relying party ID**: The domain or part of the domains of your web applications that you plan to register and authenticate users on, for example: `siven.ch`.

**Origins**: The list of the origins of your web application. Each origin has to be explicitly allowed, for example:

* `https://www.siven.ch`
* `https://login.siven.ch:9443`
* `https://sso.login.siven.ch`

As WebAuthn can only be used from a [secure context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts), the origins must be one of the following:

* A local address: `http://localhost`.
* An `https://` address on condition that the application provides a valid SSL certificate.

:::info

The **Relying party ID** must be a subset of all the origins you intend to use.

For example, the `siven.ch` **Relying party ID** matches the `https://login.siven.ch:9443` origin, but not the `https//bank.ch/` origin.

:::

## Autofill UI prerequisites

To enable the autofill UI feature for passkeys, add the `username` and `webauthn` value to any existing `autocomplete` annotations on the username input field as follows:

```
<div>
  <label for="username">Username:</label>
  <input name="username" id="loginform.username"
         autocomplete="username webauthn">
</div>
```

For more information, see [passkeys.dev](https://passkeys.dev/docs/use-cases/bootstrapping/).

[Contact Nevis support](https://portal.nevis.net) with the relying party information so that we can configure your Authentication Cloud instance.
--------------------------------------------------------------------------------
Section: ### architecture-overview.md
---
sidebar_position: 15
sidebar_label: Architecture overview
---

# FIDO2 architecture overview

<img className="boxed" src={require('../../assets/fido2_architecture.png').default} alt="FIDO2 architecture overview"/>

**User device**: A FIDO2-capable authenticator device, such as a laptop or mobile device which runs the web browser.

**Authenticator**: Allows the use of biometric methods, for example fingerprint scanning or face detection to authenticate.

Authenticators can be the following:

* Platform authenticators, built into the user device.
* Roaming authenticators, connected to the user device with USB, BLE, or NFC connections.

**Relying party** The relying party is the web application to secure using WebAuthn, to register and authenticate users. The relying party has a frontend and a backend part. The backend has to communicate with the Authentication Cloud API to start the registration or the authentication.

**Authentication Cloud FIDO2 JavaScript solution**: Authentication Cloud provides a JavaScript-based solution that can be used to handle the communication between the [WebAuthn API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API) and the Authentication Cloud API. The frontend of the relying party must include a JavaScript solution to connect to the Authentication Cloud API. For more information about the JavaScript solution, see [Register a FIDO2 authenticator](../../api-doc/api-use-cases/fido2/direct-communication/register-fido2-authenticator/#create-a-webauthn-credential-with-the-javascript-solution) and [Authenticate with FIDO2](../../api-doc/api-use-cases/fido2/direct-communication/authenticate-with-fido2.md/#authenticate-with-the-webauthn-credential-using-the-javascript-solution).
--------------------------------------------------------------------------------
Section: ### glossary.md
---
sidebar_position: 60
---

# Glossary

| **Term**         | Description                                                                                                                                                                                                                                                                                                                 |
|------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FIDO2            | FIDO2 enables users to leverage common devices to easily authenticate to online services in both mobile and desktop environments. The FIDO2 specifications are the World Wide Web Consortium’s (W3C) Web Authentication (WebAuthn) specification and FIDO Alliance’s corresponding Client-to-Authenticator Protocol (CTAP). |
| WebAuthn         | FIDO2 Web Authentication - a core component of FIDO Alliance’s FIDO2 set of specifications - is a web-based API that allows websites to update their login pages to add FIDO-based authentication on supported browsers and platforms.                                                                                      |
| CTAP             | The FIDO2 Client to Authenticator Protocol is complementary to WebAuthn. It enables an external authenticator, such as a security key or a mobile phone, to work with browsers that support WebAuthn, and also to serve as an authenticator to desktop applications and web services.                                       |
| Ceremony         | The concept of a ceremony is an extension of the concept of a network protocol, with human nodes alongside computer nodes and with communication links that include user interface(s), human-to-human communication, and transfers of physical objects that carry data.                                                     |
| Relying Party    | The entity whose web application utilizes the Web Authentication API to register and authenticate users.                                                                                                                                                                                                                    |
| Relying Party ID | A valid domain string that identifies the WebAuthn Relying Party on whose behalf a given registration or authentication ceremony is being performed.                                                                                                                                                                        |
--------------------------------------------------------------------------------
Section: ### Authenticator
Credentials belonging to the user are managed by an [authenticator](/configurationguide/fido2-concept-and-integration-guide/overview/browsers-and-authenticators). The WebAuthn Relying Party interacts with it through the client device by using the Relying Party JavaScript Application, which internally relies on the WebAuthn API provided by the client browser.

## Relying party backend

The relying party backend characterizes the **group of components** which in combination act together as the Relying Party backend of a FIDO2 Relying Party client. In the context of FIDO2, communication between a FIDO Client and a FIDO Server *always* occur via the Relying Party JavaScript Application and Nevis backend. In Nevis FIDO2, this backend includes the necessary Nevis components described below and the protected backend entity named *Web application* in the Nevis FIDO2 architecture figure.
--------------------------------------------------------------------------------
Section: #### nevisProxy
Towards the client-facing edge of the system, the **nevisProxy** component serves as the perimeter server. It's able to protect web applications from unauthenticated access and ensures that authentication takes place before requests are passed to those web applications. In Nevis FIDO2, nevisProxy is configured to accept requests according to the FIDO2 protocol and forwards them to the authentication subsystem. As in all Nevis setups, additional functions of nevisProxy are web application firewall, session management (single sign-on), and reverse proxy functionality like routing and rerouting of requests to downstream components. In Nevis FIDO2, nevisProxy will route FIDO2 HTTP requests to nevisAuth, which forwards them to nevisFIDO. The latter two form the authentication subsystem.
--------------------------------------------------------------------------------
Section: ### Example
1. The user opens the web application in the browser.
2. The browser tries to access the web application to display information to the user.
3. Nevis detects that the browser is not authenticated. It asks the user to provide his login identifier to authenticate.
4. The user provides his login information.
5. The login information is sent to the Nevis backend.
6. After identifying the user, Nevis asks the user to provide FIDO2 authentication.
7. The user authenticates using the FIDO2 Authenticator available on the client device.
8. The signed FIDO2 assertion is sent to the Nevis backend for validation.
9. The user is now authenticated and able to access the web server.
10. The user is now logged in and able to access the web application.

<img className="boxed" src={require('../../assets/fido2-auth/fido2-authentication-example.png').default} alt="FIDO2 Authentication Example"/>

## Technical flow

The technical flow in the following figure explains the component interaction in detail. The step numbers in the next figure do not correlate with the simplified example above.

:::note
The following flow is a simple compact example. Depending on requirements, changes or different approaches might be required.
The key fix points are:

* WebAuthn API in the browser.
* FIDO2 HTTP API in nevisFIDO.
* nevisAuth must be aware of the status of the FIDO2 authentication.
:::

```plantuml
@startuml
skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  BorderColor #CDD2D4
  BackgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

skinparam database {
   BorderColor #12677C
   BackgroundColor #168CA9
}



title FIDO2 Authentication

actor User as User

box "Client Device"
 participant "Browser" as BR #499985
 participant "FIDO2 Authentication\nClient Javascript" as JS #499985
end box

box "Relying Party Backend" #CDD2D4
    participant nevisProxy as P
    participant nevisAuth as A
    participant nevisLogRend as L
    participant nevisFIDO as F
    database nevisIDM as I
    participant "Relying Party\nWeb Application" as relyingPartyWebApp #SteelBlue
end box

User -> BR: Open browser
autonumber
BR -> P: Access protected resource
P -> A: Require authentication
activate A
    rnote over A #ECECEC
        Fido2AuthState
    end note
A -> L: Request rendering login page
deactivate A
activate L
L --> BR: Login page with FIDO2 Authentication Client Javascript
deactivate L

== Initialise Authentication ==

User -> BR: Provide username

BR -> JS: authenticate(username)
activate JS


JS -> P: username
autonumber stop
P -> A
autonumber resume

group HTTP API: Authentication Options Service
activate A
    rnote over A #ECECEC
        Fido2AuthState
    end note
A -> F: ""ServerPublicKeyCredentialGetOptionsRequest""

activate F
end group

F -> I: get Fido2 credentials\n based on username
activate I
autonumber stop
I --> F:
autonumber resume
deactivate I
    hnote over F
        FIDO2 config in nevisfido.yml <size:20><&file></size>
    end note
F -> F: Generate challenge
autonumber stop
F --> A: ""ServerPublicKeyCredentialGetOptionsResponse""
autonumber resume
deactivate F
A --> JS: ""ServerPublicKeyCredentialGetOptionsResponse""
deactivate A

== Authentication ==

JS -> BR: ""navigator.credentials.get""
BR -> User: Authenticate
activate User
User --> BR
deactivate User
    hnote over BR
        private <size:20><color:red><&key></color></size>
    end note
BR -> JS: Assertion

group HTTP API: Authentication Service
JS -> P: POST ""ServerPublicKeyCredential""\nto /nevisfido/fido2/assertion/result
P-> F
activate F
end group

F -> F: Get session using challenge
F -> I: Get Fido2Credential by ID
activate I
autonumber stop
I --> F
autonumber resume
deactivate I
hnote over F
    authenticator (public <size:20><color:green><&key></color></size>)
    session <size:20><&hard-drive></size>
    rp config <size:20><&file></size>
end note
F -> I: Update Fido2Credential (SignCounter)
activate I
autonumber stop
I --> F: response
autonumber resume
deactivate I
F -> F: Update session status
F --> JS: ""ServerResponse""
deactivate F
deactivate A

== Solidify Authentication at nevisAuth ==

JS -> P: Continue authentication with the\n""fido2SessionId"" in the header
activate A
autonumber stop

P -> A
autonumber resume
rnote over A #ECECEC
    Fido2AuthState
end note
A -> A: Parse and compare ""fido2SessionId""\nwith the stored value

group HTTP API: Status Service
activate F
A -> F: Verify authentication status for ""fido2SessionId""
F -> F: Fetch session for ""fido2SessionId""
F --> A: ""success""
end group
deactivate F
A -> A: ""ok"" result condition
A -> A: ""AuthDone""
A --> P: SecToken
deactivate A
P --> BR: HTTP 302 Redirect

autonumber stop
deactivate A

== Access Relying Party Services ==

BR -> P: Access Relying Party service\n(<color:red>""cookie""</color>)
P -> relyingPartyWebApp: Providing access to Relying Party service
activate relyingPartyWebApp
 relyingPartyWebApp --> BR
deactivate relyingPartyWebApp
BR --> User
deactivate BR
|||
@enduml
```

1. User accesses protected resource.
2. nevisProxy detects the user is not yet authenticated to access the protected resource, dispatches to nevisAuth.
3. nevisAuth enters the authentication flow with Fido2AuthState, which requests rendering a login page, that includes FIDO2 Authentication Client Javascript.
4. A login page is loaded in the browser, alongside the FIDO2 Authentication Client Javascript.
5. User provides its username.
6. The FIDO2 Authentication Client Javascript's `authenticate(username)` method is called.
7. The username is posted to nevisAuth.
8. Fido2AuthState recognizes it received a `username` and posts a `ServerPublicKeyCredentialGetOptionsRequest` to nevisFIDO, initiating FIDO2 Authentication.
    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/fido2/attestation/options`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/authentication-services/authentication-options-service)    
9. nevisFIDO queries the FIDO2 credentials from nevisIdm.
10. Challenge is generated and the `ServerPublicKeyCredentialGetOptionsResponse` is built.
11. The `ServerPublicKeyCredentialGetOptionsResponse` is returned to the FIDO2 Authentication Client Javascript.
12. The FIDO2 Authentication Client Javascript initiates an authentication using the received Options response via the WebAuthn API in the browser.
13. Dialog presented to the user by the browser to unlock the private key.
14. The user authenticates.
15. The WebAuthn API generates an assertion and returns it to the FIDO2 Authentication Client Javascript.
16. The FIDO2 Authentication Client Javascript posts the `ServerPublicKeyCredential` with the assertion to nevisFIDO directly.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/fido2/assertion/result`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/authentication-services/authentication-service)

17. nevisProxy forwards the request to the nevisFIDO endpoint, which is unprotected.
18. nevisFIDO session lookup. (This session is independent of the nevisAuth session)
19. nevisFIDO queries the FIDO2 credentials from nevisIdm.
20. The FIDO2 credential is updated with a new SignCounter, to prevent cloned authenticators. (the counter is **not** increased by a predefined number)
21. FIDO2 session is updated to reflect the current status.
22. ServerResponse is returned stating the status of the FIDO2 authentication.
23. The FIDO2 Authentication Client Javascript uses the `fido2SessionId` in the header to access nevisAuth and signal that the Authentication ceremony has been succeeded.
24. nevisAuth receives the `fido2SessionId` header and compares it with the one it stashed into the session.
25. `Fido2AuthState` verifies the status of the ceremony by accessing the status service of nevisFIDO.

    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/fido2/status`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/status-service)

26. Session lookup in nevisFIDO.
27. nevisFIDO returns the found status `success`.
28. The `Fido2AuthState` finishes processing by setting the result condition `ok` and nevisAuth continues the authentication flow based on the result.
29. An `AuthDone` AuthState is reached.
30. nevisAuth returns to nevisProxy with a `SecToken`.
31. nevisProxy redirects the client based on the result to the original resource, which can now be accessed by the authenticated client.

## Integration
--------------------------------------------------------------------------------
Section: ### usernameless-authentication.md
---
sidebar_position: 12
---

# Usernameless Authentication

## Description

A user is trying to access a web application, for example an e-banking application, which requires authentication. The user must provide the required authentication with a FIDO2 capable authenticator. Furthermore, the web application is protected by Nevis (notably nevisProxy and nevisAuth).
--------------------------------------------------------------------------------
Section: ### Example
1. The user opens the browser to connect to a web application.
2. The browser attempts to connect to a web application protected by Nevis.
3. Nevis detects that the user is not authenticated.
4. The browser sends usernameless login information to the Nevis backend.
5. Nevis asks the user to provide FIDO2 authentication using one of its discoverable credentials.
6. The user selects one of its discoverable credentials and authenticates using the FIDO2 Authenticator available on its device.
7. The signed FIDO2 assertion is sent to the Nevis backend for validation.
8. The assertion contains user related information and cryptographic material, which Nevis uses to identify and authenticate the previously unknown user.
9. The user is now logged in and able to access the web application.

<img className="boxed" src={require('../../assets/fido2-auth/fido2-usernameless-authentication-example.png').default} alt="FIDO2 Authentication Example"/>

## Integrate
The technical flow as well as the integration of usernameless authentication is the same as [FIDO2 Authentication](/configurationguide/fido2-concept-and-integration-guide/use-cases/authentication), with notable exceptions:

1. [The requirement of discoverable credentials](#discorverable-credentials). The presence of discoverable credentials can be ensured by enforcing that during registration the `ServerPublicKeyCredentialCreateOptionsRequest` the FIDO2 Registration Client Javascript sends to nevisFIDO contains `residentKey: "required"`. This forces the authenticator to create a credential on the client-side, or otherwise abort the registration.
2. The `authenticate(username)` method of FIDO2 Authentication Client Javascript must be called with an empty string, as in `""`. The identification of the user is then accessible over the Status Service of nevisFIDO. To access this endpoint, the fido2SessionId is needed, which is returned in the `ServerPublicKeyCredentialGetOptionsRequest` the FIDO2 Authentication Client Javascript received upon starting authentication.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/fido2/status`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/status-service)
--------------------------------------------------------------------------------
Section: ### registration-webapp.md
---
sidebar_position: 6
---

# Registration with Web Application

In this use-case, the FIDO2 Registration is integrated into the web application, where the FIDO2 credentials will be used at. For a generic description and prerequisits, please see [Registration](/configurationguide/fido2-concept-and-integration-guide/use-cases/registration).

## Technical Flow

The initial authentication depends on the custom integration as well as the existing means of authentication the end user possesses. Thus, the initial authentication steps are not explained in detail but only referenced.

:::note
The following flow is a simple compact example. Depending on requirements, changes or different approaches might be required.
The key fix points are:

* WebAuthn API in the browser.
* FIDO2 HTTP API in nevisFIDO.
:::

```plantuml
@startuml
skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  BorderColor #CDD2D4
  BackgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

skinparam database {
   BorderColor #12677C
   BackgroundColor #168CA9
}

title FIDO2 Registration

actor User as User

box "Client Device"
 participant "Browser" as BR #499985
 participant "FIDO2 Registration Client Javascript" as JS #499985
end box

box "Relying Party Backend" #CDD2D4
    participant nevisProxy as P
    participant nevisAuth as A
    participant nevisLogRend as L
    participant nevisFIDO as F
    participant "Relying Party\nWeb Application" as WebApp #SteelBlue
    database nevisIDM as I
end box

User -> BR: Open browser


== Legacy Authentication ==

ref over P, A, JS, BR, User, L, I: Authenticate at Nevis using a legacy credential (e.g. a password), to access the Web Application 

== Initialise Registration ==

autonumber
BR -> WebApp: Access web application
activate WebApp
WebApp -> BR: Web application with ""FIDO2 Registration Client Javascript""
deactivate WebApp
activate BR
User -> BR: Clicks to register FIDO2
BR -> JS: FIDO2 Registration Javascript Client runs\n(<color:red>""cookie""</color>)
activate JS

group HTTP API: Registration Options Service
JS -> P: POST ""ServerPublicKeyCredentialCreationOptionsRequest""\nto /nevisfido/fido2/attestation/options
activate P
P -> P: Delegate the SecToken
autonumber stop
P -> F
deactivate P
autonumber resume



activate F
end group


F -> I: get Fido2 credentials\n based on username
activate I
autonumber stop
I --> F:
autonumber resume
deactivate I
    hnote over F
        FIDO2 config in nevisfido.yml <size:20><&file></size>
    end note
F -> F: Generate challenge
autonumber stop

F --> P
P --> JS: ""ServerPublicKeyCredentialCreationOptionsResponse""

== Registration ==

autonumber resume
JS -> BR: ""navigator.credentials.create()""
BR -> User: Confirm
activate User
User --> BR: Authorize
deactivate User
    hnote over BR
        Generate key material
        private <size:20><color:#BF3666><&key></color></size>
        public <size:20><color:#499985><&key></color></size>
    end note
BR -> JS: Attestation object containing <size:20><color:#499985><&key></color></size>

group HTTP API: Registration Service
autonumber resume
JS -> P: POST ""ServerPublicKeyCredential"" to /nevisfido/fido2/attestation/result
autonumber stop
P -> F
end group

autonumber resume
activate F
F -> F: Get session using challenge
F -> F: Validate registration
hnote over F
    public <size:20><color:#499985><&key></color></size>
    session <size:20><&hard-drive></size>
    rp config <size:20><&file></size>
end note
F -> I: Store <size:20><color:#499985><&key></color></size> as FIDO2Credential
activate I
autonumber stop
I --> F: response
autonumber resume
deactivate I
F -> F: Update session status
F --> JS: ""ServerResponse""
deactivate F
JS --> JS: Error handling
deactivate A
JS -> BR: Return to the Web Application
deactivate JS
@enduml
```

1. The user accesses a Web Application after authenticating at Nevis with a legacy credential (a password for example).
2. The Web Application loads into the browser, with it the FIDO2 Registration Client Javascript.
3. The user initiates FIDO2 Registration on the GUI of the Web Application.
4. The Web Application calls into the FIDO2 Registration Client Javascript.
5. The FIDO2 Registration Client Javascript posts the `ServerPublicKeyCredentialCreationOptionsRequest` to the Registration Options Service of nevisFIDO, which is exposed by nevisProxy.

   **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/fido2/attestation/options`

   **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/authentication-services/authentication-options-service)
6. nevisProxy delegates the SecToken into the request, which then will be parsed by nevisFIDO.
7. nevisFIDO maps the username into a user in nevisIDM, then queries the credentials of the user.
8. Challenge is generated and the `ServerPublicKeyCredentialCreationOptionsResponse` is built, then returned.
9. The FIDO2 Registration Client Javascript receives the `ServerPublicKeyCredentialCreationOptionsResponse` and initiates registration with it at the Browser's WebAuthn API.
10. Dialog presented to the user by the browser to confirm the credential creation.
11. The user approves the credential creation.
12. The WebAuthn API generates the keys and returns an attestation to the FIDO2 Registration Client Javascript.
13. IDO2 Registration Client Javascript assembles then posts a `ServerPublicKeyCredential` to the nevisFIDO REST API that is exposed by nevisProxy.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/fido2/attestation/result`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/registration-services/registration-service)
14. nevisFIDO session lookup. 
15. Incoming request validated according to the WebAuthn specification.
16. nevisFIDO stores the FIDO2 credential in nevisIDM, such that it is related to the username.
17. FIDO2 session is updated to reflect the current status.
18. `ServerResponse` is returned stating the status of the FIDO2 ceremony. At this point the FIDO2 registration is completed.
19. The FIDO2 Registration Client Javascript logs the errors if necessary.
20. The FIDO2 Registration Client Javascript returns to the Web Application, which may proceed.

## Integration
--------------------------------------------------------------------------------
Section: ### Overview
The following diagram illustrates the integrated flow, as well as the main points of configuration.

<img className="boxed" src={require('../../../assets/fido2-auth/fido2-registration-webapp.drawio.png').default} alt="FIDO2 Registration with web application"/>
--------------------------------------------------------------------------------
Section: ### Disclaimer
The guide assumes the Nevis components nevisProxy, nevisFIDO and nevisIDM are already installed and setup in some configuration. It is also assumed that the web application of the relying party is operational and is protected by Nevis.
--------------------------------------------------------------------------------
Section: ### Integrate FIDO2 Registration with a Web Application
1. Copy the Javascript files and integrate them into your web application as you see fit.

    <details>
    <summary>FIDO2 Registration Client Javascript</summary>

    ```javascript title='fido2_registration.js'
    async function attestation(options) {
        try {
            const credential = await navigator.credentials.create({
                "publicKey": options
            });
            const requestBody = {
                id: credential.id,
                type: credential.type,
                response: {
                    clientDataJSON: base64url.encode(credential.response.clientDataJSON),
                    attestationObject: base64url.encode(credential.response.attestationObject)
                }
            };

            await fetch("/nevisfido/fido2/attestation/result", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody)
            });
        } catch (error) {
            console.error("Error while submitting WebAuthn attestation:", error);
        }
    }

    async function register(username, displayName) {
        if (!username) {
            console.error("Invalid username");
        }
        if (!displayName) {
            console.error("Invalid displayName");
        }
        if (!isWebAuthnSupportedByTheBrowser()) {
            console.error("WebAuthn is not supported by the browser!");
            return;
        }

        const request = {
            username,
            displayName,
            authenticatorSelection: {
                residentKey: "required",
                authenticatorAttachment: "platform",
                userVerification: "required"
            },
            attestation: "direct"
        };

        try {
            const response = await fetch("/nevisfido/fido2/attestation/options", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(request)
            });

            const options = await response.json();
            options.user.id = base64url.decode(options.user.id);
            options.challenge = base64url.decode(options.challenge);
            if (options.excludeCredentials != null) {
                options.excludeCredentials = options.excludeCredentials.map(({
                    id,
                    ...rest
                }) => ({
                    ...rest,
                    id: base64url.decode(id)
                }));
            }
            if (options.authenticatorSelection.authenticatorAttachment === null) {
                options.authenticatorSelection.authenticatorAttachment = undefined;
            }
            await attestation(options);
        } catch (error) {
            console.error("Error during FIDO2 registration:", error);
        }
    }
    ```
    </details>

    <details>
    <summary>Base64url encoding library</summary>

    ```javascript title='/var/opt/nevislogrend/&lt;instance&gt;/data/applications/def/resources/base64url.js'
    /*
    * Base64URL-ArrayBuffer
    * https://github.com/herrjemand/Base64URL-ArrayBuffer
    *
    * Copyright (c) 2017 Yuriy Ackermann <ackermann.yuriy@gmail.com>
    * Copyright (c) 2012 Niklas von Hertzen
    * Licensed under the MIT license.
    *
    */
    (function() {
        "use strict";

        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

        // Use a lookup table to find the index.
        var lookup = new Uint8Array(256);
        for (var i = 0; i < chars.length; i++) {
            lookup[chars.charCodeAt(i)] = i;
        }

        var encode = function(arraybuffer) {
            var bytes = new Uint8Array(arraybuffer),
            i, len = bytes.length, base64 = "";

            for (i = 0; i < len; i+=3) {
                base64 += chars[bytes[i] >> 2];
                base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                base64 += chars[bytes[i + 2] & 63];
            }

            if ((len % 3) === 2) {
                base64 = base64.substring(0, base64.length - 1);
            } else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2);
            }

            return base64;
        };

        var decode = function(base64) {
            var bufferLength = base64.length * 0.75,
            len = base64.length, i, p = 0,
            encoded1, encoded2, encoded3, encoded4;

            var arraybuffer = new ArrayBuffer(bufferLength),
            bytes = new Uint8Array(arraybuffer);

            for (i = 0; i < len; i+=4) {
                encoded1 = lookup[base64.charCodeAt(i)];
                encoded2 = lookup[base64.charCodeAt(i+1)];
                encoded3 = lookup[base64.charCodeAt(i+2)];
                encoded4 = lookup[base64.charCodeAt(i+3)];

                bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            }

            return arraybuffer;
        };

        /**
         * Exporting and stuff
         */
        if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
            module.exports = {
                'encode': encode,
                'decode': decode
            }

        } else {
            if (typeof define === 'function' && define.amd) {
                define([], function() {
                    return {
                        'encode': encode,
                        'decode': decode
                    }
                });
            } else {
                window.base64url = {
                    'encode': encode,
                    'decode': decode
                }
            }
        }
    })();
    ```
    </details>

    Adapt FIDO2 Registration Client Javascript as you see fit, particularly check and adapt error handling and the options properties: [residentKey](https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-residentkey), [authenticatorAttachment](https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-authenticatorattachment), [userVerification](https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-userverification), [attestation](https://www.w3.org/TR/webauthn-2/#enum-attestation-convey). If undecided, we recommend leaving everything on default, which requires the client-side to create a discoverable platform credential with the user's explicit verification.

    Call `register(username, displayName)` from your own scripts as you see fit, this method executes FIDO2 Registration against Nevis.
    1. `username`: the nature of this property *must* match to `credential-repository.user-attribute` in the nevisFIDO configuration. For example, if `credential-repository.user-attribute = loginId` is configured, the `username` property must contain the `loginId` of the user, as known by nevisIDM.
    2. `displayName`: this property *should* match to the `displayName` property the [SCIM API List of Users](./../../../../nevisidm/Developer-Guide/REST-Interface/SCIM-REST-Service/REST-Endpoints#list-of-users) returns from nevisIDM.

2. Configure nevisProxy.

    The FIDO2 calls of the FIDO2 Registration Client Javascript now must come through nevisProxy, where the SecToken is delegated into the request, so nevisFIDO can authorize the requests properly. If there is none yet, create a connector in nevisProxy towards nevisFIDO.

    <details>
    <summary>Create the nevisFIDO connector with AutoRewrite off</summary>

    ```xml title='/var/opt/nevisproxy/default/work/WEB-INF/web.xml'
    <servlet>
        <servlet-name>FidoConnector</servlet-name>
        <servlet-class>ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet</servlet-class>
        <init-param>
            <param-name>InetAddress</param-name>
            <param-value>localhost:9443</param-value>
        </init-param>
        <init-param>
            <param-name>AutoRewrite</param-name>
            <param-value>off</param-value>
        </init-param>
        <init-param>
            <param-name>SSLClientCertificateFile</param-name>
            <param-value>/var/opt/keybox/default/node_keystore.pem</param-value>
        </init-param>
        <init-param>
            <param-name>SSLCACertificateFile</param-name>
            <param-value>/var/opt/keybox/default/truststore.pem</param-value>
        </init-param>
    </servlet>
    ```
    </details>

    Replace `localhost:9443` with the endpoint nevisFIDO is accessible at in your network.

    <details>
    <summary>nevisFIDO FIDO2 connector mappings</summary>

    ```xml title='/var/opt/nevisproxy/default/work/WEB-INF/web.xml'
        <servlet-mapping>
            <servlet-name>FidoConnector</servlet-name>
            <url-pattern>/nevisfido/fido2/attestation/options</url-pattern>
        </servlet-mapping>

        <servlet-mapping>
            <servlet-name>FidoConnector</servlet-name>
            <url-pattern>/nevisfido/fido2/attestation/result</url-pattern>
        </servlet-mapping>

        <servlet-mapping>
            <servlet-name>FidoConnector</servlet-name>
            <url-pattern>/nevisfido/fido2/status</url-pattern>
        </servlet-mapping>
    ```
    </details>

    <details>
    <summary>Delegate the SecToken and the UserId for the Options endpoint</summary>

    ```xml title='/var/opt/nevisproxy/default/work/WEB-INF/web.xml'
        <filter>
            <filter-name>SecTokenDelegationFilter</filter-name>
            <filter-class>::ch::nevis::isiweb4::filter::delegation::DelegationFilter</filter-class>
            <init-param>
                <param-name>DelegateBasicAuth</param-name>
                <param-value>
                    AUTH:user.auth.UserId
                    AUTH:user.auth.SecToken
                </param-value>
            </init-param>
        </filter>

        <filter-mapping>
            <filter-name>SecTokenDelegationFilter</filter-name>
            <url-pattern>/nevisfido/fido2/attestation/options</url-pattern>
        </filter-mapping>
    ```
    </details>

3. [Configure FIDO2 at nevisFIDO](/configurationguide/fido2-concept-and-integration-guide/configuration/nevisfido-configuration).
4. [Configure nevisIDM](/configurationguide/fido2-concept-and-integration-guide/configuration/nevisidm-configuration).
5. Restart the instances, FIDO2 Registration should be operational!
--------------------------------------------------------------------------------
Section: ### registration-nevisauth.md
---
sidebar_position: 6
---

# Registration with nevisAuth

In this use-case, the FIDO2 Registration is implemented with ScriptStates in nevisAuth. For a generic description and prerequisits, please see [Registration](/configurationguide/fido2-concept-and-integration-guide/use-cases/registration).

:::note

The presented example solution simplifies nevisAuth configuration by hiding most of the logic in the Groovy ScriptState including the HTTP API calls to nevisFIDO.

The Nevis Identity Suite provides an nevisAdmin4 pattern named *nevisFIDO FIDO2 Self-Admin App* which contains a FIDO2 / WebAuthn capable client JavaScript. Use it or build upon it, but note that it is considered to be experimental, we might change it or remove it in the future.

:::

## Technical Flow

The initial authentication depends on the custom integration as well as the existing means of authentication the end user possesses. Thus, the initial authentication steps are not explained in detail but only referenced.

:::note
The following flow is a simple compact example. Depending on requirements, changes or different approaches might be required.
The key fix points are:

* WebAuthn API in the browser.
* FIDO2 HTTP API in nevisFIDO.
* nevisAuth must be aware of the status of the FIDO2 registration.
:::

```plantuml
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  BorderColor #CDD2D4
  BackgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

skinparam database {
   BorderColor #12677C
   BackgroundColor #168CA9
}

title FIDO2 Registration

actor User as User

box "Client Device"
 participant "Browser" as BR #499985
 participant "FIDO2 Javascript Client" as JS #499985
end box

box "Relying Party Backend" #CDD2D4
    participant nevisProxy as P
    participant nevisAuth as A
    participant nevisLogRend as L
    participant nevisFIDO as F
    database nevisIDM as I
    participant "Relying Party\nWeb Application" as relyingPartyWebApp #SteelBlue
end box

User -> BR: Open browser


== Registration Precondition check ==

activate BR
BR -> P: Login using existing credential

P -> A: Authentication required
activate A
    rnote over A #ECECEC
        IdmPasswordVerifyState
    end note

    A --> P: Username + password gui
deactivate A

P -> L
activate L
    hnote over L
        Render gui with username + password input
    end note
L --> P
deactivate L

P --> BR: (<color:red>""new cookie""</color>)

BR -> P: username + password
P -> A
activate A
    rnote over A #ECECEC
        IdmPasswordVerifyState
    end note
    A -> I
    activate I
    I --> A
    deactivate I

    rnote over A #ECECEC
        IdmGetPropertiesState
    end note
    A -> I: get mobile, email, extId
    activate I
    I --> A
    deactivate I
deactivate A
A --> P
P --> BR

autonumber
 
BR -> P: Register FIDO2 credential
autonumber stop
P -> A:
autonumber resume
    rnote over A #ECECEC
        ScriptState
    end note

A --> P: GuiDescriptor configuring JS client

autonumber stop
deactivate A
P -> L
activate L
    hnote over L
        Load JS client based on gui name
    end note
L --> P
deactivate L
P --> BR
autonumber resume

== Initialise Registration ==

autonumber stop
BR -> JS: JS client runs automatically\n(<color:red>""cookie""</color>)
autonumber resume
activate JS


JS -> P: empty POST /nevisfido/fido2/attestation/options
autonumber stop
P -> A
autonumber resume

group HTTP API: Registration Options Service
activate A
    rnote over A #ECECEC
        ScriptState
    end note
A -> F: ""ServerPublicKeyCredentialCreationOptionsRequest""

activate F
end group

F -> I: get Fido2 credentials\n based on username
activate I
autonumber stop
I --> F:
autonumber resume
deactivate I
    hnote over F
        FIDO2 config in nevisfido.yml <size:20><&file></size>
    end note
F -> F: Generate challenge
autonumber stop
F --> A: ""ServerPublicKeyCredentialCreationOptionsResponse""
autonumber resume
deactivate F

A --> P
deactivate A
P --> JS: ""ServerPublicKeyCredentialCreationOptionsResponse""

== Registration ==

JS -> BR: ""navigator.credentials.create()""
BR -> User: Confirm
activate User
User --> BR: Authorize
deactivate User
    hnote over BR
        Generate key material
        private <size:20><color:#BF3666><&key></color></size>
        public <size:20><color:#499985><&key></color></size>
    end note
BR -> JS: Attestation object containing <size:20><color:#499985><&key></color></size>

JS -> P: form POST attestation data to /nevisfido/fido2/attestation/result
autonumber stop
P-> A
autonumber resume
    activate A
    rnote over A #ECECEC
        ScriptState
    end note
group HTTP API: Registration Service
A -> F: ""ServerPublicKeyCredentialForRegistration""
end group


activate F
F -> F: Get session using challenge
F -> F: Validate registration
hnote over F
    public <size:20><color:#499985><&key></color></size>
    session <size:20><&hard-drive></size>
    rp config <size:20><&file></size>
end note
F -> I: Store <size:20><color:#499985><&key></color></size> as FIDO2Credential
activate I
autonumber stop
I --> F: response
autonumber resume
deactivate I
F -> F: Update session status
F --> A: ""ServerResponse""
deactivate F
A --> A: Error handling / Custom flow
autonumber stop
A --> P
deactivate A
deactivate JS

P --> BR: Configured next step

@enduml
```

1. The user initiates the FIDO2 registration.
2. The ScriptState returns a GuiDescriptor configuring the nevisLogRend template to include the JS client.
3. The JS client submits an empty form POST to get the `ServerPublicKeyCredentialCreationOptionsResponse`. In this example implementation the `ServerPublicKeyCredentialCreationOptionsRequest` is generated by the Groovy ScriptSate.
4. The `ServerPublicKeyCredentialCreationOptionsRequest` is created by `ScriptState` and calls the nevisFIDO Options endpoint.

   **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/fido2/attestation/options`

   **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/authentication-services/authentication-options-service)

5. nevisFIDO queries the FIDO2 credentials from nevisIdm.
6. Challenge is generated and the `ServerPublicKeyCredentialCreationOptionsResponse` is built.
7. A direct response is prepared using the `ServerPublicKeyCredentialCreationOptionsResponse`.
8. JS client receives the `ServerPublicKeyCredentialCreationOptionsResponse`.
9. JS client initiates a registration using the received Options response via the WebAuthn API.
10. Dialog presented to the user by the browser to confirm the credential creation.
11. The user approves the credential creation.
12. The WebAuthn API generates the keys and returns an attestation to the JS client.
13. JS client submits attestation to the backend.
14. The `ScriptState` in nevisAuth assembles a `ServerPublicKeyCredentialForRegistration` JSON payload from the form submit and calls the nevisFIDO REST API.

    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/fido2/attestation/result`

    **Reference:** [nevisFIDO Reference Guide](/nevisfido/reference-guide/fido2-http-api/registration-services/registration-service)

15. nevisFIDO session lookup. (This session is independent of the nevisAuth session)
16. Incoming request validated according to the WebAuthn specification.
17. nevisFIDO stores the FIDO2 credential in nevisIDM, such that it is related to the username.
18. FIDO2 session is updated to reflect the current status.
19. ServerResponse is returned stating the status of the FIDO2 authentication. At this point the FIDO2 registration is completed.
20. `ScriptState` transitions to `ok`.

## Integration
--------------------------------------------------------------------------------
Section: ### The web application
Registration can be integrated into the customer web application where the FIDO2 credentials will be eventually used at.

See [Registration with Web Application](registration-webapp).
--------------------------------------------------------------------------------
Section: ### integration-prerequisites.md
---
sidebar_position: 2
---

# Integration prerequisites

A relying party represents a web application that you wish to secure using WebAuthn to register and authenticate users.
Before you can integrate WebAuthn, you need to collect information about your web application, the relying party:

**Relying party name**: The name of your choosing, for example: `Siven Chocolate Factory`.

**Relying party ID**: The root domain or part of the domains of your web applications that you plan to register and authenticate users on, for example: siven.ch.

**Origins**: The list of the origins of your web application. Each origin has to be explicitly allowed, for example:

* `https://www.siven.ch`
* `https://login.siven.ch:9443`
* `https://sso.login.siven.ch`

As WebAuthn can only be used from a [secure context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts), the origins have to be one of the following:

* A local address: `http://localhost`.
* An `https://` address on condition that the application provides a valid SSL certificate.

:::info

Make sure that you choose a **Relying party ID**, which is a subset of all the origins you intend to use.

For example, the `siven.ch` **Relying party ID** matches the `http://login.siven.ch:9443` origin, but not the https//bank.ch/ origin.

:::
--------------------------------------------------------------------------------
Section: ### Out-of-band authentication and transaction confirmation
In the *out-of-band* scenario, a user uses one application but requires another, separate mobile application to do authentication or transaction confirmation.

<img className="boxed" src={require('../assets/mobile-auth/oob-auth.png').default} alt=""/>

An example of an *out-of-band* scenario is a user who visits a web application via the browser installed on his personal computer (no.1 and no.2). If required, the web application triggers an authentication or transaction confirmation for the user, by sending a push message to the mobile device associated with this user (l co.3). The user authenticates in the device (for example using fingerprint) and the device signs the authenticationl cequest or transaction information and returns the result to the server (no.4). After successfe server-side, the user is considered to be authenticated or the transaction to be confirmed. The
figure illustrates this scenario.

## Nevis Mobile Authentication based on FIDO UAF

To implement the aforementioned features, Nevis Mobile Authentication is based on the FIDO UAF 1.1 standard. FIDO is a set of specifications for strong authentication. The FIDO Alliance was launched in 2013 to address the lack of interoperability among strong authentication devices and the problems users face creating and remembering multiple usernames and passwords. There were more than 260 alliance members by the end of September 2016, including leading internet companies such as Google and Microsoft.

FIDO supports the *Universal Authentication Framework* (UAF) and the *Universal Second Factor* (U2F) protocols.

:::info

U2F is not in the scope of Nevis Mobile Authentication.
:::

<img className="boxed" src={require('../assets/mobile-auth/fido-uaf.png').default} alt=""/>

The UAF protocol consists of a client component, installed on the user's mobile device, and a server component,
connected with the online service. Upon registration of the user with the online service, the client on the user's device creates a new public and private key pair. The private key is stored on the user's device. The public key is registered with the online service and associated with the user's profile. During the authentication process, the client component on the user device proves the ownership of the private key to the service by signing a challenge. This involves a simple user action only, such as providing a fingerprint, entering a PIN code, using voice recognition or even iris scanning.
--------------------------------------------------------------------------------
Section: ### glossary.md
---
sidebar_position: 36
---

# Glossary

| Term                            | Description                                                                                                                                                                                                                                                                                                                                                                            | Example                                                                                                                                                                                                                                                                                                                                                                                                       |
|---------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| In-band communication           | Using the current channel.                                                                                                                                                                                                                                                                                                                                                             | A message is delivered through an already established and currently used HTTP communication channel.                                                                                                                                                                                                                                                                                                          |
| Out-of-band (OOB) communication | Using a channel other than the main communication channel.                                                                                                                                                                                                                                                                                                                             | A message is delivered via a dispatching channel (for example, as push notification, QR code, or link) instead of a currently used HTTP communication channel.                                                                                                                                                                                                                                                |
| Out-of-band authentication      | Authentication done in an application separated from the application that requires it with no direct communication between the two applications.                                                                                                                                                                                                                                       | A web application for banking is accessed from a browser on a laptop. The web application handles the banking-related business logic but requires authentication by a distinguished Access App which is installed on a mobile device.                                                                                                                                                                         |
| In-band authentication          | Authentication done within the same application that requires it.                                                                                                                                                                                                                                                                                                                      | A mobile banking application which does not require the installation of another application to handle the authentication. All required functionality is built into one application.                                                                                                                                                                                                                           |
| Transaction confirmation        | An operation in the FIDO protocol that allows a relying party to request that a FIDO Client displays some information to the end user, and requires the user to authenticate locally to their FIDO Authenticator to confirm the information. This provides proof-of-possession of previously registered key material and an attestation of the confirmation back to the relying party. | A mobile banking application has among its capabilities bank transfers. If the amount of the transfer exceeds a threshold, the user must confirm the transaction after authenticating. In the confirmation message presented to the user, the amount of the transaction is included. When the user confirms the transaction, the contents of the message (and thus the amount) are proven by the FIDO server. |
| Access App                      | Dedicated native mobile app built to implement the FIDO UAF authentication, registration and deregistration capabilities. Optionally also implements transaction confirmation capabilities.                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Business App                    | A business application end users interact with to conduct business with Nevis customers.                                                                                                                                                                                                                                                                                               | A mobile banking application which can be used to make payments.                                                                                                                                                                                                                                                                                                                                              |
| Relying Party                   | *"A web site or other entity that uses a FIDO protocol to directly authenticate users                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO                            | Fast Identity Online                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Client                 | A FIDO UAF Client implements the client side of the FIDO UAF protocols.                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Server                 | A FIDO UAF server implements the server side of the FIDO UAF protocols.                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Protocol               | The FIDO UAF protocols carry FIDO UAF messages between user devices and Relying Parties.                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO Authenticator              | A FIDO Authenticator is responsible for user verification, and maintaining the cryptographic material required for the relying party authentication.                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Authenticator          | A FIDO UAF Authenticator is a secure entity, connected to or housed within FIDO user devices, that can create key material associated to a Relying Party. The key can then be used to participate in FIDO UAF strong authentication protocols.                                                                                                                                         |
| UAF                             | The FIDO Protocol and family of authenticators which enable a service to offer its users flexible and interoperable authentication. This protocol allows triggering the authentication before the server knows the user                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Client TLS                      | A two way TLS connection where the client also needs a valid certificate. (Also known as two way SSL)                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Dispatch Target                 | Client identifier used in out-of-band message transmission.                                                                                                                                                                                                                                                                                                                            | A unique id identifying a physical mobile device of an end user                                                                                                                                                                                                                                                                                                                                               |
| Dispatch Channel                | Means of which the message is transmitted to the client.                                                                                                                                                                                                                                                                                                                               | Push (message), E-Mail, ...                                                                                                                                                                                                                                                                                                                                                                                   |
| Dispatcher                      | Concrete implemented component tasked with sending an out-of-band message.                                                                                                                                                                                                                                                                                                             | The Firebase Cloud Messaging Dispatcher (bound to the 3rd party Firebase Cloud Messaging Service)                                                                                                                                                                                                                                                                                                             |
| Channel Linking                 | Channel linking describes the concept where a user is requested to visually confirm an out-of-band authentication. The user does so by comparing information shown in a web browser and in the authentication client application.The purpose of channel linking is verifying the current channel/operation to prevent login attempts by a malicious second party (e.g., another user). | During authentication, the browser shows the characters "6A". The same characters are shown in the mobile application, allowing the user to "link" these two channels.                                                                                                                                                                                                                                        |
--------------------------------------------------------------------------------
Section: ### In-Band Registration
In the **in-band registration scenario**, nevisProxy is responsible for protecting the endpoint of nevisFIDO's Registration Service. This is typically realized by configuring an `IdentityCreationFilter` in nevisProxy and the associated connectors. If a non-authenticated HTTP client tries to access the protected resource (the Registration Service endpoint), nevisProxy will redirect the HTTP client to nevisAuth for authentication.

The following nevisProxy configuration snippets (in `web.xml`) redirect non-authenticated access via `https://<proxy host>/nevisfido/uaf/1.1/request/registration` to the locally installed nevisAuth instance. The nevisAuth instance is configured with port `8991`, and nevisFIDO with port `8443`. The name of the realm for the in-band registration operation is `"PASSWORD_AUTHENTICATION"`.

:::info

The properties `InterceptionRedirect` and `StoreInterceptedRequest` **must** be set to `"never"` and `"false"`,
respectively. These settings are relevant for JSON clients, and must prevent the proxy from interfering with the requests. For details, see the nevisProxy Technical Documentation.
:::

To provide an authentication endpoint for a mobile authentication client, nevisProxy exposes the `/auth/pwd` path. A client can perform a password login via nevisAuth using this endpoint.

```xml title="nevisProxy - Password authentication configuration"
<!-- Authentication filter to protect the nevisFIDO Registration Service -->
<filter>
    <filter-name>PasswordAuthenticationFilter</filter-name>
    <filter-class>ch::nevis::isiweb4::filter::auth::IdentityCreationFilter</filter-class>
    <init-param>
        <param-name>AuthenticationServlet</param-name>
        <param-value>NevisAuthConnector</param-value>
        <description>The configured name of the authentication servlet</description>
    </init-param>
    <init-param>
        <param-name>LoginRendererServlet</param-name>
        <param-value>NevisLoginRenderer</param-value>
        <description>The configured name of the login renderer servlet</description>
    </init-param>
    <init-param>
        <param-name>Realm</param-name>
        <param-value>PASSWORD_AUTHENTICATION</param-value>
        <description>The realm of the authentication</description>
    </init-param>
    <init-param>
        <param-name>InactiveInterval</param-name>
        <param-value>7200</param-value>
        <description>The maximum interval between two request associated to the same session
                (if deleted or 0, value is taken from nevisAuth 'Domain' element)</description>
    </init-param>
    <init-param>
        <param-name>EntryPointID</param-name>
        <param-value>localhost</param-value>
        <description>The entry point id (will be part of the sectoken)</description>
    </init-param>
    <init-param>
        <param-name>InterceptionRedirect</param-name>
        <param-value>never</param-value>
    </init-param>
    <init-param>
        <param-name>StoreInterceptedRequest</param-name>
        <param-value>false</param-value>
    </init-param>
</filter>


<!-- URL Mapping for the nevisFIDO Registration Request Service, the filter mapping includes the SecToken and the servlet mapping associates the servlet with a path. -->
<filter-mapping>
    <filter-name>PasswordAuthenticationFilter</filter-name>
    <url-pattern>/nevisfido/uaf/1.1/request/registration/*</url-pattern>
</filter-mapping>
```

If an already authenticated user tries to access the `auth/pwd` endpoint, the system returns a 404 error by default. You can define a LUA filter to avoid this. The LUA filter will return a 204 HTTP status code.

```xml title="LUA filter for authentication endpoints"
<!-- This filter is invoked *only* if the user is already authenticated: if the user is not
     authenticated, nevisAuth (through PasswordAuthenticationFilter or FidoUafAuthenticationFilter)
     is invoked, and nevisAuth returns a direct response in those cases.
     This filter just returns an HTTP response with status code 204. -->
<filter>
    <filter-name>AlreadyAuthenticatedFilter</filter-name>
    <filter-class>ch::nevis::isiweb4::filter::lua::LuaFilter</filter-class>
    <init-param>
        <param-name>Script.InputHeaderFunctionName</param-name>
        <param-value>rewriteResponse</param-value>
    </init-param>
    <init-param>
        <param-name>Script</param-name>
        <param-value>
          function rewriteResponse(request, response)
              response:send(204)
          end
       </param-value>
    </init-param>
</filter>
```

nevisProxy introduces an additional filter mapping to `auth/pwd`. This creates a _singular endpoint_, against which client applications can perform (password) authentication. This allows clients to authenticate with legacy credentials,
which is required before starting the registration process.

```xml title="Password authentication filter mapping"
<!-- The /auth/pwd filter provides and endpoint for doing "legacy" username/password authentication -->
<filter-mapping>
    <filter-name>PasswordAuthenticationFilter</filter-name>
    <url-pattern>/auth/pwd</url-pattern>
</filter-mapping>
<filter-mapping>
    <filter-name>AlreadyAuthenticatedFilter</filter-name>
    <url-pattern>/auth/pwd</url-pattern>
</filter-mapping>
```

To forward all incoming requests to nevisFIDO, the respective connector is mapped to the nevisFIDO base path:

```xml title="nevisFIDO connector servlet mapping"
<!-- Servlet forwarding every incoming request to /nevisfido/* to nevisFIDO -->
<servlet-mapping>
    <servlet-name>FidoHttpApiConnector</servlet-name>
    <url-pattern>/nevisfido/*</url-pattern>
</servlet-mapping>
```

In the in-band registration use case, nevisAuth creates a SecToken once the client application is authenticated. The SecToken is used to guarantee that the authentication was successful and to transmit the username. The username must be transmitted to nevisFIDO when the client accesses the Registration Request endpoint. nevisFIDO will validate the *
UserId*provided in the `BasicAuth` header against the user ID encoded in the SecToken. Therefore, the `UserId` must be exposed as the first information in the `BasicAuth` header.

Furthermore, the delegation filter must be mapped to the nevisFIDO base URL.

```xml title="nevisProxy - Delegation filter"
<!-- Delegation filter for transmitting the Sectoken. -->
<filter>
    <filter-name>NinjaBasicAuthDelegationFilter</filter-name>
    <filter-class>::ch::nevis::isiweb4::filter::delegation::DelegationFilter</filter-class>
    <init-param>
        <param-name>DelegateBasicAuth</param-name>
        <param-value>
            AUTH:user.auth.UserId
            AUTH:user.auth.SecToken
        </param-value>
    </init-param>
</filter>

<filter-mapping>
    <filter-name>NinjaBasicAuthDelegationFilter</filter-name>
    <url-pattern>/nevisfido/*</url-pattern>
</filter-mapping>
```

:::info

In the in-band registration use case, only nevisAuth needs access to the nevisFIDO endpoints. This allows you to block all other nevisFIDO endpoints (notably the Authentication Request endpoint) for external HTTP clients in this scenario.
:::
--------------------------------------------------------------------------------
Section: ### out-of-band-registration-client-code-examples.md
---
sidebar_position: 40
---

# Out-of-Band Registration Client Code Examples

As mentioned in [Out-of-Band Registration](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-registration), one way of performing an out-of-band registration is by using a QR code.
Information, such as a token, is transmitted from a laptop to a mobile device by scanning a QR code.

This section describes how to build a web application that uses a QR code for registration. It is assumed that the registration application is protected in the same realm/domain as the nevisFIDO Dispatch Registration Token service.e rurthermore, Nevis is configured to transmit the SecToken to the registration application once the user is
authenticated. The JavaScript snippets below use the [jQuery](https://jquery.com/) library.

The application works as follows (the numbers in the description below correspond with the numbers in the next figure:

1. The client authenticates using a web browser and a laptop. Note that this is a legacy login, *not* the Nevis Mobile
   Authentication login.
2. The client accesses the registration application. In terms of the HTTP protocol, this typically is a GET operation.
   The HTTP request to the registration application contains a SecToken. The registration application parses the
   SecToken to extract the username to authenticate.
3. The registration application returns an HTML page containing:

    1. the username,
    2. the dispatch registration token URL,
    3. the status service URL, and
    4. JavaScript code.
4. After loading the HTML page, the JavaScript sends a Dispatch Registration Token request. The dispatcher used is the
   QR Code Dispatcher, which returns the contents to be scanned inside a QR code. For this, it uses the dispatch
   registration token URL and the username from the HTML page.

5. Nevis returns the Dispatch Registration Token response with the QR code.
6. The JavaScript parses the response with the token and renders the QR code returned by nevisFIDO.

7. The user uses a FIDO enabled application in the mobile phone to scan the QR code, redeem the token and proceed with
   the registration.

Note that after sending the Dispatch Registration Token request, the JavaScript can invoke the Status Service for information on the registration status. The Status Service helps finding out whether the user redeemed the token by scanning the QR code, and whether the registration was completed successfully.

<img className="boxed" src={require('../../assets/mobile-auth/registration-application-with-qr-code.png').default} alt="
Out-of-band registration with QR code"/>

```html title="HTML Page"
<html>
  <!-- ... -->
  <body>
    <form>
      <!-- ... -->
      <input id="dispatchTokenUrl" type="hidden" value="https://www.siven.ch/nevisfido/token/dispatch/registration"/>
      <input id="statusUrl" type="hidden" value="https://www.siven.ch/nevisfido/status"/>
      <input id="username" type="hidden" value="jeff"/>

      <div id="qrCode" style="height:300px"></div>
    </form>
    <!-- ... -->
    <script th:src="@{/webjars/jquery/3.3.1/jquery.min.js}"></script>
    <script type="application/javascript">
    /**
     * Start the registration process after the document is loaded
     */
    $( document ).ready(function () {
      sendDispatchRegistrationTokenRequest();
    });
    <!-- ... -->
    </script>
  </body>
</html>
```

```javascript title="Send Dispatch Registration Token Request"
function sendDispatchRegistrationTokenRequest() {
    var username = $('#username').val();
    var getUafRequest = {
        op: "Reg",
        context: JSON.stringify({username: username})
    };
    var dispatchTokenRequest = {
        dispatcher: "png-qr-code",
        getUafRequest: getUafRequest,
        dispatchInformation: {
            encodingParameters: {
                width: 300,
                height: 300,
                foregroundColor: "rgb(4, 125, 130)",
                backgroundColor: "rgb(255, 255, 255)"
            }
        }
    };
    var dispatchTokenUrl = $('#dispatchTokenUrl').val();

    var stringifiedBody = JSON.stringify(dispatchTokenRequest);
    jQuery.ajax({
        'type': 'POST',
        'url': dispatchTokenUrl,
        headers: {
            'Accept' : 'application/json; charset=utf-8',
            'Content-Type': 'application/json; charset=utf-8'
        },
        'data': stringifiedBody,
    }).done(function (data) {
        dispatchRegistrationTokenCallback(data);
    }).fail(function () {
        // Handle the error
    });
    return status;
}


function dispatchRegistrationTokenCallback(data) {
    var pngQrCode = data['dispatcherInformation']['response'];
    renderQrCode(pngQrCode);
}
```

```javascript title="QR Code Generation"
function renderQrCode(pngQrCode) {
    let imageAsHtml = '<img src="data:image/png;base64,' + pngQrCode +
        '" alt="Scan the QR code to trigger the registration process in your mobile device." />';
    $('#qrCode').html(imageAsHtml);
}
```

```javascript title="Status Query"
function queryRegistrationStatus(sessionId) {
    var stringifiedBody = JSON.stringify({sessionId: sessionId});
    jQuery.ajax({
        'type': 'POST',
        'url': $('#statusUrl').val(),
        headers: {
            'Accept' : 'application/json; charset=utf-8',
            'Content-Type': 'application/json; charset=utf-8'
        },
        'data': stringifiedBody,
    }).done(function (data) {
        statusResponseCallback(data);
    })
    .fail(function () {
        // Handle error
    });
    return status;
}


function statusResponseCallback(data) {
    var status = data['status']
    if (status == 'succeeded') {
        // Registration was successful
    } else if (status == 'clientRegistering') {
        // The token was redeemed
    } else if (status == 'failed') {
        // Registration failed
    } else if (status == 'tokenCreated') {
        // Waiting for token to be redeemed (has the user scanned it?)
    }
}
```
--------------------------------------------------------------------------------
Section: ### Authentication
Once the FIDO credentials have been created, the private key is stored in the FIDO Authenticator and the public key is registered in the FIDO Server, the FIDO Client can authenticate. The authentication process is the following one:

1. The Relying Party client application tries to access the web application (Relying Party).
2. Since the application is not authenticated, the Relying Party sends a _GetUAFRequest_ to the FIDO Server asking to
   authenticate.
3. The FIDO Server returns a _ReturnUAFRequest_ contaning
   an [AuthenticationRequest](https://fidoalliance.org/specs/fido-uaf-v1.1-ps-20170202/fido-uaf-protocol-v1.1-ps-20170202.html#authentication-request-message)
   to the Relying Party. In this _AuthenticationRequest_ the server includes the policy. The Relying Party forwards
   the _AuthenticationRequest_ to the application. The embedded FIDO Client in the application handles this _
   AuthenticationRequest_.
4. The user authenticates using the FIDO Authenticators required by the policy of the FIDO Server.
5. The FIDO Client generates a _SendUAFResponse_ containing
   an [AuthenticationResponse](https://fidoalliance.org/specs/fido-uaf-v1.1-ps-20170202/fido-uaf-protocol-v1.1-ps-20170202.html#authenticationresponse-dictionary)
   that is sent from the Relying
   Party client to the Relying Party server. This message consists mainly of the signed challenge sent by the client
   using the private keys generated in the registration operation. The _AuthenticationResponse_ is forwarded to the FIDO
   Server.
6. The FIDO Server validates the received _AuthenticationResponse_. The validation consists mainly on verifying that:
    * The private keys used to sign the challenge correspond to FIDO Authenticators that comply with the policy.
    * The signature of the challenge is valid. To validate the signature, the FIDO credentials of the user stored during
      the registration operation are used.
7. The FIDO Server returns a _ServerResponse_ informing that the authentication was successful. The Relying Party
   detects that the client application is successfully authenticated and notifies the application.

<img className="boxed" src={require('../../assets/mobile-auth/uaf-authentication.png').default} alt=""/>
--------------------------------------------------------------------------------
Section: ### Transaction Confirmation
The FIDO UAF Protocol defines an special case of authentication known as transaction confirmation. The transaction confirmation is used when in addition to perform authentication, the user must validate some information (this information is referred to as transaction message). A typical use case would be a banking transaction: the user authenticates to execute the transaction but in addition to that the amount of the transaction must be verified by the end user to avoid tampering (this is the case represented in the diagram below). Other examples: a web shop asking the user to confirm a purchase by showing the product and amount, a public institution mobile application asking the user for confirmation when submitting a tax declaration, etc.

The information to be validated can be either a text or an image. In this scenario, the FIDO Client is not the one that generates the message to be validated by the end user, but the web application (in the FIDO UAF Specification, this entity is referenced as Relying Party). The transaction confirmation process is the following:

1. The Relying Party application contacts the Relying Party to execute a transaction (this might imply or not sending
   a _GetUAFRequest_ to the Relying Party).
2. The Relying Party sends a _GetUafRequest_ to the FIDO Server with the transaction information.
3. The FIDO Server returns an _AuthenticationRequest_ to the FIDO Client, with the policy and the transaction message.
   The transaction message is usually generated by the Relying Party.
4. The transaction message is presented to the user who confirms it.
5. The user authenticates in the FIDO Client using the authenticators required by the policy of the FIDO Server.
6. The FIDO Client sends a _SendUAFResponse_ containing an _AuthenticationResponse_ to the Relying Party server. This
   message consists mainly of the signed challenge sent by the client and a signed hash of the transaction message. Both
   elements are signed using the private keys generated during the registration operation. The _AuthenticationResponse_
   is forwarded to the FIDO Server.
7. The FIDO Server validates the received _AuthenticationResponse_. The validation consists mainly of verifying that:
    * The private keys used to sign the challenge correspond to FIDO Authenticators that comply with the policy.
    * The signature of the challenge is valid. To validate the signature, the FIDO credentials of the user stored during
      the registration operation are used.
    * The signed hash of the transaction message is valid. To validate the signature, the FIDO credentials of the user
      stored during the registration operation are used.
8. The FIDO Server returns a _ServerResponse_ informing that the transaction confirmation was successful. The Relying
   Party (bank application) is informed about this and the transaction is executed. The Relying Party notifies the
   application that the transaction was successful.

<img className="boxed" src={require('../../assets/mobile-auth/uaf-transaction-confirmation.png').default} alt=""/>
--------------------------------------------------------------------------------
Section: ### nevis-mobile-authentication.md
---
sidebar_position: 6
---

# Nevis Mobile Authentication

Nevis Mobile Authentication builds up on top of [the FIDO UAF 1.1 protocol](https://fidoalliance.org/specs/fido-uaf-v1.1-ps-20170202/fido-uaf-protocol-v1.1-ps-20170202.html)
and supports the registration, authentication, transaction confirmation and deregistration operations of FIDO UAF 1.1.
It enables secure and convenient authentication for relying applications by letting users verify their identity via their mobile device. This is achieved by integrating the relying web applications with the Nevis Security Suite and implementing Nevis Mobile Authentication client-capabilities in a mobile application.

<img className="boxed" src={require('../../assets/mobile-auth/mobile-auth-high-level-architecture.png').default} alt="
High-level Architecture of Nevis Mobile Authentication"/>

The Nevis Mobile Authentication server-side is based on Nevis components including nevisIDM as the Identity Management System. This ensures end-to-end compatibility and decreases integration efforts with third-party components. For more details on the server-side architecture, see the [High-Level Architecture](/configurationguide/mobile-auth-concept-and-integration-guide/technical-architecture/high-level-architecture).

## Mobile Authentication Devices

Nevis Mobile Authentication focuses on mobile devices with FIDO Client capabilities and FIDO Authenticators. To connect the FIDO Clients and the FIDO Authenticators with the server-side of Nevis Mobile Authentication, a small communication layer must be implemented in the Relying Party client application. This abstraction layer is referred to as Nevis Mobile Authentication client. The Nevis Mobile Authentication client is responsible to communicate FIDO UAF protocol messages received by the mobile application to the FIDO Client and from the FIDO Client to the Relying Party.

The FIDO UAF architecture anticipates that devices and operating systems are shipped with FIDO UAF Clients and Authenticators. In such cases, the Nevis Mobile Authentication client may build up on that as depicted in the following figure.

<img className="boxed" src={require('../../assets/mobile-auth/external-fido.png').default} alt="External FIDO Client and Authenticators"/>

<img className="boxed" src={require('../../assets/mobile-auth/in-app-fido.png').default} alt="Embedded FIDO Client and Authenticator"/>

:::info Nevis Mobile Authentication Client SDK

To allow quick and easy development of mobile applications with support of Nevis Mobile Authentication, a Nevis Mobile Authentication Client SDK for Android and iOS is available.
:::

Nevis Mobile Authentication anticipates two integration scenarios for the Nevis Mobile Authentication client on the mobile device:

* A Nevis Mobile Authentication client built into a mobile Business Application which requires authentication (built-in)
  .
* A Nevis Mobile Authentication client built into a dedicated native mobile application solely built to implement
  authentication, transaction confirmation, registration and deregistration scenarios (Access App).

<img className="boxed" src={require('../../assets/mobile-auth/in-app-integration.png').default} alt="In-App integration"
/>

<img className="boxed" src={require('../../assets/mobile-auth/access-app-integration.png').default} alt="Access App"/>

If Nevis Mobile Authentication client capabilities are built into a Business Application, FIDO protocol messages between the server-side and the client-side may be directly transferred through established communication channels. If Nevis Mobile Authentication Client capabilities are built into a separate dedicated application for authentication,n tut-of-band push notifications must be used to establish a new communication channel between the server-side and the
Access Application.

Based on the client-side integration type, Nevis Mobile Authentication thus supports two authentication concepts.

## Mobile Authentication Concepts

In Nevis Mobile Authentication, we distinguish between the basic usage scenarios [out-of-band authentication](/configurationguide/mobile-auth-concept-and-integration-guide/glossary) and [in-band authentication](/configurationguide/mobile-auth-concept-and-integration-guide/glossary).e sn _in-band_ authentication, authentication is done within the same application that requires it. In _out-of-band_e suthentication, authentication is done in an application separated from the application that requires it. There is no
direct communication between the two applications.
--------------------------------------------------------------------------------
Section: ### Out-of-Band Authentication
:::info Example

* A mobile banking application handles the banking-related business logic but requires the presence of another
  application (Access App) on the same or a different mobile device to handle the authentication.
* A web application for banking is accessed from a browser on a laptop. The web application handles the banking-related
  business logic but requires authentication by a distinguished Access App which is installed on a mobile device.
  :::

In _out-of-band_ authentication, there is no direct communication between the application that requires authentication and the application that conducts the authentication. That is, FIDO Protocol messages must be transferred through another channel than the channel used by the Business Application. This is called _out-of-band_ communication. In Nevis Mobile Authentication, an _out-of-band_ channel is established by delivering a message to the Access Application via push notification.

_Out-of-band_ authentication can take place on the same physical device with two logically separated and isolated applications as depicted in the figure. One application handles the business logic, whilst the other handles authentication.

<img className="boxed" src={require('../../assets/mobile-auth/out-of-band-authentication.png').default} alt="Out-of-band authentication on same device"/>

Once an application is required to log in to access protected resources on the initial _in-band_ communication channel (
1), the server-side sends a push notification to the end user's associated Access App, containing a reference to an *
AuthenticationRequest*. This triggers the Access App to request the referred-to _AuthenticationRequest_ through a newly established _out-of-band_ channel (3). The end user locally verifies his identity and cryptographically signs the challenge contained in the _AuthenticationRequest_ (4). An _AuthenticationResponse_ is then returned to the server-side (5), which verifies the signature (6) and returns an access token to the application that initially requested login (7).

Due to the fact that there is no direct communication between the application that requires authentication and the application that conducts the authentication, authentication can also take place on a separate device. The following figure illustrates this use case.

<img className="boxed" src={require('../../assets/mobile-auth/out-of-band-authentication-multiple-devices.png').default}
alt="Out-of-band authentication with multiple devices"/>
--------------------------------------------------------------------------------
Section: #### Execution
The following figure illustrates the flow when using end-to-end encryption. The dispatcher in use has no impact on the encryption feature, because it is transparent to any dispatch service.

```plantuml title="E2E Encryption Execution"
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #047D82
    LifeLineBorderColor #047D82

    ParticipantBorderColor #047D82
    ParticipantBackgroundColor #69B1B4

    ParticipantFontName Frutiger
    ParticipantFontColor white


    GroupBorderColor #047D82
    GroupBorderThickness 1

    DividerBackgroundColor #69B1B4
    DividerBorderColor #047D82
    DividerBorderThickness 1
    DividerFontColor white
    DividerFontName Frutiger

    BoxBorderColor #A6BFE0
    BoxBackgroundColor #ECECEC

}

skinparam note {
    FontName Frutiger
    BorderColor #047D82
    BackgroundColor #CCE5E5
}

skinparam database {
   BorderColor #047D82
   BackgroundColor #69B1B4
}

box "Mobile Client Device" #LightSteelBlue
 participant "Mobile Client Application" as app #SteelBlue
end box

box "Relying Party Backend"
    participant "Relying Party\nWeb Application" as RPA #SteelBlue
    participant NEVIS
end box

participant "3rd Party Dispatching Service" as DISP

autonumber

RPA -> NEVIS: initiate out of band dispatching
activate NEVIS
NEVIS -> NEVIS: load dispatching channel <size:20><color:blue><&key></color></size> public key
NEVIS -> NEVIS: encrypt message content using <size:20><color:blue><&key></color></size>
NEVIS -> DISP: send message to dispatch
activate DISP
DISP -> NEVIS: response
deactivate DISP

NEVIS --> RPA: token
deactivate NEVIS
RPA --> RPA: display "token" for visual verification

DISP --> app: message encrypted with <size:20><color:blue><&key></color></size>
activate app
app -> app: load dispatching channel <size:20><color:green><&key></color></size> private key
app -> app: decrypt message content using <size:20><color:green><&key></color></size> private key
deactivate app

@enduml

```

The following list describes the steps of the end-to-end encryption flow. The numbers correspond with the steps in the previous figure.

1. The relying party web application initiates an out-of-band operation.
2. Nevis loads the public key of the dispatch channel of the user.
3. The message content is encrypted with the public key.
4. The encrypted message is sent to the 3rd party dispatch service.
5. The response of the 3rd party dispatch service is handled by Nevis to detect dispatching errors early.
6. The token created during the dispatch operation is forwarded to the application that initiated the out-of-band
   operation.
7. A visual representation of the token is rendered and shown to the user to allow visual verification of the dispatched
   message.
8. The mobile client application receives the message out-of-band.
9. The mobile client application loads the matching private key for the encrypted message.
10. The mobile client application decrypts the message content with the private key.
--------------------------------------------------------------------------------
Section: ### Example with Push Notification
This section describes the transaction confirmation process on the basis od the second scenario.

The numbers in the description below correspond with the numbers in the next figure.

1. The user completes his online shopping by performing a credit card checkout and supplying his credit card information.
2. The online shop contacts the payment backend to initiate the payment.
3. The payment backend contacts Nevis Mobile Authentication to initiate a transaction confirmation. The payment backend is responsible for determining the relying party backend username based on the provided payment information (e.g., the user's credit card information).
4. Nevis sends a push notification to the mobile device. If the user registered more than one mobile device, the backend must either:
    1. Decide which device should receive the push message, or.
    2. Send multiple messages to all devices registered to the user.
5. The mobile device receives the push notification and shows it in the notification bar. User interaction with the
   notification will open the mobile application, which is required to handle the push message data content.
6. The mobile application decrypts the push message and uses the contained data to contact Nevis to proceed
   with the FIDO transaction confirmation.
7. Nevis sends back the transaction content to the mobile application and requests the user to confirm the transaction.
8. The user confirms (or rejects) the transaction using the fingerprint-based FIDO Authenticator in the mobile device.
9. The transaction confirmation process on the mobile device is completed. The mobile application sends the confirmation
   result to Nevis.
10. The Nevis Authentication Backend informs the payment backend about the successfully signed transaction.
11. The payment backend confirms the payment to the online shop.
12. The online shop shows the payment as completed.

<img className="boxed" src={require('../../assets/mobile-auth/uc-oob-transaction-confirmation-flow.drawio.png').default} alt="Out-of-Band Transaction Confirmation Example"/>

## Technical Flow

:::info

The technical flow in the next figure explains the component interaction in detail. The step numbers in the figure do not correlate with the simplified example above.
:::

In regard to the UAF protocol and flow, the steps in the transaction confirmation process and the [Out-of-Band Authentication](out-of-band-authentication) processes are the same. The authentication and transaction confirmation processes differ in the payload that accompanies the transaction confirmation process. This payload contains the transaction information; it is (usually) absent in authentication scenarios. The following technical flow therefore only contains the steps specific for the transaction confirmation process.

```plantuml title="Out-of-band transaction confirmation flow"
@startuml

skinparam shadowing false
skinparam BoxPadding 10
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #047D82
    ParticipantBorderColor #168CA9
    ParticipantBackgroundColor #168CA9
    ParticipantFontName Frutiger
    ParticipantFontColor white
    ActorBackgroundColor #168CA9
    ActorBorderColor #168CA9
    ActorFontName Frutiger
    GroupBorderColor #168CA9
    GroupBorderThickness 1
    DividerBackgroundColor #168CA9
    DividerBorderColor #168CA9
    DividerBorderThickness 1
    DividerFontColor white
    DividerFontName Frutiger
    BoxBorderColor #168CA9
    BoxBackgroundColor #ECECEC
}
skinparam note {
    FontName Frutiger
    BorderColor #168CA9
    BackgroundColor #F5F5F5
}

title Out-of-Band Transaction Confirmation

actor User

box "Desktop Device"  #F5F5F5
    participant "Browser" as browser #75C3D7
end box

box "Mobile Client Device"  #F5F5F5
 participant "FIDO UAF \nAuthenticator" as Authenticator #75C3D7
 participant "Nevis Access App" as app #75C3D7
end box

box "3rd Party Backend" 
    participant "Web Application" as WebApp #75C3D7
end box

box "Relying Party Backend"
    participant nevisProxy
    participant nevisAuth
    participant nevisFIDO
    participant nevisIDM
end box

participant "Customer Backend" as backend #75C3D7
participant "Firebase Cloud Messaging\n(FCM)" as FCM #75C3D7


User -> browser ++ : Open browser app
browser -> WebApp ++ : Access 3rd party web application
ref over browser, WebApp
    Web application interaction leading to transaction confirmation
end ref

autonumber

WebApp -> nevisProxy: Transaction information
nevisProxy -> backend ++: Forward transaction information
backend -> backend: Resolve ""username"", ""dispatchTargetId""

== Dispatch Token ==

backend -> backend: Create ""GetUafRequest""\n(""username"")

group HTTP API: Dispatch Token Service
    backend -> nevisFIDO ++ : Dispatch token request\n(""dispatchTargetId,""\n""GetUafRequest"")
end group

autonumber stop

nevisFIDO -> nevisFIDO: Generate ""token"" and\nstore ""GetUafRequest""
nevisFIDO -> nevisIDM ++ : Fetch dispatch target\n(""dispatchTargetId"")

nevisFIDO <-- nevisIDM -- : Dispatch target
hnote over nevisFIDO
    dispatch target
    public <size:20><color:green><&key></color></size>
end note

nevisFIDO -> nevisFIDO: Encrypt data using JWE\n(""token,redeemUrl"")
FCM <- nevisFIDO ++ : Transmit push message
FCM --> nevisFIDO --
backend <-- nevisFIDO --: Dispatch token response\n(sessionId)

autonumber resume

loop status == succeeded OR status == failed

    group HTTP API: Status Service
        backend -> nevisFIDO ++ : Query status \n(""sessionId"")
        nevisFIDO -> backend --: Status response
    end group

end

autonumber stop

== Receive and Handle Dispatched Token ==

app <- FCM ++ : Push message
hnote over app
    dispatch target
    private <size:20><color:red><&key></color></size>
end note
app -> app: Decrypt JWE


== Redeem Authentication Token for Transaction Confirmation==

group HTTP API: Redeem Token Service
    app -> nevisProxy: Redeem authentication token\n(""token"")
    nevisProxy -> nevisFIDO ++: Foward redeem authentication token\n(""token"")
end group

nevisFIDO -> nevisFIDO: Fetch ""GetUafRequest""\nfrom session
hnote over nevisFIDO
    policy <size:20><&document></size>
end note
app <-- nevisFIDO --: ""ReturnUAFRequest""\n(""AuthenticationRequest"")

== Trusted facets ==

group HTTP API: Facets Service
    app -> nevisProxy: Fetch trusted facets
    nevisProxy -> nevisFIDO ++: Forward trusted facets request
end group
app <-- nevisFIDO --: Trusted facets

== Out-of-Band Transaction Confirmation ==

autonumber resume
app -> app: Show transaction content

autonumber stop

Authenticator <- app ++ : Trigger user authentication
User <- Authenticator ++ : Authenticate

User --> Authenticator -- : Unlock private key
hnote over Authenticator
    private <size:20><color:red><&key></color></size>
end note
Authenticator --> app -- : ""Assertion""

group HTTP API: Authentication Response Service
    app -> nevisProxy: ""SendUAFResponse""\n(""AuthenticationResponse"")
    nevisProxy -> nevisFIDO: Forward ""SendUAFResponse""\n(""AuthenticationResponse"")
end group

nevisFIDO -> nevisIDM ++: Fetch FIDO credential

nevisFIDO <-- nevisIDM --: Credential
hnote over nevisFIDO
    public <size:20><color:green><&key></color></size>
    policy <size:20><&document></size>
    metadata <size:20><&document></size>
end note
app <-- nevisFIDO: ""ServerResponse""
deactivate app

== Finalize Transaction Confirmation ==
autonumber resume

backend -> nevisProxy --: Status response
nevisProxy -> WebApp: Forward status response
WebApp -> WebApp: Handle transaction based on status response
WebApp -> browser--: Show transaction result
browser -> User--: Show transaction result

|||
@enduml

```

The numbers in the list correlate with the step numbers in the previous figure.

1. The user interacts with a third party web application which leads to a transaction, such as buying a book with this credit card in an online shop. The web application sends the transaction information to a relying party backend application. This backend application is capable of retrieving the missing required information to issue a transaction.
2. nevisProxy forwards the request to the relying party backend application.
3. The relying party backend application uses the provided transaction information (for example the credit card number) to resolve both the corresponding user stored in nevisIDM and the dispatch target ID of the user's mobile device.

   How the information is retrieved depends on the respective use case, the available information provided by the third party web application as well as the custom implementation of the relying party backend application.
4. The relying party backend application creates a GetUafRequest for the given username.

   **References:**

    * [Authentication Request Service](/nevisfido/reference-guide/uaf-http-api/authentication-services/authentication-request-service)
    * [GetUAFRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-client-api-transport-v1.0-ps-20141208.html#getuafrequest-dictionary)
5. The relying party backend application calls the nevisFIDO endpoint to dispatch a token request, and supplies the
   `GetUafRequest` together with the ID of the previously selected dispatch target (`dispatchTargetId`).

   **Endpoint:** `https://<nevisFIDO-host>/nevisfido/token/dispatch/authentication`

   **References:**

    * [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service)
6. The relying party application uses the sessionId to query the status of the transaction confirmation operation. This
   `sessionId` has been provided as response in a previous, not described step.

   **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/status`

   **References:**

    * [Status Service](/nevisfido/reference-guide/uaf-http-api/status-service)
7. The status service returns the status result for the current ongoing transaction confirmation operation.

   This operation is looped until the status response indicates success or failure of the transaction operation.
8. The relying party mobile application receives the `AuthenticationRequest` containing the transaction information, which it shows to the user on the mobile. The transaction information is either text- or image-based. It is up to the mobile application to choose the most suitable representation.

   The user has to decide whether to accept the transaction during the authentication process. The relying party mobile client application always returns an `AuthenticationResponse` to the server, even if the user rejected the transaction. In the latter case, the response contains the client error code indicating the user cancellation, instead of the signed transaction assertion.
9. The relying party backend application forwards the status response obtained from the nevisFIDO status service to the third party web application. The status response is most likely defined by the third party web application and must be mapped accordingly by the relying party backend application.
10. nevisProxy forwards the status response to the third party web application.
11. The third party web application that initiated the transaction confirmation processes the transaction according to the status response. That is, it marks the transaction as either confirmed or failed, depending on whether the user confirmed the transaction on his/her mobile device.
12. The transaction result is represented in the browser.
13. The user sees the transaction result (for example, a successful credit card payment).

The above technical flow applies to both scenarios described at the start of the chapter. In scenario 1 as well as scenario 2, the relying party backend application needs to access protected endpoints of the nevisFIDO component. Access can be granted in two ways:

* If the nevisFIDO instance is _not_ using client-TLS, access is granted by providing a SecToken issued to the user who wants to initiate a transaction confirmation. In scenario 1, the SecToken is directly available as the user authenticated first. In scenario 2, the payment backend must be able to request a SecToken from Nevis in the name of the user.
* If the nevisFIDO instance is using client-TLS, access is granted implicitly, based on a valid client certificate (for more information, see [Security Considerations](../security-considerations)).

The SecToken _can_ be used in both scenarios, but user impersonation based on the SecToken is only easily available in scenario 1. For scenario 2, client-TLS based user impersonation is recommended.

## Configuration Snippets

You will find example configuration snippets for all involved components in [Nevis Component Configuration Examples](/configurationguide/mobile-auth-concept-and-integration-guide/appendixes/nevis-component-configuration-examples).

Note that the described scenario of transaction confirmation does _not_ involve nevisAuth. Therefore, map the required endpoints only in nevisProxy.
--------------------------------------------------------------------------------
Section: ### Example
1. The user launches the e-banking application on the mobile device.
2. The mobile client application tries to access the e-banking web server to retrieve the account statement of the user.
3. Nevis detects that the mobile client application is not authenticated. It asks the user to provide authentication that meets the security policy of the e-banking application. In this example, this is a fingerprint-based authentication.
4. The user authenticates using the fingerprint-based FIDO Authenticator in the mobile device.
5. The mobile client application can now access the e-banking web server. The account statement is displayed in the mobile application.

<img className="boxed" src={require('../../assets/mobile-auth/uc-in-band-authentication.png').default} alt="In-Band Authentication"/>

## Technical Flow

:::info

The technical flow in the following figure explains the component interaction in detail. The numbers of the steps in the next figure do not correlate with the simplified example above.
:::

It is assumed that the user has already registered FIDO credentials. These FIDO credentials are located in the nevisFIDO server on the mobile device containing the e-banking mobile application. See the [In-Band Registration](in-band-registration) use case for details regarding registration. It is also assumed that only one user is using the application on the mobile device, that is, the device is not shared between different users. Another assumption is that the policy requires the use of a fingerprint-based authenticator.

```plantuml title="In-Band Authentication Flow"
@startuml

skinparam shadowing false
skinparam BoxPadding 10
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #047D82
    ParticipantBorderColor #168CA9
    ParticipantBackgroundColor #168CA9
    ParticipantFontName Frutiger
    ParticipantFontColor white
    ActorBackgroundColor #168CA9
    ActorBorderColor #168CA9
    ActorFontName Frutiger
    GroupBorderColor #168CA9
    GroupBorderThickness 1
    DividerBackgroundColor #168CA9
    DividerBorderColor #168CA9
    DividerBorderThickness 1
    DividerFontColor white
    DividerFontName Frutiger
    BoxBorderColor #168CA9
    BoxBackgroundColor #ECECEC
}
skinparam note {
    FontName Frutiger
    BorderColor #168CA9
    BackgroundColor #F5F5F5
}

title In-Band Authentication

actor User as user

box "Mobile Device" #F5F5F5
 participant "FIDO UAF \n Authenticator" as authenticator #75C3D7
 participant "Nevis Access App" as app #75C3D7
end box

box "Nevis Backend"
    participant nevisProxy as proxy
    participant nevisAuth as auth
    participant nevisFIDO as fido
    participant nevisIDM as idm
end box

participant "Customer Application" as backend #75C3D7

autonumber
user -> app++: Open and use Mobile App

== Initialise Authentication ==

app -> proxy++: Access /auth/fidouaf
proxy -> auth--++: Authentication required

rnote over auth #ECECEC
    FidoUafAuthState
end note

group HTTP API: Authentication Request Service
    auth -> fido++: ""GetUAFRequest""
end group

hnote over fido
    policy <size:20><&document></size>
end note
fido --> auth--: ""ReturnUAFRequest""\n(""AuthenticationRequest"")
auth --> app--: Forward ""ReturnUAFRequest""\n(""AuthenticationRequest"")

== Trusted Facets ==

group HTTP API: Facets Service
    app -> proxy++: Fetch trusted facets
    proxy -> fido--++: Forward trusted facets request
end group
fido --> app--: ""TrustedFacets""

== Client processing ==

app -> authenticator++: Trigger user authentication
authenticator -> user++: Authenticate
user --> authenticator--: Unlock private key
 
hnote over authenticator
    private <size:20><color:red><&key></color></size>
end note
authenticator --> app--: Assertion

== Authentication Response ==

group HTTP API: Authentication Response Service
    app -> proxy++: ""SendUAFResponse""\n(""AuthenticationResponse"")
    proxy -> fido--++: Forward ""SendUAFResponse""\n(""AuthenticationResponse"")
end group

fido -> idm++: Fetch FIDO credential
idm --> fido--: Credential
hnote over fido
    public <size:20><color:green><&key></color></size>
    policy <size:20><&document></size>
    metadata <size:20><&document></size>
end note
fido --> app--: ""ServerResponse""

== Finalise Authentication ==

app -> proxy++: Check authentication status \n(""fidoUafSessionId"")
proxy -> auth++: Check authentication status \n(""fidoUafSessionId"")

rnote over auth #ECECEC
    FidoUafAuthState
end note

group HTTP API: Status Service
 auth -> fido++: Query authentication status
end group

fido --> auth--: Authentication Status\n(""StatusResponse"")  """succeeded"""

note right
 The flow will fail if one of the following two statuses is reported:
 - failed
 - unknown
end note

auth --> proxy--: Authentication Status\n(""StatusResponse"")  """succeeded"""
proxy --> app--: Authentication Status\n(""StatusResponse"")  """succeeded"""

== Generate SecToken ==

app -> proxy++: Check authentication status \n(""fidoUafSessionId"")
proxy -> auth++: Check authentication status \n(""fidoUafSessionId"")

rnote over auth #ECECEC
    FidoUafAuthState
end note
auth -> auth: Transition """ok"""

rnote over auth #ECECEC
    DirectResponseState
end note

auth -> auth: Set response payload JSON: \n""{"status":"completed"}""
auth -> auth: Set response to AUTH_DONE

auth --> proxy--: ""{"status":"completed"}"" + ""SecToken""
proxy --> app--: ""{"status":"completed"}""\n(<color:red>""cookie""</color>)

== Access Relying Party Services ==

app -> proxy++: Access Relying Party service\n(<color:red>""cookie""</color>)
autonumber stop
proxy -> backend--++: Providing access to Relying Party service
backend --> app--
app --> user--
|||

@enduml
```

The numbers in the list correlate with the step numbers in the previous figure.

1. The user opens the e-banking application on the mobile device to see her actual account statement.

2. The mobile application initiates the in-band authentication by accessing the respective endpoint

   As the perimeter component of Nevis Mobile Authentication, nevisProxy receives the incoming request.

   **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/auth/fidouaf`

   **References:**

    * [HTTP APIs and Client Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/configuration/http-apis-and-client-authentication)

3. nevisProxy detects that the mobile client application is not authenticated.

   nevisProxy redirects the client to nevisAuth to ask for authentication.

4. nevisAuth is configured for authentication with FIDO UAF. To achieve this, nevisFIDO provides an own AuthState named `FidoUafAuthState`.

   The `FidoUafAuthState` assembles a `GetUAFRequest` (with the operation header set to `Auth`). nevisAuth sends the `GetUAFRequest` to nevisFIDO, to trigger a FIDO UAF authentication.

   **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/uaf/1.1/request/authentication`

   **References:**

    * [FidoUafAuthState](/nevisfido/reference-guide/config-nevis-components/nevisauth-fido-authstates/fido-uaf/fidouafauthstate)
    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/authentication-services/authentication-request-service)
    * [GetUAFRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-client-api-transport-v1.1-id-20170202.html#getuafrequest-dictionary)

5. nevisFIDO sends a `ReturnUAFRequest` to nevisAuth. The `ReturnUAFRequest` contains an `AuthenticationRequest` message including the authentication policy.

   nevisFIDO also returns a FIDO UAF session identifier. For more information, see [Authentication Request Service](/nevisfido/reference-guide/uaf-http-api/authentication-services/authentication-request-service) in the nevisFIDO Reference Guide, in particular the "Example Response" part. This part describes the proprietary extension containing the FIDO UAF session ID.

   :::info

   Placing the `fidoUafSessionId` in the extension part of the `AuthenticationRequest` makes synchronisation between nevisAuth and nevisFIDO possible: It links the FIDO session maintained in nevisFIDO to the session maintained by nevisAuth.
   :::

   **References:**

    * [ReturnUAFRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-client-api-transport-v1.1-id-20170202.html#returnuafrequest-dictionary)
    * [AuthenticationRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticationrequest-dictionary)
    * [Extensions Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#extension-dictionary)

6. nevisAuth forwards the `ReturnUAFRequest` to the mobile device through nevisProxy. It is assumed that the mobile device includes an embedded FIDO Client.

   While forwarding the `ReturnUAFRequest`, nevisAuth looks into the contained `AuthenticationRequest` message and stores the found FIDO UAF session identifier. However, nevisAuth does not change the content of the message.

   **References:**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/config-nevis-components/nevisauth-fido-authstates/fido-uaf/fidouafauthstate#restarting-the-fido-uaf-authentication)
    * [ReturnUAFRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-client-api-transport-v1.1-id-20170202.html#returnuafrequest-dictionary)
    * [AuthenticationRequest Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticationrequest-dictionary)

7. The embedded FIDO Client fetches the trusted facets.

   The request will be sent to nevisProxy.

   The information accessible at the Facets Service endpoint helps the e-banking mobile application to identify whether it is an authorized facet of the e-banking web application.

   **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/nevisfido/uaf/1.1/facets`

   :::info

   This endpoint is an example of mapping nevisProxy to the nevisFIDO Facets Service endpoint
   :::

8. nevisProxy forwards the request to nevisFIDO.

   **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/uaf/1.1/facets`

   **References:**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/facets-service)
    * [Facets Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-appid-and-facets-v1.1-id-20170202.html#determining-if-a-caller-s-facetid-is-authorized-for-an-appid)

9. nevisFIDO returns the trusted facets it maintains. nevisProxy forwards them to the FIDO Client.

   **References:**

    * [Trusted Facets Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-appid-and-facets-v1.1-id-20170202.html#trustedfacets-structure)

10. The FIDO Client triggers the user authentication at the matching FIDO Authenticator.

    The FIDO Client can find a matching FIDO Authenticator on the mobile device by using the policy received via the AuthenticationRequest message in step 6.

11. The fingerprint-based FIDO Authenticator initiates the client-side authentication of the user.

    The GUI of the mobile platform informs the user to authenticate by tapping the fingerprint sensor of the mobile device.

12. With a successful fingerprint-based authentication the user enables the usage of the private key. This private key matches the formerly registered FIDO credentials of the e-banking web application. The private key is now unlocked inside the FIDO Authenticator for signing purposes.

13. As the outcome of the user authentication, the FIDO Authenticator assembles and returns an AuthenticatorSignAssertion to the FIDO Client. The assertion is signed by the private key of the user, as proof of the successful client-side authentication.

    :::info

    The private key that is used to sign the assertion never leaves the FIDO Authenticator. This means that neither the embedded FIDO Client nor the Relying Party mobile app can access it directly (not even in an unlocked state).

    Because the `AuthenticatorSignAssertion` is digitally signed, none of the involved parties in the communication chain can change the assertion without violating any upcoming integrity checks.
    :::

    **References:**

    * [Authentication Request Processing Rules for FIDO Authenticator Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authentication-request-processing-rules-for-fido-authenticator)
    * [Authentication Response Generation Rules for FIDO UAF Client Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authentication-response-generation-rules-for-fido-uaf-client)
    * [AuthenticatorSignAssertion Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticatorsignassertion-dictionary)

14. The Relying Party mobile app sends a `SendUAFResponse` to the Authentication Response Service endpoint defined in nevisProxy.

    The `SendUAFResponse` contains an `AuthenticationResponse` message including the `AuthenticatorSignAssertion`provided by the FIDO Authenticator in the previous step (13).

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/auth/fidouaf/authenticationresponse/`

    :::info

    Since this endpoint is not a direct match to the nevisFIDO Authentication Response Service endpoint, it should be mapped with a custom connector servlet and servlet-mapping in nevisProxy:

    ```xml title="Authentication Response custom servlet and mapping"
    <servlet>
        <servlet-name>Connector_AuthenticationResponse</servlet-name>
        <servlet-class>ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet</servlet-class>
        <init-param>
            <param-name>AutoRewrite</param-name>
            <param-value>off</param-value>
        </init-param>
        <init-param>
            <param-name>InetAddress</param-name>
            <param-value>localhost:9443</param-value>
        </init-param>
        <init-param>
            <param-name>MappingType</param-name>
            <param-value>pathinfo</param-value>
        </init-param>
        <init-param>
            <param-name>URIPrefix</param-name>
            <param-value>/nevisfido/uaf/1.1/authentication</param-value>
        </init-param>
    </servlet>

    <servlet-mapping>
        <servlet-name>Connector_AuthenticationResponse</servlet-name>
        <url-pattern>/auth/fidouaf/authenticationresponse/</url-pattern>
    </servlet-mapping>
    ```

    :::
    **References:**

    * [SendUAFResponse Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-client-api-transport-v1.1-id-20170202.html#senduafresponse-dictionary)
    * [AuthenticationResponse Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticationresponse-dictionary)

15. nevisProxy forwards the SendUAFResponse to nevisFIDO.

    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/uaf/1.1/authentication`

    **References:**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/authentication-services/authentication-response-service)

16. nevisFIDO fetches the user's FIDO credential from nevisIDM. The credential contains the public key material that the FIDO Authenticator generated exclusively for this e-banking application and user during the registration.

    You can uniquely identify and fetch the credential by the "username/AppId/AAID/KeyId" quadruple.

17. nevisIDM returns the FIDO credential to nevisFIDO.

    nevisFIDO validates the AuthenticationResponse, including the `AuthenticatorSignAssertion`.

    nevisFIDO verifies the signature - and thus the integrity - of the `AuthenticatorSignAssertion`, with the public key from the related FIDO credential.

    In addition to the policy, nevisFIDO also uses the metadata stored locally on the server to validate the response. The metadata information must contain a descriptor of the FIDO Authenticator model used to perform the authentication.

    **References:**

    * [Authentication Response Processing Rules for FIDO Authenticator Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-protocol-v1.1-id-20170202.html#authenticationresponse-dictionary)

18. nevisFIDO returns a `ServerResponse` to the Relying Party mobile app through nevisProxy, informing that the authentication was successful.

    :::info

    When nevisFIDO returns the `ServerResponse`, you can consider the FIDO operation as completed. For authenticating purposes, however, Nevis Mobile Authentication must further consult nevisAuth.
    :::

    **References**

    * [ServerResponse Specification](https://fidoalliance.org/specs/fido-uaf-v1.1-ps-20170202/fido-uaf-client-api-transport-v1.1-ps-20170202.html#serverresponse-interface)

19. The mobile application provides the FIDO UAF session ID generated in step 5. This is required to trigger a
    synchronisation between nevisAuth and nevisFIDO.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/auth/fidouaf`

20. nevisProxy detects that the mobile application is not yet authenticated.

    nevisProxy forwards the request with the FIDO UAF session ID to nevisAuth.

    **Endpoint:** `https://<nevisAuth-host>:<nevisAuth-port>/nevisauth/services/AuthenticationService`

    **References**

    * [FidoUafAuthState](/nevisfido/reference-guide/config-nevis-components/nevisauth-fido-authstates/fido-uaf/fidouafauthstate)

21. nevisAuth queries nevisFIDO regarding the authentication status.

    nevisAuth verifies that the FIDO UAF session ID is the one stored in step 6. It sends the FIDO UAF session ID to the status service of nevisFIDO.

    **Endpoint:** `https://<nevisFIDO-host>:<nevisFIDO-port>/nevisfido/status`

    **References**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/status-service)

22. nevisFIDO confirms to nevisAuth that the authentication for the provided FIDO UAF session ID was successful.

    **References**

    * [nevisFIDO Reference Guide](/nevisfido/reference-guide/uaf-http-api/status-service)

23. nevisAuth forwards the `statusResponse` obtained from nevisFIDO to nevisProxy.
24. nevisProxy forwards the `statusResponse` to the mobile application.

    Although the authentication is considered completed, the session has not yet been marked as authenticated. This is because the nevisAuth flow is not completed yet.

25. To complete the authentication flow, the mobile application re-sends the request containing the FIDO UAF session ID.

    **Endpoint:** `https://<nevisProxy-host>:<nevisProxy-port>/auth/fidouaf`
26. nevisProxy forwards the request with the FIDO UAF session ID to nevisAuth.
27. Since the authentication was successful, nevisAuth will transition to the next configured AuthState with the "ok" transition.

    Here, the `DirectResponseState` is configured as the next AuthState after the `FidoUafAuthState`.
28. The next AuthState `DirectResponseState` sets the direct response payload to a static JSON containing:

    ```json
    {"status":"completed"}
    ```

29. The next AuthState, `DirectResponseState`, also sets the response to `AUTH_DONE`. It thus marks the authentication flow as complete.
30. With the result set to `AUTH_DONE`, a SecToken is generated. Furthermore, the session is marked as authenticated.
31. The mobile application receives the static JSON payload alongside a cookie. Both indicate that the session is now authenticated.
32. The mobile application can now access the services of the e-banking web server and display the account statement of the user.

    The cookie is used by nevisProxy to check that the application is authenticated.
--------------------------------------------------------------------------------
Section: ### Multiple Users in Device
In some cases, the device used to access the web application might be shared between different users. This may be the case, for example, for a company using proprietary hardware with an embedded FIDO Authenticator and a limited number of devices. In this scenario, it is useful to identify the user trying to authenticate beforehand. You can achieve this with [FIDO step-up authentication](/configurationguide/mobile-auth-concept-and-integration-guide/concept-description/fido-uaf-universal-authentication-framework#fido-uaf-step-up-authentication).

In this use case, nevisFIDO is aware of the user trying to authenticate. This allows nevisFIDO to limit the allowed FIDO UAF Authenticators to those registered by this user, and to send a list with only those authenticators to the FIDO UAF client. The client can then determine which FIDO Authenticators to use for authentication without interacting with the user.

It is possible to configure the `FidoUafAuthState` in nevisAuth to define the username (if any) to be sent to nevisFIDO.
You do this with the `fidoUafUsername` property:

```xml

<AuthState name="FidoUafAuthState" class="ch.nevis.auth.fido.uaf.authstate.FidoUafAuthState" final="false"
           resumeState="false">
    <ResultCond name="ok" next="AuthDone"/>
    <ResultCond name="error" next="AuthError"/>
    <ResultCond name="failed" next="AuthError"/>
    <property name="fidoUafServerUrl" value="https://localhost:8443"/>
    <property name="httpclient.tls.truststoreRef" value="DefaultKeyStore"/>
    <property name="fidoUafUsername" value="${notes:username}"/>
</AuthState>
```

In the example above, the username is retrieved from the notes stored in the nevisAuth session. The notes can be stored by a previously executed AuthState. nevisFIDO uses nevisIDM to store FIDO credentials, and the _extId_ of the user is the username. The previously executed AuthState could interact with the user to retrieve an identifier; the main task of the AuthState would be to retrieve the username (_extId_) from nevisIDM using this identifier. The following diagram describes this process:

<img className="boxed" src={require('../../assets/mobile-auth/uc-in-band-authentication-multiple-users.png').default}
alt="FidoUafAuthState Username Retrieval"/>

Another possibility is to retrieve the username at the client level. The application could send the username in the request. For example, if the `fidoUafUserName` property of the `FidoUafAuthState` is configured as follows:

```xml

<property name="fidoUafUsername" value="${inargs:o.username.v}"/>
```

The mobile client could send the username (again the _extId_ of the user in nevisIDM) in the first step of the authentication using JSON:

```json
{
  "username": "the_user_name"
}
```

If the application has an identifier of the user other than the _extId_, you could use the same approach as above.
However, you do not need to interact with the user, because in this case the identifier is provided by the application.

## Configuration Snippets

You will find example configuration snippets for all involved components in [Nevis Component Configuration Examples](/configurationguide/mobile-auth-concept-and-integration-guide/appendixes/nevis-component-configuration-examples).
--------------------------------------------------------------------------------
Section: ### dispatching-for-out-of-band-operations-push-notification-fallback.md
---
sidebar_position: 30
---

# Dispatching for Out-of-Band Operations - Push Notification Fallback

## Description

In the context of [out-of-band authentication](out-of-band-authentication), a user-friendly approach is to send the information with the Firebase Cloud Messaging service (short FCM service). The user must only click the push message that he/she receives on his mobile phone to open the application and proceed with the authentication.

But sometimes push service notifications do not work. In case of an outage in the provider network, for example, or when there are problems with the coverage. For these situations, Nevis Mobile Authentication provides two fallback authentication mechanisms. This chapter explains how the end user application interacts with the backend to trigger the fallback authentication mechanisms.

## Fallback Mechanisms

Nevis Mobile Authentication provides two different out-of-the-box fallback authentication mechanisms:

* **QR codes** The QR Code fallback mechanism is useful if the user accesses the protected web application via a desktop PC or laptop. Instead of sending a push notification to the user's mobile device, Nevis Mobile Authentication displays a QR code on the PC or laptop. The user must then scan this QR code with his mobile device to trigger the authentication.
* **Deep links** QR codes will not work if the user accesses the protected web application on the same mobile device used for mobile authentication - you cannot scan a QR code with the device displaying the code. In this case, it is possible to use deep links. When the user clicks on such a link, the authentication mobile application opens.

:::info

For more information, see the nevisFIDO Reference Guide ([QR Code Dispatcher](/nevisfido/reference-guide/dispatchers/qr-code-dispatcher)e Gnd [Link Dispatcher](/nevisfido/reference-guide/dispatchers/link-dispatcher)).The interaction with the backend is the same in both cases. The section below explains how this interaction works.
:::

## Fallback in Out-of-Band Authentication

To be able to understand how the fallback authentication works, you first need to understand the out-of-band authentication on the relying party level.

A relying party is for example a nevisAuth instance in case of an application protected by Nevis, or a credit card transaction web application in case of a payment. The relying party asks nevisFIDO whether a user has been authenticated. For this, the relying party uses the nevisFIDO session ID. When the user has been authenticated, the relying party gives the user access to the application that required authentication. So nevisFIDO does the *authentication*, and the relying party performs the *authorization*.

Now suppose it is necessary to use a fallback authentication mechanism. In this case, the relying party requests a new authentication, based on the respective fallback authentication mechanism (QR code or deep link). For this new authentication request, nevisFIDO will generate a new session ID, here referred to as *sessionID2.*The relying party will then check whether the user authenticated successfully for the session *sessionID2*.

:::info

It is up to the relying party whether to grant the user access to the requested application as soon as authentication is completed for the initial session ID, or only if the user has authenticated for the last session ID, *sessionID2*.s cuppose, for example, that the initial out-of-band mechanism is push notification, and the fallback mechanism is QRs code. Should the displaying of the QR code then invalidate the authentication with the push notification (which might only arrive a bit late)? The choice may depend on the desired user experience.

If nevisAuth is the relying party, it only uses the authentication triggered last to check whether nevisFIDO authenticated the user (the authentication that was triggered last is the one with session ID *sessionID2)*. This means that even if the user authenticates successfully with the initial request, nevisAuth will not use this to grant access to the protected application; nevisAuth only considers the user as authenticated when the latest generated authentication (with *sessionID2*) is completed. This makes the approach of nevisAuth in the fallback case very similar to its approach in the standard case.
:::

The fallback process consists of the following steps:

1. The web browser connects with the relying party asking for a service (access to a protected resource, do a credit card purchase, etc.). The relying party notes that the user must authenticate.
2. The relying party sends a request to nevisFIDO asking to authenticate the user. This is done by invoking a dispatcher, such as the Firebase Cloud Messaging dispatcher.
3. nevisFIDO returns a dispatch response to the relying party. This response contains a nevisFIDO session ID (*sessionID1*). The relying party uses the returned nevisFIDO session ID to determine whether the user authenticated in nevisFIDO.
4. The relying party forwards the nevisFIDO response to the web browser.
5. The web application running in the web browser decides that a fallback authentication is required. Multiple criteria can lead to this decision: Too much time has passed since the triggering of the initial authentication, the user wants to use an alternative authentication mechanism, etc. The web browser connects with the relying party asking for a new authentication with a fallback authentication method.
6. The relying party sends a request to nevisFIDO asking to authenticate the user with the fallback mechanism. If the fallback mechanism is QR code, nevisFIDO invokes the QR Code dispatcher. If the fallback mechanism is deep link, nevisFIDO invokes the Link dispatcher.
7. nevisFIDO returns the dispatch response to the relying party. This response contains a nevisFIDO session ID (*sessionID2*). The relying party uses the returned nevisFIDO session ID to determine whether the user authenticated in nevisFIDO.
8. The relying party forwards the nevisFIDO response to the web browser.
9. The web browser receives the nevisFIDO response. If QR code is used, the user scans the rendered QR code with the mobile authentication application. If a deep link is used, the user clicks the link to open the mobile authentication application. In both cases, the information is transmitted from the web browser to the authentication application.
10. The user authenticates using the mobile device.
11. The relying party checks with nevisFIDO whether the user has been authenticated. For this, the relying party uses the relevant session ID. The check can be triggered either by the relying party itself or indirectly by the web browser (by asking the relying party to do the check). If the user has been authenticated, the relying party gives access to the requested service. In case of a transaction confirmation, like a credit card payment, the relying party must guarantee that the payment is done only once. If the relying party allows authentication with the initial nevisFIDO session (*sessionID1*), either *sessionID1* or *sessionID2* should result in a single payment (for more information, see the info box above).

The following figure shows the fallback scenario if a user wants to access an e-banking application via the web browser in a desktop:

<img className="boxed" src={require('../../assets/mobile-auth/uc-oob-authentication-fallback-desktop.drawio.png').default} alt="Fallback Out-of-Band Authentication Using Desktop"/>

The figure below shows the fallback scenario if a user wants to access the e-banking application via his/her mobile device:

<img className="boxed" src={require('../../assets/mobile-auth/uc-oob-authentication-fallback-mobile.drawio.png').default} alt="Fallback Out-of-Band Authentication Using Mobile Only"/>

:::info

In the Nevis Mobile Authentication solution, it is the web application (the client) that decides whether to trigger a fallback authentication. Theoretically, it is also possible to decide this at the relying party level (the backend). However, this should be avoided:

* Using a fallback mechanism has an impact on the user interaction. This means that the client application is necessarily impacted anyway. Leaving most of the fallback logic at the client level keeps things simple at the backend.
* Some relying parties (such as nevisAuth) can only determine limited fallback criteria. Leaving this decision at the client level makes the mechanism more flexible and thus allows for a better user experience.

:::
--------------------------------------------------------------------------------
Section: ### high-level-architecture.md
---
sidebar_position: 11
---

# High-Level Architecture

To provide mobile authentication, Nevis Mobile Authentication relies on several Nevis components which contribute to the overall mobile authentication solution. The central components use are depicted in the following figure.

<img className="boxed" src={require('../../assets/mobile-auth/nevis-mobile-authentication-architecture.png').default}
alt="Nevis Mobile Authentication architecture"/>

Within the Nevis architecture, nevisFIDO acts as a service to implement the FIDO UAF 1.1 specification standard.

The nevisFIDO component tightly integrates with other Nevis components to deliver the complete mobile authentication feature. In the sections that follow, we highlight briefly the functions of the subsystems that work together to ultimately deliver mobile authentication to the client device in the hands of a user.

## Client Device

The client device represents the physical device owned by a user, e.g. a mobile phone. To use and benefit from Nevis Mobile Authentication, the client device requires a Relying Party mobile client to interact and authenticate against a Relying Party backend. The Relying Party mobile client consists of a Client (Business)
Application and the FIDO Client.

## Relying Party Backend

The relying party backend characterizes the **group of components** which in combination act together as the Relying Party backend of a FIDO Relying Party client. In the context of FIDO, communication between a FIDO Client and a FIDO Server *always* occur via the Relying Party client and Relying Party backend. In Nevis Mobile Authentication, it not only includes the necessary Nevis components described below but also the protected backend entity named *Web application* in the above figure.
--------------------------------------------------------------------------------
Section: #### nevisProxy
Towards the client-facing edge of the system, the **nevisProxy** component serves as the perimeter server. It's able to protect web applications from unauthenticated access and ensures that authentication takes place before requests are passed to those web applications. In Nevis Mobile Authentication, nevisProxy is configured to accept requests according to the FIDO UAF 1.1 protocol and forwards them to the authentication subsystem. As in all Nevis setups, additional functions of nevisProxy are web application firewall, session management (single sign-on), and reverse proxy functionality like routing and rerouting of requests to downstream components. In Nevis Mobile Authentication,o pevisProxy will route HTTP requests to the communication endpoints of nevisFIDO and nevisAuth, which in combination form
the authentication subsystem.
--------------------------------------------------------------------------------
Section: ### reference-deployment.md
---
sidebar_position: 18
---

# Reference Deployment

## Minimal Recommended Physical Deployment Infrastructure

The figure shows a typical, minimal deployment of the Nevis Mobile Authentication solution. The perimeter infrastructure consists of a Linux Server environment running *nevisProxy*to protect access to the internal application environment.
This in term is split into two servers, one running the relying party application,
the other one running the authentication environment consisting of *nevisAuth* and *nevisFIDO* and the identity management environment, consisting of *nevisIDM.*

:::info

Note that this solution outline does *not* provide load balancing capabilities.
:::

<img className="boxed" src={require('../../assets/mobile-auth/reference-deployment-diagram.png').default} alt="Nevis Mobile Authentication Reference Deployment Diagram"/>

## Scaling

Performance related scaling of the infrastructure can be achieved by vertical or horizontal scaling. Vertical scaling refers to increasing the hardware resources of the involved components (CPU, RAM). For more information regarding hardware and software requirements, see the [System Requirements](system-requirements) chapter.
--------------------------------------------------------------------------------
Section: ### Horizontal Scaling
Horizontal scaling can be achieved by using a shared, database backed session and token storage.

Multiple scaling setups are possible, the following figure outlines the two most likely ones:

<img className="boxed" src={require('../../assets/mobile-auth/horizontal-scaling.png').default} alt="Horizontal scaling examples"/>

* In the *instance based round robin* approach, one nevisAuth instance is configured to connect to two nevisFIDO
  instances using round robin.
* In the *"vertical line" load balancing*approach, a dedicated load balancer is used to balance the incoming requests
  between two (or more) complete Nevis authentication suite setups. In this example, the load balancer is placed in
  front of *nevisProxy,*however it can potentially be placed at different levels as well.
--------------------------------------------------------------------------------
Section: ### nevisadmin-plugin-authcloud.md
---
sidebar_position: 60
---
# nevisadmin-plugin-authcloud

## Authentication Cloud Login

Connects to the Nevis [Authentication Cloud](https://docs.nevis.net/authcloud/).

This step adds mobile authentication to your authentication flow.

You need an access app use this step.

The user must be registered in your Authentication Cloud instance. 
You can use the `Authentication Cloud Onboarding` pattern for that.

When the user exists, login confirmation is requested.
By default, a push notification is sent to trigger the Nevis Access App.

However, you can also show a QR code instead (see `Authentication Type`).

If the user is not registered or has no active authenticator,
the `On User Not Exists` exit will be taken and no screen will be shown.

Your authentication flow should include any of the following patterns in front of this pattern:

- `nevisIDM Password Login`: use when mobile authentication shall be a second factor
- `nevisIDM User Lookup`: use for passwordless login

nevisAuth will connect to your Authentication Cloud instance using TLS, so the CA certificate of the endpoint needs to be trusted.

If you get an `unable to find valid certification path to requested target` 
error in the nevisAuth log, then you have to import the CA certificate of the Authentication Cloud
endpoint into the `Default Backend Trust Store` of the `nevisAuth Instance`.
--------------------------------------------------------------------------------
Section: ### Proxy Server
If you have to go through a forward proxy for the outbound connection to firebase
enter the hostname:port here.

At the moment only HTTP proxy is supported.

## Authentication Cloud Onboarding

Connects to the Nevis [Authentication Cloud](https://docs.nevis.net/authcloud/).

This step can be used to enroll users. 

You need an access app use this step.

A QR code is shown which has be scanned with the app.

If the user is already registered and has an active authenticator,
the `On User Exists` exit will be taken and no screen will be shown.

Your flow should include any of the following patterns in front of this pattern:

- `nevisIDM Password Login`: use when Auth Cloud shall be used as second factor
- `nevisIDM User Lookup`: use for passwordless login

nevisAuth will connect to your Authentication Cloud instance using TLS
and thus the CA certificate of the endpoint needs to be trusted.

If you get an `unable to find valid certification path to requested target` error
in the nevisAuth log, then you have to import the CA certificate of the Authentication Cloud
endpoint into the `Default Backend Trust Store` of the `nevisAuth Instance`.
--------------------------------------------------------------------------------
Section: ### AuthState Class
Select one of the available implementations.

When `ScriptState` is selected, all requests sent by JavaScript are directed towards nevisAuth.
The script takes care of the communication with the nevisFIDO component, and thus you can restrict access to nevisFIDO. 
There is no need to expose any nevisFIDO APIs on the nevisProxy `Virtual Host`.

When `Fido2AuthState` is selected, configuration for `Fido2AuthState` is generated.
FIDO2 related requests are sent to nevisFIDO instead. This requires that the following nevisFIDO APIs 
are exposed on the nevisProxy `Virtual Host`:

- `/nevisfido/fido2/attestation/options`
- `/nevisfido/fido2/assertion/result`
- `/nevisfido/fido2/status`

The easiest way to ensure this is to add a `nevisFIDO FIDO2 REST Service` pattern to your project.

It is recommended to select the `Fido2AuthState` implementation as it is a more pragmatic solution whereas
the `ScriptState` is likely to be decommissioned.

This pattern is experimental and likely to change in future releases.
--------------------------------------------------------------------------------
Section: ### Authentication Level
Authentication level that is set on success.


## FIDO2 Management Demo

#*DEMO/TESTING ONLY - NOT FOR PRODUCTION USE*

Serves a simple HTML page with JavaScript to register a FIDO2 authenticator.

This is a simple and bare-bone example for demonstration and testing purposes and not intended for production use. 
It works only when the extId is used as username.
Provide your own version adapted to your integration scenario.

For instance, use `Hosting Service` to deploy your HTML and JavaScript on a nevisProxy `Virtual Host` 
or `Generic Authentication Step` when the registration shall be done within an authentication flow.

Visit the official [WebAuthn Guide](https://webauthn.guide/) for further information 
on how to do FIDO2-based registration and authentication.

The `nevisFIDO FIDO2 Instance` must be exposed on the same `Virtual Host`
using `nevisFIDO FIDO2 REST Service` pattern.

In the `nevisFIDO FIDO2 Instance` pattern `Relying Party ID` and `Relying Party Origins` must be set correctly, 
to allow AJAX calls from the JavaScript.

The client certificate used by `nevisFIDO FIDO2 Instance` must be uploaded as a certificate credential
for the `nevisfido` technical user. This should be done automatically in Kubernetes deployments but best double-check.

The credential type 23 must be allowed in the nevisIDM unit policy so that a FIDO2 Authenticator credential
can be created for the authenticated user.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Frontend Path
Enter the path where this example shall be exposed on the nevisProxy `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store provider for the HTTPs endpoint.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for SecToken verification.
--------------------------------------------------------------------------------
Section: ### Key Store
Assign a key store to be used for the 2-way TLS connection to nevisIDM.

If no pattern is assigned an automatic key store will be generated. 
This requires automatic key management to be enabled in the inventory.
Further, the pattern assigned to `nevisIDM` must be a `nevisIDM Instance`
which uses an automatic trust store for the `Frontend Trust Store`.

Note that it is required that the certificate used by nevisFIDO to connect to nevisIDM
is uploaded as a certificate credential for the `nevisfido` technical user.
This is done automatically when deploying to Kubernetes and using automatic key management 
on both sides. In any other case, this step has to be done manually.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the trust store for validating the nevisIDM endpoint.

The trust store should contain the certificate of the CA that
has issued the server certificate.

If no pattern is assigned an automatic trust store will be generated.
This requires automatic key management to be enabled in the inventory.

In that case the pattern assigned to `nevisIDM` must be a `nevisIDM Instance` pattern
which uses an automatic key store for the `Frontend Key Store`.
--------------------------------------------------------------------------------
Section: ### Syslog Host
Defines where to send logs to via syslog.

This configuration is used only when syslog forwarding is enabled (see `Log Targets`).

The syslog facility is `localhost3` and the threshold is `INFO`.

## nevisFIDO FIDO2 REST Service

Set up access to a `nevisFIDO FIDO2 Instance` on a nevisProxy `Virtual Host`.

This pattern will be adapted depending on the requirements of 
upcoming FIDO 2 use case patterns.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used by this pattern to establish a connection with the nevisAdapt component.
This trust store must trust the `nevisAdapt Instance`'s key store. Please reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin automatic key management.
--------------------------------------------------------------------------------
Section: ### TLS Encryption
If `enabled` the query parameter `useSSL=true` will be added to enable 1-way TLS.

If no `Trust Store` is assigned then `trustServerCertificate=true` will be added to the connection string.

Assignment of a `Trust Store` is recommended for production use.

**Note:** `PostgresSQL` database connection configuration doesn't support TLS connection yet.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### nevisAuth Instance
Add nevisAuth Instance reference pattern(s) to enable session termination in connected components. 
If the session store is shared, it is enough to add one instance per database.

Please make sure that all involved nevisAuth Instances have ManagementService enabled.
Add or extend a `Generic nevisAuth REST Service` for each with the following configuration:

```
<RESTService name="ManagementService" class="ch.nevis.esauth.rest.service.session.ManagementService" />
```
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for verifying the NEVIS SecToken. If no pattern is assigned the signer key will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### Syslog Host
Defines where to send logs to via syslog.

This configuration is used only when syslog forwarding is enabled (see `Log Targets`).

The syslog facility is `localhost3` and the threshold is `INFO`.

## nevisAdapt REST API

The pattern exposes the nevisAdapt REST API on a nevisProxy `Virtual Host`.

The nevisAdapt REST API is available via `/nevisadapt/api`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the trust store for outbound TLS connections.

If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisAdapt Instance`
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### CSRF Protection
_Cross-Site Request Forgery_ (_CSRF_) is an attack to force an authenticated user to send unwanted requests.

- `off (default)` - no CSRF protection. Recommended for applications which may be called from other sites.
- `header-based` - `GET` and `HEAD` requests are allowed (assumption: these methods must not manipulate server-side state). 
For other requests the `Referer` and `Origin` headers must match the `Host` header.

## nevisAdapt Remember Me Step

Using the pattern, you can integrate nevisAdapt as a remember-me service in nevisAuth.

If the provided token is found and still valid, the authentication process is cut shorter.

If no remember-me token is provided or it's no longer valid, the step generates a new one
then initiates the original full authentication process. If all the authentication steps
complete successfully, nevisAdapt persists the new token so that it can be used for quick
entry later. Keep `On Success` empty in order to shortcut the authentication flow.

CAUTION: if `On Success` and `Original Authentication Flow` are set to the same step, it disables
the remember-me functionality.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used by this pattern to establish a connection with the nevisAdapt component.
This trust store must trust the `nevisAdapt Instance`'s key store. Please reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin automatic key management.
--------------------------------------------------------------------------------
Section: ### Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for verifying the NEVIS SecToken. If no pattern is assigned the signer key will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign an add-on pattern to customize the configuration.

## nevisDetect Administration GUI

The pattern exposes the nevisDetect Frontend GUIs on a nevisProxy `Virtual Host`.

The Administration GUI is available on `/nevisdetect/admin`.
--------------------------------------------------------------------------------
Section: ### nevisDetect Admin
Reference for the pattern with the details of the web application.

Supported patterns:
- nevisDetect Admin Instance
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the trust store for outbound TLS connections.

If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisDetect Admin`
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### TLS Encryption
If `enabled` the query parameter `useSSL=true` will be added to enable 1-way TLS.

If no `Trust Store` is assigned then `trustServerCertificate=true` will be added to the connection string.

Assignment of a `Trust Store` is recommended for production use.

**Note:** `PostgresSQL` database connection configuration doesn't support TLS connection yet.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Sub-path Restriction
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for verifying the NEVIS SecToken. If no pattern is assigned the signer key will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### Message Queue Client Trust Store
Reference a trust store provider pattern or leave empty to manage the trust store with nevisAdmin.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign an add-on pattern to customize the configuration.

## nevisDetect Persistency REST API

The pattern exposes the nevisDetect Frontend GUIs on a nevisProxy `Virtual Host`.

The nevisDetect Persistency REST API is available on `/nevisdetect/persistency`.
--------------------------------------------------------------------------------
Section: ### nevisDetect Persistency
Reference for the pattern with the details of the web application.

Supported patterns:
- nevisDetect Persistency Instance
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the trust store for outbound TLS connections.

If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisDetect Persistency`
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which shall be used for outbound TLS connections to nevisIDM.
If no pattern is assigned no trust store will be generated.

For nevisDataPorter to use the trust store,
the following expressions should be used inside the `dataporter.xml` file:

```
${idm.truststore}
${idm.truststore.password}
```

Example configuration:

```xml
<object type="NevisIDMConnectionPool" name="adminService">
    <dp:paraVal name="endpoint" value="${cfg.idmEndpoint}"/>
    <dp:paraVal name="loginMode" value="proxyCert"/>
    <dp:paraMap name="sslSettings">
        <value name="javax.net.ssl.trustStore" value="${idm.truststore}"/>
        <value name="javax.net.ssl.trustStorePassword" value="${idm.truststore.password}"/>
        ...
    </dp:paraMap>
</object>
```
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point for the callback from social login provider.

In case your host has
* 1 address, that address will be used
* many addresses with
  * 1 https, and many http, the https will be used without warning
  * mix between http and https, the 1st https will be used with warning
  * single scheme (http or https only) the 1st address will be used with warning

E.g.
```
http://nevis.net
http://nevis-security.net
https://nevis.net
https://nevis-security.net
```
The `https://nevis.net` will be used as the host for Apple callback
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.


## OAuth 2.0 / OpenID Connect Metadata Endpoint

Sets up a Metadata endpoint for OAuth 2.0 / OpenID Connect.
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.


## OAuth 2.0 / OpenID Connect Pushed Authorization Request Endpoint

Sets up a Pushed Authorization Request endpoint for OAuth 2.0 / OpenID Connect.
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.
--------------------------------------------------------------------------------
Section: ### Endpoint Path
If you enter a **path** the REST service will be generated and exposed on the nevisProxy `Virtual Host`
assigned to the `OAuth 2.0 Authorization Server / OpenID Provider`.

The prefix `exact:` is not supported here, enter the path as-is.

If you enter a **URL** no REST service will be generated.
Use this variant if you want to use an external service.

Either way, the information will be used by the `OAuth 2.0 / OpenID Connect Metadata Endpoint`
to provide metadata.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### OpenID Connect Issuer
Enter the _issuer_ for OpenID Connect.

The value must be a case-sensitive URL using the https scheme that contains at least scheme and host.
The port number and path component are optional. No query or fragment components are allowed.

If not set the issuer will be calculated based on:

- the first `Frontend Address` with scheme `https` of the assigned `Virtual Host`
- the first `Frontend Path`
--------------------------------------------------------------------------------
Section: ### JWK Set Endpoint Trust Store
Assign a trust store for the outbound TLS connection to JWK Set endpoint for ID Token encryption.

Import the CA certificate of the `JWK Set endpoint` into this trust store.

Since version 4.38 nevisAuth trusts CA certificates included in the JDK.

Thus, it is not required to configure this.

However, you can still configure a trust store here to be as strict as possible.
--------------------------------------------------------------------------------
Section: ### On Success
The step executed after a successful authentication.
If no step is configured here the process ends with `AUTH_DONE`.

**Note**: In order to have profile selection in case account have multiple profiles, you need to use the User Lookup pattern.

## nevisMeta Connector

Use to connect to an existing nevisMeta instance.

Use the pattern only when the instance is not set up by this project.

Ensure that the SecToken trust store of the instance allows the 
SecToken signers used in this project.
--------------------------------------------------------------------------------
Section: ### TLS Encryption
If `enabled` the query parameter `useSSL=true` will be added to enable 1-way TLS.

If no `Trust Store` is assigned then `trustServerCertificate=true` will be added to the connection string.

Assignment of a `Trust Store` is recommended for production use.

**Note:** `PostgresSQL` database connection configuration doesn't support TLS connection yet.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store for the HTTPs endpoint.

If no pattern is assigned a Trust Store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign a Trust Store which is used to validate the signature of a received NEVIS SecToken.

There are 2 use cases which require validation:

- when a user accesses the `nevisMeta Web Console` the SecToken is signed using `NEVIS SecToken` / `Key Store`.
- when nevisAuth calls nevisMeta the SecToken is signed using `nevisAuth Instance` / `Internal SecToken Signer`.

If no pattern is assigned the trust store will be provided by nevisAdmin 4 automatic key management. 
However, this requires that automatic key management is used in the `NEVIS SecToken` and `nevisAuth Instance` patterns.
--------------------------------------------------------------------------------
Section: ### Client Authentication
Setting for 2-way TLS on the nevisMeta HTTPs endpoint. There are 3 options will
affect the callers (e.g. nevisProxy or technical clients accessing nevisAuth REST APIs)

* required: Callers **must** present a client certificate.
* requested: Callers **can** present a client certificate.
* disabled: Callers **must not** use a client certificate.

The `Frontend Trust Store` must contain the issuing CA.
--------------------------------------------------------------------------------
Section: ### Syslog Host
Defines where to send logs to via syslog.
 
This configuration is used only when syslog forwarding is enabled (see `Log Targets`).

The syslog facility is `localhost3` and the threshold is `INFO`.

## nevisMeta REST Service

The pattern exposes the nevisMeta REST API on a nevisProxy `Virtual Host`.

The REST API is exposed on the path `/nevismeta/rest`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign add-on patterns to customize the behaviour of this service.

Example use cases:

- `Authorization Policy` to enforce roles or an authentication level.
- `URL Handling` to redirect or forward requests.
- `HTTP Header Customization` to add, replace, or remove HTTP headers in requests or responses.


## nevisMeta Web Console

Sets up the [nevisMeta Web Console](https://docs.nevis.net/nevismeta/Concept-Description-and-Technical-Architecture/Architecture-overview#web-console), 
which is a component supporting the setup of OAuth2 and OpenID Connect for nevisAuth.

You can access the Web console on the assigned Virtual Host.

For instance, let's say your domain is example.com, and you have entered https://example.com as a Frontend Addresses in the Virtual Host pattern. This means that you can access the Web console on https://example.com/nevismeta/.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign the Trust Store provider for outbound TLS connections.
If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisMeta`
--------------------------------------------------------------------------------
Section: ### On Entry
Point to the first step of the authentication process.

## Authentication Done

Completes an authentication flow.

The pattern may only be used as the last step within an authentication flow.

Use as explicit follow-up for patterns such as `Generic Authentication Step` and `User Information`
which do not add follow-up steps automatically.

## Authentication Failed

Shows a GUI with the error message `error_99`.
When the GUI is shown, the session is terminated.

If `HTTP Error Code` is configured and the configured code is handled on the nevisProxy `Virtual Host`
then the GUI is not shown, and a static error page is presented instead.

The pattern may only be used as the last step within an authentication flow.

Use as explicit follow-up for patterns such as `Generic Authentication Step` and `User Information`
which do not add follow-up steps automatically.
--------------------------------------------------------------------------------
Section: ### HTTP Error Code
Enter a status code for error page produced by nevisAuth.
If not set the status code will be `200`.

Note that the error page from nevisAuth will not be shown, 
when error handling is applied by nevisProxy.

nevisProxy replaces the body of the HTTP response, when there is a page for this status code, 
uploaded to `Hosted Resources` of the `Virtual Host`, or to a `HTTP Error Handling` pattern.

## Authentication Realm

This pattern defines how to authenticate access to applications.

You can assign this pattern to your applications as `Authentication Realm`,
or expose it as a `SAML IDP` or `OAuth 2.0 Authorization Server / OpenID Provider`.

Examples how to authenticate your users can be found in the [Concept & Configuration Guide](https://docs.nevis.net/configurationguide/use-cases/Authentication/).

The authentication processes are provided by a `nevisAuth Instance` which has to be assigned.
For rendering the pages during authentication, nevisLogrend is used.
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.

If no pattern is assigned automatic key management is used to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses 
for validating the signature of the NEVIS SecToken issued by nevisAuth. 

If no pattern is assigned automatic key management is asked to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter` generated by this pattern.

Most realms generate only 1 `IdentityCreationFilter` named `Authentication_<name>`, 
which is used to protect the application.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                 |
|----------------------|---------------------------------------|
| BodyReadSize         | 64000                                 |
| InterceptionRedirect | Condition:ENV:HTTP_USER_AGENT:mozilla\|Mozilla\ninitial\nnever |
| ClientCert           | want                                  |
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### nevisProxy: Simple Template
nevisProxy provides a simple login page renderer which can be used instead of nevisLogrend.
See `Login Renderer` for details.

For each enabled language (e.g. `en`) upload a file named `<lang>_template.html`.
The template must contain the placeholder `NEVIS_AUTH_FORM`. 

If your templates require additional resources (e.g. CSS, images)
upload them as `Hosted Resources` on the nevisProxy virtual host.
--------------------------------------------------------------------------------
Section: ### Language Cookie Domain
Enter a domain for the cookie that nevisLogrend issues 
to remember the language of the user.

This setting should only be used when you want to issue a _wildcard cookie_
to share the language with other sub-domains (e.g. across multiple `Virtual Host`).

For instance, if you enter `.example.com` then 
the cookie will also be sent to `subdomain.example.com`.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.

If no pattern is assigned automatic key management is used to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses 
for validating the signature of the NEVIS SecToken issued by nevisAuth. 

If no pattern is assigned automatic key management is asked to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter` generated by this pattern.

Most realms generate only 1 `IdentityCreationFilter` named `Authentication_<name>`, 
which is used to protect the application.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                 |
|----------------------|---------------------------------------|
| BodyReadSize         | 64000                                 |
| InterceptionRedirect | Condition:ENV:HTTP_USER_AGENT:mozilla\|Mozilla\ninitial\nnever |
| ClientCert           | want                                  |
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### nevisProxy: Simple Template
nevisProxy provides a simple login page renderer which can be used instead of nevisLogrend.
See `Login Renderer` for details.

For each enabled language (e.g. `en`) upload a file named `<lang>_template.html`.
The template must contain the placeholder `NEVIS_AUTH_FORM`. 

If your templates require additional resources (e.g. CSS, images)
upload them as `Hosted Resources` on the nevisProxy virtual host.
--------------------------------------------------------------------------------
Section: ### Custom Dependencies
In case your `AuthState` elements use custom classes upload the required JAR file(s) here.

Files uploaded here will be deployed into the `lib` directory of the nevisAuth instance.

## Generic Authentication Service

Defines an authentication service which is exposed 
on the given `Frontend Path` on the assigned `Virtual Host`.

Requests received on this path are forwarded to nevisAuth.

Use to import an existing configuration.

We recommend you implement complex self-service and registration processes in a dedicated application, 
for example, using the SOAP or REST API of nevisIDM.

The pattern can also provide authentication for applications exposed on nevisProxy,
see `Generic Authentication Realm` for details.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve
as entry point for this authentication service.
--------------------------------------------------------------------------------
Section: ### Frontend Path
Define a path to be mapped on the assigned virtual host.

Requests sent to this path will be forwarded to nevisAuth
so that they can be handled by this authentication service.
--------------------------------------------------------------------------------
Section: ### Configuration
Enter `AuthState` elements as XML.

The `Domain` element is optional.

- If missing the element will be created. The `Entry` methods 
`authenticate` and `stepup` will be set to the first provided `AuthState`. 
The method `logout` is not set and thus the nevisAuth default behaviour applies.

- If provided the `Domain` must come before all `AuthState` elements. 
The attributes `name` and `default` are not supported and should be omitted.
Attributes are sorted by name. The `Entry` elements are sorted by `method`.

The `AuthState` linked to `stepup` should be able to dispatch the request.
For instance, you may have assigned an `Authorization Policy` to your application(s)
and thus you need a state which decides based on the request variable `requiredRoles`.

The following example dispatches level `2` into an `AuthState` named `TAN`
which provides authentication via mTAN:

```
<AuthState name="EntryDispatcher" class="ch.nevis.esauth.auth.states.standard.ConditionalDispatcherState" final="false">
    <ResultCond name="nomatch" next="Authentication_Done"/>
    <ResultCond name="level2" next="TAN"/> <!-- TAN state is expected to set authLevel="2" -->
    <Response value="AUTH_ERROR">
        <Arg name="ch.nevis.isiweb4.response.status" value="403"/>
    </Response>
    <property name="condition:level2" value="${request:requiredRoles:^2.*$:true}"/>
</AuthState>
```

The following expressions are supported:

- `${instance}`: name of the nevisAuth instance
- `${request_url}`: generates a nevisAuth expression which returns the URL of the current request
- `${realm}`: name of the Realm (see below)
- `${service_url}`: generates a nevisAuth expression which evaluates to true for requests received on the configured `Frontend Path`
- `${service.postfix}`: in Kubernetes side-by-side deployment a postfix is added to service names. Use this expression when connecting to a service deployed against the same inventory.
- `${keystore}`: name of the `KeyStore` element provided by this pattern. Assign a pattern to `Key Objects` to add a `KeyObject` into this `KeyStore`. 

The `name` of `AuthState` elements is prefixed 
with the sanitized name of the Realm (referred to as `${realm}`).

The realm prefix must be added when using `propertyRef` to reference AuthStates
generated by other patterns (e.g. `<propertyRef name="${realm}_SomeState"/>`).

An exception is the AuthState which defines the nevisIDM connection 
(as generated by `nevisIdm Password Login` or `nevisIDM Connector for Generic Authentication`).
Here the `propertyRef` must be defined as follows: 

`<propertyRef name="nevisIDM_Connector"/>`

This pattern does not validate that labels are translated.
Translations can be provided on the `Authentication Realm` pattern.
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.

If no pattern is assigned automatic key management is used to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses 
for validating the signature of the NEVIS SecToken issued by nevisAuth. 

If no pattern is assigned automatic key management is asked to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter` generated by this pattern.

Most realms generate only 1 `IdentityCreationFilter` named `Authentication_<name>`, 
which is used to protect the application.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                 |
|----------------------|---------------------------------------|
| BodyReadSize         | 64000                                 |
| InterceptionRedirect | Condition:ENV:HTTP_USER_AGENT:mozilla\|Mozilla\ninitial\nnever |
| ClientCert           | want                                  |
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### nevisProxy: Simple Template
nevisProxy provides a simple login page renderer which can be used instead of nevisLogrend.
See `Login Renderer` for details.

For each enabled language (e.g. `en`) upload a file named `<lang>_template.html`.
The template must contain the placeholder `NEVIS_AUTH_FORM`. 

If your templates require additional resources (e.g. CSS, images)
upload them as `Hosted Resources` on the nevisProxy virtual host.
--------------------------------------------------------------------------------
Section: ### Frontend Path Settings
Assign add-on patterns to customize the `Frontend Path`.

## Generic Authentication Step

Define an `authentication step` using XML elements as described in the nevisAuth reference guide. 

An `authentication step` consists of one or multiple `AuthState` elements which belong together, 
for example, username / password login against LDAP with enforced password change.
--------------------------------------------------------------------------------
Section: ### Authentication Application
Optionally assign an application which provides the authentication service
and shall be exposed on the same virtual host as the applications.

Not required for federation-based authentication 
where the authentication service is hosted on another domain.
--------------------------------------------------------------------------------
Section: ### Environment Variables
Add additional environment variables to the nevisAuth `env.conf`.

The standard environment variables `RTENV_SECURITY_CHECK` and `JAVA_OPTS`
will always be present in `env.conf` and can't be overwritten using this setting.


## Generic nevisAuth REST Service

Configures a nevisAuth REST service 
using the XML syntax described in the [nevisAuth Technical Documentation](https://docs.nevis.net/nevisauth/setup-and-configuration/components/rest-service-api).

The service is not exposed on a nevisProxy `Virtual Host`, 
it is accessible on the assigned `nevisAuth` only.

The XML attribute `path` defines which requests are handled.
--------------------------------------------------------------------------------
Section: ### Template Parameters
Define _Template Parameters_.

Examples:

```yaml
smtp: smtp.siven.ch
sender: noreply@siven.ch
```

These parameters can be used in your `Configuration`.

The expression formats are:

`${param.<name>}`:

- `name` found: parameter value is used.
- `name` missing: expression is **not** replaced.

`${param.<name>:<default value>}`:

- `name` found: parameter value is used.
- `name` missing: default value will be used.

In `<default value>` the character `}` must be escaped as `\}`.

## Generic nevisAuth Web Service

Configures a nevisAuth Web service 
using the XML syntax described in the [nevisAuth Technical Documentation](https://docs.nevis.net/nevisauth/setup-and-configuration/components/soap-web-services).

The service is not exposed on a nevisProxy `Virtual Host`, 
it is accessible on the assigned `nevisAuth` only.

The XML attribute `uri` defines which requests are handled.
--------------------------------------------------------------------------------
Section: ### Parameters
Define _Parameters_ to be used in the `JSON Response`.

Examples:

```yaml
backend-host: backend.siven.ch
```

The expression formats are:

`${param.<name>}`:

- `name` found: parameter value is used.
- `name` missing: expression is **not** replaced.

`${param.<name>:<default value>}`:

- `name` found: parameter value is used.
- `name` missing: default value will be used.

In `<default value>` the character `}` must be escaped as `\}`.


## JWT Token

Assign to a realm using `Application Access Tokens` 
to allow the realm to produce a JWT token.

To issue a JWT token and propagate it to applications you also have to assign the pattern to
the corresponding `Web Application`, `REST Service`, or `SOAP Service` 
using `Application Access Token`.

The JWT token is sent in an HTTP header (default: `Authorization`) 
in the format `Bearer <token>`.
--------------------------------------------------------------------------------
Section: ### Frontend Addresses
Enter the `Frontend Addresses` of the nevisProxy `Virtual Host` patterns 
for which this pattern provides authentication.

Example:

- `www.siven.ch`

In case multiple values are configured you can define which `Keytab File` or `Keytab File Path` 
to use by referencing its file name.

Example:

- `www.siven.ch -> kerberos_ch.keytab`
- `www.siven.de -> kerberos_de.keytab`
--------------------------------------------------------------------------------
Section: ### Frontend Addresses
Enter the `Frontend Addresses` of the nevisProxy `Virtual Host` patterns 
for which this pattern provides authentication.

Example:

- `www.siven.ch`

In case multiple values are configured you can define which `Keytab File` or `Keytab File Path` 
to use by referencing its file name.

Example:

- `www.siven.ch -> kerberos_ch.keytab`
- `www.siven.de -> kerberos_de.keytab`
--------------------------------------------------------------------------------
Section: ### On Failure
Assign authentication step that is processed if Kerberos authentication fails.

If no step is assigned an AuthState `Authentication_Failed`
will be created automatically.

## LDAP Login

Username / password login for LDAP.

For `Web Application`, an initial redirect (to `?login`) is performed and a login GUI is shown.

Basic authentication may be used to call a REST or SOAP service.

Double-check the URL you are calling as 
nevisProxy responds with a redirect if no servlet could be found otherwise (`trailingSlashRedirect`).
--------------------------------------------------------------------------------
Section: ### LDAP Endpoints
Configure the LDAP endpoint.
The URL must start with `ldap://` or `ldaps://`

In case of `ldaps://` you may have to import the certificate of the CA which has issued the certificate of the LDAP server into the `Backend Trust Store` on the `nevisAuth Instance`.
--------------------------------------------------------------------------------
Section: ### Gui Title
Change the Gui title.

We recommend to enter a label here and provide translations for this label in the `Authentication Realm`.


## NEVIS SecToken

Assign to a realm using `Application Access Tokens`.
This enables the realm to produce a Nevis SecToken.

To issue a SecToken and propagate it to applications 
also assign the pattern to the corresponding `Web Application`, 
`REST Application`, or `SOAP Application` using `Additional Settings`.

On the application server you may use Ninja to extract the SecToken 
from the `Authorization` header. It is transferred as the Basic Auth password.

As Ninja validates the signature of the SecToken,
you have import the signer certificate into the Ninja truststore.
--------------------------------------------------------------------------------
Section: ### None Found
Assign a step to continue with when the user has **none** of the configured roles.

If no step is assigned, error code `403` will be returned in this case.


## SAML IDP

Sets up a SAML Identity Provider (_IDP_).

The `Authentication Realm` provides Single-Sign-On.

By default, only SP-initiated authentication is allowed. This method is most secure and standard.

Service providers (_SP_) may initiate authentication by sending an `AuthnRequest`
to any of the configured `Frontend Path(s)`.

You can enable IDP-initiated authentication via the `Authentication Type` drop-down.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
Define paths for the following cases.

- **SP-initiated authentication**

Service providers may send a parameter `SAMLRequest` containing an `AuthnRequest` (using POST or redirect binding) 
to request authentication. On successful authentication the IDP returns a SAML `Response`.

On entry an initial session will be created.
The session may expire during authentication due to timeout. 

When this happens an error page (name: `saml_dispatcher`) with title `title.saml.failed` 
and error message `error.saml.failed `will be rendered.

- **SP-initiated logout**

Service providers may send a `LogoutRequest` (POST or redirect binding)
to logout from this IDP and other service providers.

- **IDP-initiated logout**

Applications may have a link pointing to the IDP to trigger a global logout. 

This link may point to:

- `<path>/logout`: to show a logout confirmation page (GUI name: `saml_logout_confirm`, label: `info.logout.confirmation`)
- `<path>/?logout`: to skip the logout confirmation page.

If a `Referer` header has been sent by the browser, the logout confirmation page will have a `cancel` button which redirects to the referer.
Note that if the SP is NEVIS you may have to adapt the `Security Response Headers` of the `Virtual Host`.
By default, the header `Referrer-Policy: strict-origin-when-cross-origin` is set and this will prevent the path being sent so the `cancel` button will redirect to `/`.

During SAML logout the IDP renders a GUI named `saml_logout`
with the following hidden fields:

- `saml.logoutURLs`: the URL of the SPs including `LogoutRequest` message as query parameter
- `saml.logoutURL`: the URL to redirect to after successful logout

The default nevisLogrend template contains Javascript to invoke all `saml.logoutURLs`
and redirect to `saml.logoutURL` after all requests have been sent. This is a best effort operation 
which means that the JavaScript does not check if the logout was successful.

- **IDP-initiated authentication**

Requests to the base path without `SAMLRequest` will trigger IDP-initiated authentication.

In this case the following parameters must be sent: 

- `Issuer`: as entered for a `SAML SP Connector`
- `RelayState`: this parameter is returned to the SAML SP together with the `Response`
--------------------------------------------------------------------------------
Section: ### Metadata Service Path
Enter a path where the _SAML Metadata Service_ shall be exposed
on the assigned `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### IDP Issuer
Enter the `Issuer` of the IDP.

Example: `https://idp.example.org/SAML2`

The `Issuer` is used to look up the trust store 
containing the signer certificate of the IDP.

For this purpose a `KeyObject` element will be configured
in the nevisAuth `esauth4.xml` using the `Issuer` 
for the attribute `id`.
--------------------------------------------------------------------------------
Section: ### IDP URL
Enter the `Location` of the SAML `SingleSignOnService`.
This may be a URL or a path on the same virtual host.

nevisAuth will send an `AuthnRequest` to this location
to delegate the authentication or session upgrade process 
to the IDP.

By default, the `AuthnRequest` contains a `RequestedAuthnContext` 
which specifies the required authentication level.
You can disable this feature via `Custom Properties`.
--------------------------------------------------------------------------------
Section: ### IDP Signer Trust Store
Assign a pattern to configure the signer certificate of the identity provider.
--------------------------------------------------------------------------------
Section: ### Custom Follow-up Steps
Assign follow-up steps.
 
The order of steps is relevant. 
The first step in this list has index `1`. 
 
You may reference a step in the configuration
via the `Custom Transitions`.

## SAML Response Consumer

The pattern exposes an authentication service on the assigned `Virtual Host`.

The service can consume incoming SAML Response or SAML artifact messages,
and can execute an optional post-processing flow.

The overall process may work as follows:

- Consume a SAML `Response` and `RelayState` on the `Frontend Path`. The `RelayState` must contain the URL of an application.
- If configured, execute the `Post-Processing Flow`.
- The authentication is now done.
- Redirect to the `RelayState` parameter pointing to the application.
- Assuming the application is protected by the realm assigned to this pattern, the caller is allowed access.
--------------------------------------------------------------------------------
Section: ### Frontend Paths
Enter a path where SAML `Response` messages sent by an external IDP shall be consumed.

The external IDP may send messages using POST or redirect binding.
--------------------------------------------------------------------------------
Section: ##### SAML Artifact Binding
To use SAML Artifact Binding with a certain IDP,
the `Artifact Resolution Service` must be configured in the `SAML IDP Connector`.

The flow begins with the IDP sending an `ArtifactResponse` message to any of the configured frontend paths.

Now an `ArtifactResolve` message will be created and signed using this certificate.
The message will then be sent to the IDP via a server-to-server call.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Define custom `init-params` for the nevisProxy `DelegationFilter`
which propagates the SAML Response to the backend.

This setting is experimental and may be adapted in future releases.

Examples:

- `DelegatePostPolicy: override` - create a new POST request and send it to the `Assertion Consumer Service Path`. 
The response is returned to the client which means that the original (GET) request is lost. However, the SP can redirect to the application. This mode should be preferred for proper SP integration.

- `DelegatePostPolicy: sidecall` - send a POST request to the `Assertion Consumer Service Path` but do not return the response to the client. 
Afterwards, the original (GET) request is sent. This mode may be required in case the response of the POST request does not redirect to the application.

## SAML SP Connector

The pattern defines the connection to a SAML Service Provider (_SP_).

Assign the pattern to a `SAML IDP`.
--------------------------------------------------------------------------------
Section: ### SP URL - Assertion Consumer Service(s)
Enter the _Assertion Consumer Service URL_ of the SP.

Enter multiple values if the same SP can be accessed via multiple URLs.

If the SP is provided by a `SAML SP Realm` the URLs are structured as follows:

- scheme, host and port: `Frontend Addresses` of each `Virtual Host` where the `SAML SP Realm` is used.
- path component: `Assertion Consumer Service` of the `SAML SP Realm`.

The URLs are used during SP-initiated SAML authentication to validate incoming SAML requests.
The `assertionConsumerServiceURL` attribute of received SAML `AuthnRequest` messages must match one of these URLs.

The first URL is also used for IDP-initiated authentication (property `spURL` of the `IdentityProviderState`).

IDP-initiated authentication may be triggered by sending a request 
to any of the `Frontend Path(s)` of the `SAML IDP`.
The following parameters must be provided either in the query or as `POST` parameters:

- `Issuer` - the unique name used by the SP (also called `entityID` in the SAML metadata).
- `RelayState` - will be sent back to the SP together with the SAML `Response` when authentication is done. 
In case the SP is setup by a `SAML SP Realm` this should a URL of an application protected by this realm.
--------------------------------------------------------------------------------
Section: ### SP Signer Trust Store
Configure the trust store used to validate incoming SAML messages
(e.g. `AuthnRequest`, `LogoutRequest`) which are sent by this SP.
--------------------------------------------------------------------------------
Section: ### Message Encryption Trust Store
Assign a pattern to configure the certificate to encrypt the outgoing message to the service provider.
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.

If no pattern is assigned automatic key management is used to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses 
for validating the signature of the NEVIS SecToken issued by nevisAuth. 

If no pattern is assigned automatic key management is asked to provide the trust store.
This requires that the `nevisAuth Instance` is part of this project and also uses automatic key management. 

Automatic key management should be used for test setups only.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter`
generated by this pattern.

This pattern generates 2 `IdentityCreationFilter` elements:

1. `Authentication_<name>`: enforces authentication for applications.
2. `SAML_<name>`: provides the `Assertion Consumer Service` and `Session Upgrade Path`

If you want to patch only one of these filters 
consider using `Generic Application Settings` instead.

Note that the parameter `InterceptionRedirect` of the `SAML_<name>` filter
is forced to `never`. If you configure `InterceptionRedirect` here
it will be ignored for this filter as leads to message loss in SAML POST binding.

Examples:

- `BodyReadSize = 64000`
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### nevisProxy: Simple Template
nevisProxy also provides a simple login page renderer.

For each enabled language (e.g. `en`) upload a file named `<lang>_template.html`.
The template must contain the placeholder `NEVIS_AUTH_FORM`. 

If your templates require additional resources (e.g. CSS, images)
upload them as `Hosted Resources` on the nevisProxy virtual host.
--------------------------------------------------------------------------------
Section: ### Custom Properties
Enter custom properties for the nevisAuth `IdentityProviderState`
which issues the SAML `Response` (or `Assertion`).

Please check the technical documentation for details.

Common use cases are:

- `out.issuer`: sets the `Issuer` element (By default, the sanitized name of the pattern is used)
- `out.audienceRestriction`: some recipients require this to be set to decide if they accept the token
- `out.signatureKeyInfo`: add information about the signer certificate

Examples:

```
out.authnContextClassRef = urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
out.sessionIndex = ${notes:saml.assertionId}
out.signatureKeyInfo = Certificate
out.subject.format = urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified
out.ttl = 10
relayState = ${request:currentResource}
```

## SAP Logon Ticket

Assign to a realm using `Application Access Tokens` 
to allow the realm to produce an SAP Logon Ticket.

To issue an SAP Logon Ticket and propagate it to applications you also have to assign the pattern to
the corresponding `Web Application`, `REST Service`, or `SOAP Service` 
using `Application Access Token`.

The issued SAP Logon Ticket may either be propagated to the client as a cookie (for pseudo-federated scenarios 
based on shared cookie domain spaces) or propagated to a backend application behind a nevisProxy instance.
--------------------------------------------------------------------------------
Section: ### API Key
API key to connect to Sendgrid.

## Standalone Authentication Flow

Use this pattern to build custom self-admin use cases,
for example, user registration, password reset, mobile change.

The authentication flow is exposed on the assigned `Virtual Host`.
Requests received on the configured `Frontend Path` are dispatched into an authentication step.

The flow is always executed, even when the user already has an authenticated session.

Be aware that on successful execution of the flow,
the caller may be authenticated in the assigned `Authentication Realm`,
and thus will be able to access any applications protected by that realm.

For use cases which do not require an authenticated session
it is therefore recommended to use a separate realm.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
Enter frontend path(s) which should be handled.
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the allowed HTTP methods. 

If not configured, all HTTP methods are allowed.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store for the outbound TLS connection to SwissPhone.

Import the CA certificate of the `Portal Server` into this trust store.

Since version 4.38 nevisAuth trusts CA certificates included in the JDK.

Thus, it is not required to configure this. 

However, you can still configure a trust store here to be as strict as possible.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Database
By default, nevisAuth stores sessions and out of context data in memory.

In most setups you should use a database instead, and you should assign a `nevisAuth Database` pattern here.

In memory should be used only when there is only 1 line / pod of nevisAuth,
or in a classic deployment where nevisProxy can ensure session-sticky load balancing towards nevisAuth.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store provider for the HTTPs endpoint.
If no pattern is assigned the Trust Store will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### Client Authentication
Enable to enforce 2-way TLS on the nevisAuth HTTPs endpoint. 

This means that callers (e.g. nevisProxy or technical clients accessing nevisAuth REST APIs) must present a client certificate.

The `Frontend Trust Store` must contain the issuing CA.
--------------------------------------------------------------------------------
Section: ### Default Backend Trust Store
Assign the Trust Store provider for outbound TLS connections.
If no pattern is assigned a trust store will be provided by nevisAdmin 4 automatic key management.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Signer Trust Store
Assign a trust store to validate the signature of the **internal** NEVIS SecToken.

This is an advanced setting and it is usually not required to configure this.

If no pattern, an `Automatic Key Store` pattern, or a `PEM Key Store`, 
is assigned to `Internal SecToken Signer Key Store`, then you **do not** have to configure this. 
The configuration of nevisAuth will be generated correctly, based on the deployment type and scaling.

Configuration is required in **classic VM deployment**, when this instance is deployed to multiple hosts,
**and** the hosts have **different** key material in the `Internal SecToken Signer Key Store`.
--------------------------------------------------------------------------------
Section: ### Line Preference
This setting (together with the inventory) defines the order of nevisAuth endpoints in the connection string from nevisProxy.

nevisAuth stores unauthenticated sessions in memory.
In a classic deployment to VMs, even when a `nevisAuth MariaDB Remote Session Store` is configured, 
sessions are synced to the DB only after successful authentication.
Thus, multi-step login flows require that requests for the same session are routed to the same nevisAuth endpoint.

nevisProxy uses a simple fail-over strategy. The first URL in the connection string for nevisAuth is always used,
unless this instance is not available. This strategy works well when:

* there is only 1 nevisProxy instance
* there are 2 lines of nevisProxy but line 1 is active and line 2 is standby
* there is a session-sticky load-balancer in front of nevisProxy is session-sticky

The order of the connection string depends on the inventory. See also:
[Defining Lines and Fail-over Association](https://docs.nevis.net/nevisadmin4/User-Guide/Infrastructure-Inventories/Working-with-Inventory-Files/Defining-Lines-and-Failover-Association)

This strategy may fail in active / active setups when line groups are defined in the inventory.
In such setups you can set this drop-down to `disabled` to ensure that the order in the connection string is the same on all nevisProxy lines.
--------------------------------------------------------------------------------
Section: ### Type
Select `key store` when a private key is needed.
Select `trust store` for providing trusted certificate (e.g. for signature validation).
--------------------------------------------------------------------------------
Section: ### Trust Store
Reference a trust store provider pattern or leave empty to let nevisAdmin establish a trust store.
This reference property is considered when type `trust store` is selected.

## nevisAuth Log Settings

Configure log levels and retention of nevisAuth logs.

Assign to a `nevisAuth Instance` via `Log Settings`.

In classic VM deployment nevisAdmin 4 does *not* restart the nevisAuth instance
when only log configuration is changed. New log configuration is reloaded within 60 seconds after deployment.
--------------------------------------------------------------------------------
Section: ### HTTPs
Choose between plain HTTP, normal HTTPs and mutual (2-way) HTTPs.
If `enabled` a `Key Store` is required.
If set to `mutual`, a `Trust Store` is required as well.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Used when mutual (2-way) HTTPs is configured.
If no pattern is assigned here automatic key management will provide the trust store.
--------------------------------------------------------------------------------
Section: ### Base Path
Set a custom path for nevisLogrend resources (e.g. CSS).
The path will be made accessible in nevisProxy.

You must change the path when using multiple nevisLogrend instances 
on the same virtual host.
--------------------------------------------------------------------------------
Section: ### Syslog Host
Defines where to send logs to via syslog.

This configuration is used only when syslog forwarding is enabled (see `Log Targets`).

The syslog facility is `localhost3` and the threshold is `INFO`.

## nevisProxy Login Renderer

Set up nevisProxy to use its own, internal renderer instead of nevisLogrend.

Assign the pattern to your realm using `GUI Rendering` / `Login Renderer`.

The nevisProxy Login Renderer is less powerful.
It simply translates GUI descriptors received from nevisAuth into an HTML form,
and puts them in a HTML template.

Upload the HTML templates to the realm pattern using `Login Templates`.

Upload a `<lang>_template.html` for each language that is enabled 
in the `nevisAuth Instance`.

The template files must contain the placeholder `\_NEVIS_AUTH_FORM\_`.

Resources referenced by these HTML template files, for example images, CSS,
should be uploaded on the `Virtual Host` using `Hosted Resources`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the `Microsoft Azure TLS Issuing CA 01` certificate.

You can access the `Host name` with your browser by adding `https://` in front, 
download the CA certificate, and then use a `PEM Trust Store` to provide it. 

## Azure Service Bus Remote Queue

Configures an Azure Service Bus connection-string for Azure Service Bus pattern to use.
--------------------------------------------------------------------------------
Section: ### On Failure
Configure the step to execute after the authentication failed.

If no step is configured here the process ends.

## nevisIDM Administration GUI

The pattern exposes the nevisIDM Administration GUI on a nevisProxy `Virtual Host`.

The Administration GUI is exposed on `/nevisidm/admin`.

You can enable the nevisIDM Self Admin GUI under `Advanced Settings`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store if you want to validate the server certificate used by nevisIDM.
If this not set, the connection is 1-way TLS.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisIDM`
--------------------------------------------------------------------------------
Section: ### Request Validation (ModSecurity)
- `off` - no request validation
- `standard` - uses ModSecurity OWASP Core Rule Set (CRS) with default paranoia level 1 - Basic security
- `custom` - configure `Request Validation Settings` via `Additional Settings`
- `log only` - uses `standard` in log only mode
--------------------------------------------------------------------------------
Section: ### REST API Access
Enables REST API access for the NevisIDM web application. As of 2022 May it is only needed by the Terms & Conditions
functionality. If Terms & Conditions is not used, then this can be disabled safely.

- `enabled` - the REST API will be exposed on the path `/nevisidm/api/*`.
- `disabled` - access to the path `/nevisidm/api/*` will be blocked.

If the REST API is enabled here, then the use of the `nevisIDM REST Service` pattern is not needed.

**WARNING: if the `nevisIDM REST Service` pattern is also used, and has different realms or SecToken patterns assigned, then the
configuration may lead to a requirement clash or a similar issue**
--------------------------------------------------------------------------------
Section: ### On Success
Assign an optional step to execute after successful authentication.

## nevisIDM Connector

Use to connect to an existing nevisIDM instance.

Use the pattern only when the instance is not set up by the project.

Ensure that the SecToken trust store of the instance allows the 
SecToken signers used in this project.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store provider for the HTTPs endpoint.
If no pattern is assigned the Trust Store will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### SecToken Trust Store
Assign a Trust Store provider pattern to use for setting up trust between nevisIDM and nevisAuth. If no pattern is assigned the signer key will be provided by the nevisAdmin 4 PKI.
--------------------------------------------------------------------------------
Section: ### SMTP SSL/TLS Mode
Choose between:

- `disabled` - SSL/TLS is disabled. The `SMTP Trust Store` is not used.
- `STARTTLS` - uses the `STARTTLS` command (see RFC 2487) to switch to SSL/TLS if supported by the SMTP server.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a Trust Store provider pattern to use for setting up trust between nevisIDM and the SMTP server.
--------------------------------------------------------------------------------
Section: ### Trust Store
You should add a CA certificate, and then use a `PEM Trust Store` to provide it. 

## nevisIDM Log Settings

Change log configuration for nevisIDM.
--------------------------------------------------------------------------------
Section: ### Show Policy Violations
If set to `enabled` then after failed credential creation displays violated policies.

## nevisIDM Password Login

Login to nevisIDM with username and password.

The step is intended to be used as a first factor 
in the `Initial Authentication Flow` of an `Authentication Realm`.

To support login using email, store the email in the `Login ID` field of the user.

Authentication is based on the default password policy of the selected client.
See the nevisIDM Technical Documentation on how to adapt the policy.

On successful authentication, the `UserId` of the session 
is set to the `Ext ID` of the nevisIDM user.

For `Web Application`, an initial redirect (to `?login`) is performed and a login GUI is shown.
Technical clients calling a `REST Service` or `SOAP Service` may use basic authentication and send the credential upfront.

Double-check the URL you are calling as nevisProxy also responds with a redirect 
if no servlet can be found otherwise (`trailingSlashRedirect`).

The step also supports enforced password change, for expired passwords,
and provides password reset, for users who forgot their password.
--------------------------------------------------------------------------------
Section: ### Entry Path
The path prefix of the links for the password forgotten process.

Example: given a domain `www.adnovum.ch` and the value `/pwreset/`, all password forgotten steps will
use the base path `www.adnovum.ch/pwreset/`.
--------------------------------------------------------------------------------
Section: ### Email Sent Redirect
Where to redirect to once the password reset ticket has been generated.

- `root`: to the domain root (`/`) on this `Virtual Host`
- `referrer`: to the initial URL requested by the client
- `custom`: to a custom path or URL as configured by `Custom Email Sent Redirect`

Note that the `referrer` will always be a page requiring authentication, hence
it will basically redirect to the login page.
--------------------------------------------------------------------------------
Section: ### Skip List
Comma-separated list of versioned tables (which are used to provide history data) to be ignored by the prune history job and left with their original content.

Possible values (Any combination of the following):

* `tidma_application_v`
* `tidma_authorization_appl_v`
* `tidma_authorization_client_v`
* `tidma_authorization_erole_v`
* `tidma_authorization_unit_v`
* `tidma_authorization_v`
* `tidma_cert_info_v`
* `tidma_client_application_v`
* `tidma_client_v`
* `tidma_consent_v`
* `tidma_cred_login_info_v`
* `tidma_credential_v`
* `tidma_dict_entry_v`
* `tidma_dict_entry_value_v`
* `tidma_enterprise_auth_v`
* `tidma_enterprise_role_v`
* `tidma_erole_member_v`
* `tidma_fido2_v`
* `tidma_fido_uaf_v`
* `tidma_mobile_signature_v`
* `tidma_oath_v`
* `tidma_personal_answer_v`
* `tidma_personal_question_v`
* `tidma_policy_configuration_v`
* `tidma_policy_parameter_v`
* `tidma_profile_v`
* `tidma_property_allowed_val_v`
* `tidma_property_v`
* `tidma_property_value_v`
* `tidma_role_v`
* `tidma_saml_federation_v`
* `tidma_template_collection_v`
* `tidma_template_text_v`
* `tidma_template_v`
* `tidma_terms_application_v`
* `tidma_terms_url_v`
* `tidma_terms_v`
* `tidma_unit_cred_policy_v`
* `tidma_unit_v`
* `tidma_user_login_info_v`
* `tidma_user_v`

For further information about historical tables visit [Versioned DB tables
](https://docs.nevis.net/nevisidm/Configuration/Data-Model/Database-tables-and-the-nevisIDM-data-model/Versioned-DB-tables).

## nevisIDM REST Service

Set up access to nevisIDM REST service on a nevisProxy `Virtual Host`.

The nevisIDM REST Service is exposed as: `/nevisidm/api`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store if you want to validate the server certificate used by nevisIDM.
If this not set, the connection is 1-way TLS.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisIDM`
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign add-on patterns to customize the behaviour of this service.

Example use cases:

- `Authorization Policy` to enforce roles or an authentication level.
- `URL Handling` to redirect or forward requests.
- `HTTP Header Customization` to add, replace, or remove HTTP headers in requests or responses.


## nevisIDM SOAP Service

Using the pattern, you can set up access to the nevisIDM SOAP APIs 
on a nevisProxy `Virtual Host`.

The nevisIDM SOAP APIs are exposed on `/nevisidm/services`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store if you want to validate the server certificate used by nevisIDM.
If this not set, the connection is 1-way TLS.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname of `nevisIDM`
--------------------------------------------------------------------------------
Section: ### On Success
Configure the step to execute after the user has accepted all terms and conditions.

If no step is configured here the process ends and the user will be authenticated.

## nevisIDM URL Ticket Consume

Provides an endpoint on a `Virtual Host` to consume URL tickets.
The request has to contain a query parameter `x` containing the ticket code.

Before the ticket is validated a Gui is shown. The Gui has an info text
with label `info.url_ticket.welcome` and a continue button.

This Gui prevents that clients consume the ticket by calling the URL (e.g. to render a preview),
before the user even has a chance to click the link.

When the ticket is valid, the step assigned to `On Success` will be executed.

Note that when a `URL Ticket` credential is created for a nevisIDM user,
the associated `URLTicket` policy defines how the link is generated and communicated.

With `sendingMethod=Email` the user will receive an email.

Your support team can create URL tickets using the nevisIDM Admin GUI.
This requires that the policy sets `urlPrefix` so that the link can be generated.

URL tickets are often generated during an authentication flow.
As of Aug 2022 there is no high-level step to create URL tickets,
use `Generic Authentication Step` instead.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
Enter frontend path(s) which should be handled.
--------------------------------------------------------------------------------
Section: ### On Success
Assign an authentication step which shall be executed when the URL ticket is valid.

Note: this pattern does not provide any content on the exposed `Frontend Path(s)` and does not ensure
that the caller is redirected when the authentication flow terminates. 

Thus, please take appropriate measures at the end of the flow to avoid a `404` error.
For instance, you may trigger a redirect at the end of your flow, or
assign an `URL Handler` to `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the allowed HTTP methods. 

If not configured, all HTTP methods are allowed.
--------------------------------------------------------------------------------
Section: ### nevisadmin-plugin-nevisproxy.md
---
sidebar_position: 20
---
# nevisadmin-plugin-nevisproxy

## Access Restriction

Sets up a filter in nevisProxy to block or filter incoming
requests based on the source IP of the request.

The pattern can be assigned to applications 
or an entire `Virtual Host` using `Additional Settings`.

Blocked requests are responded to with HTTP error code `403`.

To produce a nice looking error page, ensure that 
you have configured an error page for 403 on the `Virtual Host` 
or use the `HTTP Error Handling` pattern on the same location.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Allow Override
By default, access restriction rules apply to all sub-locations.

For instance, when you assign an `Access Restriction` pattern to a `Virtual Host` 
all applications on this virtual host will be affected. 

To **replace** the rules defined on a parent location 
select `enabled` on all `Access Restriction` patterns in the hierarchy.

If `disabled` is selected anywhere in the hierarchy the rules are 
considered **additional**.

Technical Details:

This feature is implemented using a nevisProxy `LuaFilter`.
Mapped filters are inherited to sub-locations unless an `exclude-url-regex` is defined.

By selecting `enabled` the generator is informed that the mapped filter has the purpose
`access restriction`. The generator then ensures that an `exclude-url-regex` entry
 is generated when a filter with the same purpose is mapped to a sub-location.

## Automatic Key Store

Sets up a key store managed by nevisAdmin 4.

In classic deployment the private key is generated during deployment
by running a command on the target host.

nevisAdmin then downloads the CSR and issues a certificate,
which is deployed to the target host.

In Kubernetes deployment a custom resource definition (CRD) is generated 
and sent to the Nevis Operator running in the cluster.

Set the inventory variable `__nevisadmin_pki_automatic_allowed_mode` to restrict the allowed modes:

- `any` (default) - assignment of key management patterns is optional.
- `explicit` - assign patterns where-ever a key store or trust store is required.

This example illustrates how the key store looks on the target system:

```
[root@nevis /]# ls -l /var/opt/keys/own/<name>/
total 40
-rw-r----- 1 root nvbgroup 1103 Dec  1 07:05 ca-chain.pem
-rw-r----- 1 root nvbgroup 1013 Dec  1 07:05 cert.pem
-rw-r----- 1 root nvbgroup  887 Dec  1 07:05 csr.pem
-rwxr-x--- 1 root nvbgroup   40 Dec  1 07:05 keypass
-rw-r----- 1 root nvbgroup 1675 Dec  1 07:05 key_pkcs1.pem
-rw-r----- 1 root nvbgroup 1704 Dec  1 07:05 key.pem
-rw-r----- 1 root nvbgroup  451 Dec  1 07:05 key_pub.pem
-rw-r----- 1 root nvbgroup 2053 Dec  1 07:05 keystore.jks
-rw-r----- 1 root nvbgroup 2309 Dec  1 07:05 keystore.p12
-rw-r----- 1 root nvbgroup 2688 Dec  1 07:05 keystore.pem
```
--------------------------------------------------------------------------------
Section: ### Owner(s)
Select an instance pattern which defines the target hosts of this `Automatic Key Store`.
This setting is required only when this pattern is assigned to an `Automatic Trust Store`.

## Automatic Trust Store

Sets up a trust store managed by nevisAdmin 4.

In classic deployment the certificates of trusted key stores
are deployed to the target host.

In Kubernetes deployment a custom resource definition (CRD) is generated instead and sent to the Nevis Operator running in the cluster.

Set the inventory variable `__nevisadmin_pki_automatic_allowed_mode` to restrict the allowed modes:

- `any` (default) - assignment of key management patterns is optional.
- `explicit` - assign patterns where-ever a key store or trust store is required.

This example illustrates how the trust store looks on the target system:

```
[root@nevis /]# ls -l /var/opt/keys/trust/<name>/
total 16
-rwxr-x--- 1 root nvbgroup   16 Dec  1 07:05 keypass
-rw-r----- 1 root nvbgroup 1656 Dec  1 07:05 truststore.jks
-rw-r----- 1 root nvbgroup 2042 Dec  1 07:05 truststore.p12
-rw-r----- 1 root nvbgroup 2116 Dec  1 07:05 truststore.pem
```
--------------------------------------------------------------------------------
Section: ### Additional Trusted Certificates
Upload additional trusted certificates in PEM format.

The content of all files will be concatenated and added to the `truststore.*` files generated by this pattern.

You can make this a variable and upload the files in the inventory using the `Attach files` function.

## CSRF Protection Settings

Customize CSRF protection for an application, for example, `Web Application`.

You can assign the pattern to `Virtual Host` patterns as well,
to configure CSRF protection for all applications on this host.
--------------------------------------------------------------------------------
Section: ### Header-based Check
CSRF protection can be obstructive for some cross-domain use cases 
(e.g. federation or providing a public REST API).
--------------------------------------------------------------------------------
Section: ### Allowed Domains
CSRF protection can be obstructive for cross-domain use cases 
(e.g. federation or providing a public REST API).

Enter domains which should be excluded from `header-based` CSRF protection. 
There is no support for wildcards, pre- or postfix notations (sub-domains must be listed individually).

Example: 
```
www.adnovum.ch 
adnovum.ch
```

## Cookie Customization

Configure whether cookies are to be returned to the caller or stored in the user session.

You may also assign the pattern to multiple applications, and set `Shared Protected Cookies`
to share cookies between applications. 

Note that cookie sharing is supported only for applications 
using the same session in nevisProxy, that is, 
applications protected by the same authentication realm.

The default cookie handling differs based on the type of application:
 
| Type | Behaviour | 
|---|---|---| 
| Web Application (with authentication) | Cookies are stored. |
| Web Application (public) | Cookies are allowed to passthrough. |
| REST API | Cookies are dropped. |
| SOAP Service | Cookies are dropped. |
--------------------------------------------------------------------------------
Section: ### Cookie Conflict Resolution
When multiple `Cookie Customization` patterns are used it happen that 
a certain cookie is defined as both a `Client Cookie` and as a `Shared Protected Cookie` 
for the same application.

By default, this conflict is resolved by allowing the cookie to `pass-through`, treating it as a `Client Cookie`.

This behaviour is usually more robust but less secure as the cookie will be accessible in the browser.

Select `protect` to threat the cookie as a `Shared Protected Cookie` instead.

## Default Service

Makes the configured `Frontend Path(s)` accessible 
on the assigned `Virtual Host(s)` by mapping a `DefaultServlet`.

You can decorate the paths by assigning `Additional Settings`, for example, 
to provide custom services using nevisProxy filters.

Note that if your request passes through the entire filter chain without 
being responded or redirected an error code 404 is returned.

The pattern is only to be used when there is no pattern for your use case. 
Whenever possible, use the following patterns instead:

- `Web Application`, `REST Service`, `SOAP Service`: to make a backend application accessible
- `Standalone Authentication Flow`: to provide an entry point for flows implemented in nevisAuth
- `Hosting Service`: to host static resources
--------------------------------------------------------------------------------
Section: ### Virtual Host(s)
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
The path(s) which shall be accessible on the assigned `Virtual Host(s)`.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign add-on patterns to customize the behaviour of this service.

Example use cases:

- `Authorization Policy` to enforce roles or an authentication level.
- `URL Handling` to redirect or forward requests.
- `HTTP Header Customization` to add, replace, or remove HTTP headers in requests or responses.


## Generic Application Settings

Customize the `web.xml` configuration for an application
using XML constructs as described in the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy). 

Use as add-on for `Web Application`, `SOAP Service`, or `REST Service`.

The following expressions may be used for all applications:

- `${name}`: sanitized name of the pattern
- `${service.name}`: the name of the application
- `${service.id}`: the unique ID of the application
- `${host.key}`: use as `EntryPointID` when adding a custom `IdentityCreationFilter` (advanced use case)

For applications with only 1 `Frontend Path`:

- `${service.path}`: the frontend path of the application, excluding trailing slash `/` and asterisk `*`
- `${service.mapping}`: the `url-pattern` calculated for the frontend path of the application 

In case an `Authentication Realm` is assigned:

- `${realm.name}`: name of the realm (use for `StateKey` / `DelegateSource`)
- `${auth.connector}`: name of the `Esauth4ConnectorServlet` (use for `AuthenticationServlet`)
- `${logrend.renderer}`: name of the `LoginRendererServlet`
- `${logrend.connector}`: name of the `Http(s)ConnectorServlet` for nevisLogrend (if nevisLogrend is used)

When defining filters it is recommended to set `Filter Mappings` to `automatic`.
This way the filters are mapped to all frontend paths of the application.
--------------------------------------------------------------------------------
Section: ### Filters and Mappings
Configure filters and their mappings using the XML syntax described in the nevisProxy Technical Documentation. 

Filters that have the same name as other filters (even those defined by other patterns) 
will be combined: the `init-param` sets will be merged where possible.
Direct contradictions are interpreted as validation failures.

**Example 1**: Create (or patch) a filter with a fixed name

```xml
<filter>
   <filter-name>SomeName</filter-name>
   <filter-class>ch::nevis::isiweb4::filter::SomeClass</filter-class>
   <init-param>
      <param-name>...</param-name>
      <param-value>...</param-value>
   </init-param>
</filter>
```

**Example 2**: Create (or patch) a filter using an application-specific name

```xml
<filter>
   <filter-name>SomeName_${service.name}</filter-name>
   <filter-class>ch::nevis::isiweb4::filter::SomeClass</filter-class>
   ...
</filter>
```

**Example 3**: Map a filter to a sub-path of the assigned application(s).
This example works for applications which have 1 frontend path only.

```xml
<filter-mapping>
   <filter-name>SomeFilter</filter-name>
   <url-pattern>${service.path}/custom/*</url-pattern>
</filter-mapping>
```

**Example 4**: Use multi-value expressions

Multi-value expressions replicate an entire line for each associated value.

Use the expressions `*{service.path}` and `*{service.mapping}` to generate filters 
which must contain the frontend paths of all assigned applications.

The following snippet is not complete but should illustrate the concept:

```xml
<filter>
    <filter-name>FormSigning</filter-name> 
    <filter-class>ch::nevis::isiweb4::filter::validation::EncryptionFilter</filter-class>
    <init-param>
        <param-name>EntryURL</param-name>
        <param-value>
            *{service.path}/
        </param-value>
    </init-param>
    ...
</filter>
```
--------------------------------------------------------------------------------
Section: ### Filter Mappings
Choose between:

- `manual` (default): only the `filter-mapping` elements which have been configured via `Filters and Mappings` will be added.
- `automatic`: filters configured via `Filters and Mappings` will be mapped to all `Frontend Paths` of the application.
- `both`: like `automatic` but additional `filter-mapping` elements are allowed as well.
--------------------------------------------------------------------------------
Section: ### Remove Filter Mappings
Remove `<filter-mapping>` elements generated by other patterns.

The syntax is a map of `<filter-name>:<url-pattern>`, according to elements from the `web.xml`.

In the `<filter-name>` the expressions `${service.name}` and `${realm.name}` may be used.

For applications which have only 1 frontend path you may use `${service.mapping}` instead of `<url-pattern>`.

Examples:

```
ModSecurity_${service.name}:${service.mapping}
Authentication_${realm.name}:${service.mapping}
```

## Generic QoS Configuration (mod_qos)

Assign the pattern to a `Virtual Host` using `Additional Settings`.

Use to configure `mod_qos` in case the `standard` configuration is not sufficient.

`mod_qos` is quite powerful, and can cover may use cases. 
See [mod_qos documentation](http://mod-qos.sourceforge.net/) for further information.

The pattern is experimental and may change in future releases. 
The `mod_qos` directives are not validated.

The directives are applied using an `ApacheConfigFilter` (named `Qos`),
which is added to the `web.xml` of the `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Server Directives (Experimental)
Server level directives can be entered here.

These directives apply to the entire `nevisProxy Instance` 
which means that other `Virtual Host` patterns may be affected.

Examples:

```
QS_ClientEventBlockCount 200 300
QS_SetEnvIf NAVAJO_HTTPSESS_CREATED !QSNOT QS_Block=yes
QS_SrvMaxConnClose 85%
QS_SrvMaxConnPerIP 75
QS_SrvMinDataRate 75 300 250
```
--------------------------------------------------------------------------------
Section: ### Host Directives
Host level directives can be entered here.

## Generic Virtual Host Settings

Customize the `web.xml` configuration
using XML constructs as described in the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy). 

Use as add-on for the `Virtual Host` pattern. 
The following expressions are supported:

- `${name}`: sanitized name of the pattern
- `${service.name}`: the name of the virtual host
- `${service.id}`: the unique ID of the virtual host
- `${service.path}`: the base path of the virtual host (empty String) 
- `${service.mapping}`: the `url-pattern` for the virtual host `/*`
--------------------------------------------------------------------------------
Section: ### Filters and Mappings
Configure filters and their mappings using the XML syntax described in the nevisProxy Technical Documentation. 

Filters that have the same name as other filters (even those defined by other patterns) 
will be combined: the `init-param` sets will be merged where possible.
Direct contradictions are interpreted as validation failures.

**Example 1**: Create (or patch) a filter with a fixed name

```xml
<filter>
   <filter-name>SomeName</filter-name>
   <filter-class>ch::nevis::isiweb4::filter::SomeClass</filter-class>
   <init-param>
      <param-name>...</param-name>
      <param-value>...</param-value>
   </init-param>
</filter>
```

**Example 2**: Create (or patch) a filter using an application-specific name

```xml
<filter>
   <filter-name>SomeName_${service.name}</filter-name>
   <filter-class>ch::nevis::isiweb4::filter::SomeClass</filter-class>
   ...
</filter>
```

**Example 3**: Map a filter to a sub-path of the assigned application(s).
This example works for applications which have 1 frontend path only.

```xml
<filter-mapping>
   <filter-name>SomeFilter</filter-name>
   <url-pattern>${service.path}/custom/*</url-pattern>
</filter-mapping>
```

**Example 4**: Use multi-value expressions

Multi-value expressions replicate an entire line for each associated value.

Use the expressions `*{service.path}` and `*{service.mapping}` to generate filters 
which must contain the frontend paths of all assigned applications.

The following snippet is not complete but should illustrate the concept:

```xml
<filter>
    <filter-name>FormSigning</filter-name> 
    <filter-class>ch::nevis::isiweb4::filter::validation::EncryptionFilter</filter-class>
    <init-param>
        <param-name>EntryURL</param-name>
        <param-value>
            *{service.path}/
        </param-value>
    </init-param>
    ...
</filter>
```
--------------------------------------------------------------------------------
Section: ### Servlets and Mappings
Configure `servlet` and/or `servlet-mapping` elements
using the XML constructs described in the nevisProxy Technical Documentation.

You can also customize elements which have been generated by other patterns.
Elements can be referenced as follows:

- `servlet`: `servlet-name`
- `servlet-mapping`: `url-pattern`

In Kubernetes side-by-side deployment a postfix is added to service names. 
Use the expression `${service.postfix}` connecting to a service deployed against the same inventory.

Example 1: Add or overwrite an `init-param` for an existing `servlet`:

```xml
<servlet>
  <servlet-name>Hosting_Default</servlet-name>
  <init-param>
    <param-name>NoMatchFile</param-name>
    <param-value>/index.html</param-value>
  </init-param>
</servlet>
```

Example 2: Remove a `servlet-mapping`:

```xml
<servlet-mapping>
    <url-pattern>/app/*</url-pattern>
</servlet-mapping>
```

Here we left out the `servlet-name` to tell the pattern to remove the `servlet-mapping` for the given `url-pattern`.

Note that the mapping of the hosted resources is an exception and cannot be removed this way 
(see the property `Hosted resources` of the Virtual Host pattern for more information).

Removing a `servlet` element is not supported.
--------------------------------------------------------------------------------
Section: ### Mime-Mappings
Set or replace `mime-mapping` elements.

Examples:

```
<mime-mapping>
    <extension>svg</extension>
    <mime-type>image/svg+xml</mime-type>
</mime-mapping>
```

The `mime-mapping` elements affect the entire `Virtual Host`
and are used use to determine the `Content-Type` for responses.

nevisProxy always sets a `Content-Type` header 
for static resources served by the `Virtual Host`.

Further, nevisProxy can add a `Content-Type` header for resources served by applications.
To enable this advanced feature assign `Generic Application Settings` to the application
and set the parameter `ProxyPolicy` to `mime-completion`.

## Generic nevisProxy Instance Settings

You can assign the pattern to a `nevisProxy Instance` using `Additional Settings`.
 
Use to customize the main configuration files of the nevisProxy instance, including:

- `navajo.xml`
- `bc.properties`

To configure logging, use `nevisProxy Log Settings` instead.
--------------------------------------------------------------------------------
Section: ### Configuration: navajo.xml
Customize the Navajo servlet container configuration (`navajo.xml`)
using XML constructs described in the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy).

The root element `<Service>` must be provided.

Examples:

Increase number of parallel requests (worker threads):

```xml
<Service>
    <Server MaxClients="1000"/>
</Service>
```

Increase the maximum allowed request body size:

```xml
<Service>
    <Server LimitRequestBody="10485760"/>
</Service>
```

Set a `Context` attribute for `some.domain.com`:

```xml
<Service>
    <Engine>
        <Host name="some.domain.com">
            <Context additionalStatusCodes="207,210,242,422,423,424,449,456,540,541,543,544,545,456,549,552,560" />
        </Host>
    </Engine>
</Service>
```

Overrule the allowed HTTP methods for `some.domain.com`:

```xml
<Service>
    <Engine>
        <Host name="some.domain.com">
            <Context allowedMethods="ALL-HTTP" />
        </Host>
    </Engine>
</Service>
```

Overrule the server aliases for `some.domain.com`:

```xml
<Service>
    <Connector name="some.domain.com" port="*" serverAlias="*.domain.com">
    </Connector>
</Service>
```

It is possible to use the following placeholders:

- `${instance.id}`: unique ID of the `nevisProxy Instance` pattern
- `${instance.name}`: name of the nevisProxy instance. For instance, use `/var/opt/nevisproxy/${instance.name}` to refer to the instance directory.

Limitations:

- customizing `Navajo` elements is not supported
- customizing `Host` (or its child elements) requires `name`
--------------------------------------------------------------------------------
Section: ### Configuration: bc.properties
Customize the low-level configuration (`bc.properties`)
using properties described in the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy).

For instance, when request validation is enabled this requires a buffer
and this buffer has to be big enough to store the entire request.

The following example increases the maximum size of the request buffer to 10 MB:

```
ch.nevis.navajo.request.BufferSize=10485760
```

You also may have to increase the maximum allowed request size. 
See `Configuration: navajo.xml` for an example.

Note that increased buffer sizes may lead to increased demand of RAM and disk space. 

When the required buffer exceeds `ch.nevis.navajo.request.MemBufferSize` 
then nevisProxy will buffer to disk instead.

The demand caused by request buffers can be estimated as follows:

- RAM: `MaxClients` * `ch.nevis.navajo.request.MemBufferSize` 
- disk: `MaxClients` * `ch.nevis.navajo.request.BufferSize` 

See `Configuration: navajo.xml` for a description of `MaxClients`.
--------------------------------------------------------------------------------
Section: ### Template Parameters
Define _Template Parameters_.

Examples:

```yaml
backend-host: backend.siven.ch
```

These parameters can be used in:

* `Configuration: navajo.xml`
* `Configuration: bc.properties`

The expression formats are:

`${param.<name>}`:

- `name` found: parameter value is used.
- `name` missing: expression is **not** replaced.

`${param.<name>:<default value>}`:

- `name` found: parameter value is used.
- `name` missing: default value will be used.

In `<default value>` the character `}` must be escaped as `\}`.

## HTTP Error Handling

Use the pattern to handle HTTP error codes.

You can use the pattern as an add-on for `Virtual Host`
or any backend application, for example, `Web Application`, `REST Service`, or `SOAP Service`.
--------------------------------------------------------------------------------
Section: ### Error Pages
Upload HTML error pages, JSON error pages and associated resources here.

Pages must be named like the error code they are used for (e.g. `500.html`).
You can use the same page for multiple status code (e.g. `401,403,500-599.html`).

By default, the error pages are deployed to `/errorpages/<name>` but
you can set a different location via the property `Base Path` (see `Advanced Settings`).

In your error pages we recommend to use relative links to include resources.
You may also include resources deployed on the virtual host via `Hosted Resources`.

The following placeholders are supported:

- `TRANSFER_ID` for the unique ID of the request (e.g. `c0a80e52-5d04-11ac0500-16906714eee-00000003`)
- `TIMESTAMP` to show a timestamp (e.g. `Tue, 19 Feb 2019 15:48:02 GMT`)
--------------------------------------------------------------------------------
Section: ### Mode
Enable or disable the error handling.

When set to `disabled`, all settings except `Apply only to sub-paths` are ignored.
Use this setting in combination with `Apply only to sub-paths` to disable the error handling for some sub-paths only.

Usage examples (valid for `Virtual Host`s and backend applications):
- Disable the error handling: 
use an `Error Handler` pattern with `Mode` set to `disabled` and link it to the target pattern via `Additional Settings`;
- Disable the error handling for some sub-paths:
use an `Error Handler` pattern with `Mode` set to `disabled` and `Apply only to sub-paths` set to the paths where no error handling should occur, and link it to the target pattern via `Additional Settings`;
- Define a customised error handling and disable it for some sub-paths: 
use two `Error Handler` patterns, one with the custom settings, and one with `Mode` set to `disabled` and `Apply only to sub-paths` set to the paths where no error handling should occur. Link both of them to the target pattern via `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply the error handling on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Base Path
By default, the error pages are deployed to `/errorpages/<name>` but you can set a different location here.
--------------------------------------------------------------------------------
Section: ### Keep Security Headers
Configure the name of special response headers which should be kept,
regardless of the header action of the matching rule.
Useful for keeping the security response headers for the error pages.

Default:

```
Strict-Transport-Security
X-Content-Type-Options
Referrer-Policy
```


## HTTP Header Customization

Use to add, overwrite, or remove HTTP headers in requests or responses.

You can use the pattern as add-on for `Virtual Host` or applications, 
for example, `Web Application`, `REST Service`, or `SOAP Service`.

The following expressions may be used:

- `${client.ip}` - IP address of the caller
- `${request.id}` - unique ID of this request
- `${request.header.<name>}` - value of a request header (only for requests)
- `${env.<name>}` - Apache `ENV` variables
- `${auth.<name>}` - access to the `AUTH` scope (only for requests, requires an `Authentication Realm` and the `Filter Phase` is to be set to `AFTER_AUTHENTICATION` or `END`)
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply the header customization on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table illustrates the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |


## Hosting Service

Use the pattern to host static pages and related resources.

For instance, you can use this pattern to host HTML or a single-page application (SPA).

Further, you can provide CSS, images, and Javascript for error pages uploaded by a `HTTP Error Handling` pattern.

The pattern generates configuration for the nevisProxy [ch::nevis::nevisproxy::servlet::file::FileReaderServlet](https://docs.nevis.net/nevisproxy/Configuration/Servlets/FileReaderServlet).
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Frontend Path
The path at which the resources shall be accessible at the frontend.
You may use `/` to deploy root content.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply the ICAP scanning on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |

## JWT Access Restriction

Sets up a filter in nevisProxy to verify the JWT of incoming requests.

A request will be allowed to pass through if it contains a valid JWT, in
every other case (e.g. failed to verify, expired or token not present), the
request will be blocked. Blocked requests are responded to with HTTP error code `403`

The pattern can be assigned to applications 
or an entire `Virtual Host` using `Additional Settings`.
.
--------------------------------------------------------------------------------
Section: ### Lua Script
Upload a Lua script which should be invoked for requests and / or responses.
The script has to contain one or multiple of the following Lua functions:

- `function inputHeader(request, response)` - called once per request
- `function input(request, response, chunk)` - called once per request body _chunk_
- `function outputHeader(request, response)` - called once per response
- `function output(request, response, chunk)` - called once per response body _chunk_

The uploaded script will be deployed to the nevisProxy host in sub-directory `WEB-INF` using
the name of this pattern for the file name to ensure that the file name is unique.

Here is an example Lua script which replaces sensitive information in response bodies:

```
local buf = {}
function output(request, response, chunk)
  if chunk ~= nil then
    table.insert(buf, chunk)
    return nil
  else
    return string.gsub(table.concat(buf), "some-sensitive-data", "*****");
  end
end  
```

The following expressions can be used anywhere within the script:

- `${name}` - sanitized name of this pattern
- `${host}` - name of the `Virtual Host` directory
- `${instance}` - name of the `nevisProxy Instance` directory
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |

## Maintenance Page

Shows a static maintenance page
if the current date and time is within a certain interval.

Technical note: nevisProxy uses system calls to determine the current time in UTC. 
To check if UTC time is correct, run `date -u` on the nevisProxy host.

You can assign the pattern using `Additional Settings` to applications,
or an entire `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Base Path
Enter the base path under which the maintenance page will be hosted.

You usually don't have to change this configuration, unless the path clashes with any other hosted resources.

By default, `/maintenance/` is used.


## NGINX Ingress Settings

Assign this pattern to a `nevisProxy Instance` using `Additional Settings`. 

Use in Kubernetes deployments to add annotations for the NGINX Ingress 
which runs in front of nevisProxy and terminates incoming connections.
--------------------------------------------------------------------------------
Section: ### TLS Secrets
Use your own Kubernetes secrets to provide the frontend key store for a `Virtual Host`.

Syntax is a map of (primary) frontend address of the host to secret name.

```properties
www.siven.ch: customsecretname
```

Secrets must be of `type: kubernetes.io/tls`. Secrets must be prepared before deployment.
They must contain a private key (`tls.key`), a matching certificate (`tls.crt`) and should contain the CA chain (`ca.crt`).

If not set the Nevis operator request certificates from the cluster issuer
and generates a secret for each `Virtual Host` to store the required key material.
--------------------------------------------------------------------------------
Section: ### Custom Root Directory Name
Set to deploy the key store underneath a _base_ directory.
The key store will be established at:

`/var/opt/keys/own/<base>/<name>`

This configuration may be used to prevent key stores overwriting each other 
and is only required in complex setups with multiple projects or inventories.

## PEM Trust Store

Set up a trust store.

The trust store is deployed to `/var/opt/keys/trust/<name>`.

The trust store will contain the following files:

- `truststore.pem`
- `truststore.jks` - JKS format
- `truststore.p12` - PKCS12 format
- `keypass` - used by Java-based components to retrieve the password to access the JKS or PKCS12 files

All `truststore.*` files contain the same certificates.

The JKS and PKCS12 files are created during the first generation,
and then stored in a cache backed by the nevisAdmin 4 database.
--------------------------------------------------------------------------------
Section: ### Trusted Certificates
Upload trusted certificate(s) in PEM format.

If you set a _variable_, the variable should be a list of secret file references in the inventory.
Example:

```
  my-variable: 
    - inv-res-secret://147cc54a5629fadac761ec01#some-cert.pem
    - inv-res-secret://147cc54a5629fadac761ec01#some-other-cert.pem
```

Upload files for this variable by clicking `Attach files`
in the drop-down on the inventory screen.

If you are deploying to Kubernetes you may store the trust store content in a Kubernetes secret.
You can pick any name for the Kubernetes secret but the keys must be as in the following example:

```
  my-variable: 
    - k8s-secret-file://dummy-truststore:truststore.pem/
    - k8s-secret-file://dummy-truststore:truststore.jks/
    - k8s-secret-file://dummy-truststore:truststore.p12/
    - k8s-secret-file://dummy-truststore:keypass/
```

Note that nevisAdmin 4 does not notice when the content of the Kubernetes secret changes.
Manual interaction (terminating pods) is required in that case.
--------------------------------------------------------------------------------
Section: ### Custom Directory Name
Enter a name for the trust store directory 
which is used instead of the pattern name.

This configuration may be used to prevent trust stores overwriting each other 
and is only required in complex setups with multiple projects or inventories.
--------------------------------------------------------------------------------
Section: ### Custom Root Directory Name
Set to deploy the trust store underneath a _base_ directory.
The trust store will be established at:

`/var/opt/keys/trust/<base>/<name>`

This configuration may be used to prevent trust stores overwriting each other 
and is only required in complex setups with multiple projects or inventories.

## REST Service

Set up access to a backend application providing a REST API.
--------------------------------------------------------------------------------
Section: ### Virtual Hosts
Assign `Virtual Host` patterns which shall serve as entry point for this application.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
The (base) path of the application.

Examples:

- `/app/` - defines a base path. 
Any requests which have a path component starting with `/app/` will be sent to this application.
- `/` - forward all requests to this application. 
Use this only when there are no other applications or hosted resources.
- `exact:/app.html` - matches requests to `/app.html` only (query parameters are allowed). 
Use this for single-page applications which don't require any additional resources.

Note that if the frontend path is different from the path used within `Backend Addresses` 
then URL rewriting will be configured to correctly route
requests and responses between clients and backends.
--------------------------------------------------------------------------------
Section: ### Backend Addresses
Enter the complete URLs (scheme, host, port and path) of the backend services. 

Note: 

- all URLs must use the same scheme and path.
- automatic path rewriting will be performed when the path differs from the `Frontend Path`.

In case you are setting multiple addresses, use `Load Balancing` to select a request dispatching strategy.
--------------------------------------------------------------------------------
Section: ### Load Balancing
Select a request dispatching strategy when several `Backend Addresses` are configured.

- `disabled` - all requests will be sent to the first address. If this address is not available the next address is chosen;
- `round-robin` - one of the addresses will be picked up for each request using a round-robin rotation;
- `session-sticky` - one of the addresses will be picked up for each new session using a round-robin rotation, then subsequent requests for the session will be sent to the same address.


Failover strategy:

* When the selected backend cannot be accessed, nevisProxy will attempt to use another one.
* Once the said backend can be accessed again, it can be picked up for new requests if the load balancing is `round-robin`, or for new sessions if the load balancing is `disabled` or `session-sticky`. 
The requests linked to an existing session will still go to the current backend until the end of the session if the load balancing is `disabled` or `session-sticky`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Optional setting for enabling trust to HTTPS backends.

For securing production environments:

- set `Backend Addresses` starting with `https://`
- assign a `Trust Store` pattern containing the certificates required for verifying the backend certificate
- set `Hostname Validation` to `enabled`
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname configured in `Backend Addresses`
--------------------------------------------------------------------------------
Section: ### Host Header
Defines the `Host` header for requests forwarded to the application.

When `backend` is selected then nevisProxy uses the host part of the backend address that has been selected.
This is the default behaviour and similar to what a browser would do.
Therefore, this configuration should work in most cases.

When `client` is selected then nevisProxy will keep the `Host` header as received from the client.
The following `init-param` will be generated:
              
```
<init-param>
  <param-name>HostName</param-name>
  <param-value>ENV:HTTP_Host;</param-value>
</init-param>
```

The configuration is dynamic to support virtual hosts with multiple frontend addresses.
Note that this may be less secure. 
Even though browsers do not allow this clients may sent an arbitrary value for the `Host` header.
It is therefore recommended to test how your application behaves in this case.
--------------------------------------------------------------------------------
Section: ### Response Rewriting
Use this feature to replace backend hostnames in responses
or set to `custom` to configure complex rewriting use cases.

- `off` disables automatic response rewriting
- `header` enables auto rewrite for response headers (including Set-Cookie header)
- `complete` enables auto rewrite for the entire response (including body)
- `custom` configure `Response Rewriting Settings` via `Additional Settings`
--------------------------------------------------------------------------------
Section: ### CSRF Protection
_Cross-Site Request Forgery_ (_CSRF_) is an attack that forces an authenticated user to send unwanted requests.

- `off (default)` - no CSRF protection. Recommended for APIs which may be called from other sites.
- `header-based` - `GET` and `HEAD` requests are allowed. 
For other requests `Referer` and `Origin` headers must match the `Host` header.
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the HTTP methods allowed for this application. 

Methods which are listed here must also be allowed on the `Virtual Host`.

You may also use the following method groups:

* `ALL-HTTP` includes common HTTP methods.

  These are: `GET, POST, HEAD, DELETE, TRACE, CONNECT, OPTIONS, PUT, PATCH`

* `ALL-WEBDAV` includes all methods required for WebDAV.
  
  These are: `MERGE, UNCHECKOUT, MKACTIVITY, PROPPATCH, LOCK, CHECKOUT, SEARCH, COPY, MKCOL, MKWORKSPACE, PROPFIND, UPDATE, REBIND, BASELINE-CONTROL, UNBIND, CHECKIN, VERSION-CONTROL, UNLOCK, LABEL, MOVE, ACL, BIND, REPORT` 

To remove methods from `ALL-HTTP` and `ALL-WEBDAV` simply add the method with a `-` sign in front of it.
--------------------------------------------------------------------------------
Section: ### Session Termination
Use this feature to terminate sessions on the backend application.

nevisProxy will send a `GET` request to this path when the nevisProxy session is terminated (due to logout or session timeout).
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param(s)` for the Http(s)ConnectorServlet. For example: ConnectionRetries=10

Please check the nevisProxy technical documentation for supported `init-params` of the servlet classes `ch::nevis::isiweb4::servlet::connector::http::HttpConnectorServlet` and `ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet`.

## Request Validation Settings (ModSecurity)

Use the pattern to customize ModSecurity rules.
Assign the same pattern to multiple applications to enforce a common configuration.

Do not use rule IDs in the range 500001-500999 
as they are reserved for Nevis internal purposes. 

Deploying changes to an existing pattern triggers a restart of nevisProxy 
if the `RestartPolicy` is set to `eager`.

Restarting the instance better suits large and highly customised ModSecurity setups.

If you prefer to let nevisProxy reload the ModSecurity configuration on-the-fly, 
set the `RestartPolicy` to `lazy` in the corresponding `nevisProxy Instance` patterns.
--------------------------------------------------------------------------------
Section: ### Validation Scope
Sets the scope of request validation:

- `all`: validation will be applied to all requests. This includes authentication.

- `backend`: validation will be applied to requests which are sent to the backend application. The authentication is excluded.

- `authentication`: validation will be applied to requests which are sent to nevisAuth.
--------------------------------------------------------------------------------
Section: ### Log Only Mode
Allows to use the request validation settings in log only mode.
--------------------------------------------------------------------------------
Section: ### Backend Host Rewriting
- `off` disables automatic response rewriting
- `header` enables auto rewrite of response headers (includes cookies)
- `complete` enables auto rewrite for response headers and body
--------------------------------------------------------------------------------
Section: ### Response Body Content Types
Enter regular expressions to match the `Content-Type`
of responses. If the expression matches, the response body is rewritten.

## Rule Bundle (ModSecurity)

Use the pattern to further customize ModSecurity rules.

Assign the same pattern to multiple `Request Validation Settings` patterns
to easily configure and maintain global or group ModSecurity rule configurations.

Do not use rule IDs in the range 500001-500999 
as they are reserved for Nevis internal purposes.
--------------------------------------------------------------------------------
Section: ### Whitelist Modifications
Configure _whitelist modifications_.

As explained in the [ModSecurity documentation](https://www.modsecurity.org/CRS/Documentation/exceptions.html#exceptions-versus-whitelist)
_whitelist modifications_ are applied **before** including the core rules.

If both the `Request Validation Settings` and the `Rule Bundle` pattern have _whitelist modifications_ configured, first
the `Rule Bundle`, then the `Request Validation Settings` whitelists will be applied.

Note that new rule may require a rule ID which has to be unique for this pattern.
Use the range 1-99,999 as it is reserved for local (internal) use. 

* Remove rule with ID `900200` for the path `/app/some.html`:

`SecRule REQUEST_URI "@streq /app/some.html" "pass,nolog,id:1000,ctl:ruleRemoveById=200002"`
--------------------------------------------------------------------------------
Section: ### Exception Modifications
Configure _exception modifications_.

As explained in the [ModSecurity documentation](https://www.modsecurity.org/CRS/Documentation/exceptions.html#exceptions-versus-whitelist)
_exception modifications_ are applied **after** including the core rules.

If both the `Request Validation Settings` and the `Rule Bundle` pattern have _exception modifications_ configured, first
the `Request Validation Settings`, then the `Rule Bundle` modifications will be applied.

Note that new rule may require a rule ID which has to be unique for this pattern.
Use the range 1-99,999 as it is reserved for local (internal) use. 

* Remove rule with ID `900200`:

`SecRuleRemoveById 900200`

* Whitelist body parameter `upload` for all rules:

`SecRuleUpdateTargetByTag ".*" "!ARGS:upload"`

* Whitelist body parameter `upload` for rule ID `123`:

`SecRuleUpdateTargetById 123 !ARGS:upload`

* Add a new rule which allows the HTTP methods used for WebDAV:

```
SecAction \
 "id:1,\
  phase:1,\
  nolog,\
  pass,\
  t:none,\
  setvar:'tx.allowed_methods=GET HEAD POST OPTIONS PUT PATCH DELETE CHECKOUT COPY DELETE LOCK MERGE MKACTIVITY MKCOL MOVE PROPFIND PROPPATCH PUT UNLOCK'"
```

## SOAP Service

The pattern sets up access to a backend application which provides a SOAP service.
--------------------------------------------------------------------------------
Section: ### Virtual Hosts
Assign `Virtual Host` patterns which shall serve as entry point for this application.
--------------------------------------------------------------------------------
Section: ### Frontend Path
The (base) path of the application.

Examples:

- `/app/` - defines a base path. 
Any requests which have a path component starting with `/app/` will be sent to this application.
- `/` - forward all requests to this application. 
Use this only when there are no other applications or hosted resources.
- `exact:/app.html` - matches requests to `/app.html` only (query parameters are allowed). 
Use this for single-page applications which don't require any additional resources.

Note that if the frontend path is different from the path used within `Backend Addresses` 
then URL rewriting will be configured to correctly route
requests and responses between clients and backends.
--------------------------------------------------------------------------------
Section: ### Backend Addresses
Enter the complete URLs (scheme, host, port and path) of the backend services. 

Note: 

- all URLs must use the same scheme and path.
- automatic path rewriting will be performed when the path differs from the `Frontend Path`.

In case you are setting multiple addresses, use `Load Balancing` to select a request dispatching strategy.
--------------------------------------------------------------------------------
Section: ### Load Balancing
Select a request dispatching strategy when several `Backend Addresses` are configured.

- `disabled` - all requests will be sent to the first address. If this address is not available the next address is chosen;
- `round-robin` - one of the addresses will be picked up for each request using a round-robin rotation;
- `session-sticky` - one of the addresses will be picked up for each new session using a round-robin rotation, then subsequent requests for the session will be sent to the same address.


Failover strategy:

* When the selected backend cannot be accessed, nevisProxy will attempt to use another one.
* Once the said backend can be accessed again, it can be picked up for new requests if the load balancing is `round-robin`, or for new sessions if the load balancing is `disabled` or `session-sticky`. 
The requests linked to an existing session will still go to the current backend until the end of the session if the load balancing is `disabled` or `session-sticky`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Optional setting for enabling trust to HTTPS backends.

For securing production environments:
- set `Backend Addresses` starting with `https://`
- assign a `Trust Store` pattern containing the certificates required for verifying the backend certificate
- set `Hostname Validation` to `enabled`
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname configured in `Backend Addresses`
--------------------------------------------------------------------------------
Section: ### Host Header
Defines the `Host` header for requests forwarded to the application.

When `backend` is selected then nevisProxy uses the host part of the backend address that has been selected.
This is the default behaviour and similar to what a browser would do.
Therefore, this configuration should work in most cases.

When `client` is selected then nevisProxy will keep the `Host` header as received from the client.
The following `init-param` will be generated:
              
```
<init-param>
  <param-name>HostName</param-name>
  <param-value>ENV:HTTP_Host;</param-value>
</init-param>
```

The configuration is dynamic to support virtual hosts with multiple frontend addresses.
Note that this may be less secure. 
Even though browsers do not allow this clients may sent an arbitrary value for the `Host` header.
It is therefore recommended to test how your application behaves in this case.
--------------------------------------------------------------------------------
Section: ### Response Rewriting
Use this feature to replace backend hostnames in responses
or set to `custom` to configure complex rewriting use cases.

- `off` disables automatic response rewriting
- `header` enables auto rewrite for response headers (including Set-Cookie header)
- `complete` enables auto rewrite for the entire response (including body)
- `custom` configure `Response Rewriting Settings` via `Additional Settings`
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the HTTP methods allowed for this application. 

Methods which are listed here must also be allowed on the `Virtual Host`.

You may also use the following method groups:

* `ALL-HTTP` includes common HTTP methods.

  These are: `GET, POST, HEAD, DELETE, TRACE, CONNECT, OPTIONS, PUT, PATCH`

* `ALL-WEBDAV` includes all methods required for WebDAV.
  
  These are: `MERGE, UNCHECKOUT, MKACTIVITY, PROPPATCH, LOCK, CHECKOUT, SEARCH, COPY, MKCOL, MKWORKSPACE, PROPFIND, UPDATE, REBIND, BASELINE-CONTROL, UNBIND, CHECKIN, VERSION-CONTROL, UNLOCK, LABEL, MOVE, ACL, BIND, REPORT` 

To remove methods from `ALL-HTTP` and `ALL-WEBDAV` simply add the method with a `-` sign in front of it.
--------------------------------------------------------------------------------
Section: ### Session Termination
Use this feature to terminate sessions on the backend application.

nevisProxy will send a `GET` request to this path when the nevisProxy session is terminated (due to logout or session timeout).
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param(s)` for the Http(s)ConnectorServlet. For example: ConnectionRetries=10

Please check the nevisProxy technical documentation for supported `init-params` of the servlet classes `ch::nevis::isiweb4::servlet::connector::http::HttpConnectorServlet` and `ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet`.

## Secret Test

#*TESTING ONLY - NOT FOR PRODUCTION USE*

Used for testing the secret-preserving in Kubernetes deployments.

Assign to a `nevisProxy Instance` using `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Secret File(s)
Set a variable and upload secret file(s) in the inventory.

The file `/var/opt/nevisproxy/<instanceName>/run/secret_files.txt` should then contain:

- classic: resolved value(s)
- Kubernetes: `inv-res-secret://` reference(s)

## Security Response Headers

Configure security headers to be set by nevisProxy on responses.
Assign the pattern to an entire `Virtual Host` or individual applications.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply the cache handling on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |

## TCP Settings

Use the pattern to customize TCP connections to backend applications.
Assign the same pattern to multiple applications to enforce a common standard.

| `DNS Caching` | `Keep-Alive` | Description |
| ------------------------------------- | ------------------------------------- | --- |
| `disabled` | `disabled` | Always works but has the biggest impact on latency. |
| `disabled` | `enabled` | DNS may resolve a new IP but Keep-Alive is enabled so some requests may still be routed to the previous IP. This may be acceptable if the previous IP is still reachable and could even be required in case sessions are bound to the TCP connection. |
| `enabled` | `disabled` | The resolved IPs are stable but for each request a new TCP connection is established. |
| `enabled` | `enabled` | The resolved IPs are stable and connections are reused. |
--------------------------------------------------------------------------------
Section: ### Lifetime
The absolute lifetime of a TCP connection. This should be configured to less than the connection lifetime allowed by the firewall between nevisProxy and the content providers. By leaving this field empty, you will be using the nevisProxy default value.


## TLS Settings

Use the add-on to customize TLS/SSL settings for nevisProxy.

Assign to a `Virtual Host` to customize settings for incoming connections.

You can customize connections to backends by assigning the pattern to your service 
(`Web Application`, `REST Application`, `SOAP Application`) using `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Protocols
The value configured here will be applied as `SSLProtocol`. 

Check the [Apache Documentation](http://httpd.apache.org/docs/current/mod/mod_ssl.html#sslprotocol) for details.

If empty and when this pattern is assigned to a `Virtual Host` the following value is used:

`-all +TLSv1.2 -TLSv1.3`

If empty and when this pattern is assigned to an application, default `SSLProtocol` from nevisProxy are applied.
Check the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy/Configuration/Servlets/HttpsConnectorServlet) for details.
--------------------------------------------------------------------------------
Section: ### Cipher Suite
The value configured here will be applied as `SSLCipherSuite`.

Check the [Apache Documentation](http://httpd.apache.org/docs/current/mod/mod_ssl.html#sslciphersuite) for details.

If empty and when this pattern is assigned to a `Virtual Host` the following value is used:

`ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES128-GCM-SHA256`

If empty and when this pattern is assigned to an application, default `SSLCipherSuites` from nevisProxy are applied.
Check the [nevisProxy Technical Documentation](https://docs.nevis.net/nevisproxy/Configuration/Servlets/HttpsConnectorServlet) for details.
--------------------------------------------------------------------------------
Section: ### SSL Options
The value configured here will be applied as `SSLOptions`.

It should only have value when assigned to a `Virtual Host` pattern.

Check the [Apache Documentation](http://httpd.apache.org/docs/current/mod/mod_ssl.html#ssloptions) for details.

If empty and when this pattern is assigned to a `Virtual Host` the following value is used:

`+OptRenegotiate +StdEnvVars +ExportCertData`

## Testing Service

#*TESTING ONLY - NOT FOR PRODUCTION USE*

Used for testing. This pseudo service does not configure anything but allows tweaking the validation, generation, planning and deployment processes.
--------------------------------------------------------------------------------
Section: ### On deployment
Use for testing only.

## URL Handling

Use the pattern to:

- *redirect* requests (returning status code `302` with a `Location` header)
- rewrite the path of a request, that is, *forward*.

Query parameters are always considered.

You can use the pattern as an add-on for `Virtual Host`
or any application, for example, `Web Application`, `REST Service`, `SOAP Service`.

Redirect and forward rules have the following format:

`<source> -> <destination>`

The pattern generates a nevisProxy `RewriteFilter` named `URLHandler_<name>`.
If either `source` or `destination` starts with `http://` or `https://` 
then the init-param `RequestURL` is set, otherwise `RequestURI` is used.
--------------------------------------------------------------------------------
Section: ### Apply only to sub-paths
Set to apply this pattern on some sub-paths only.

Sub-paths must be relative (e.g. not starting with `/`)
and will be appended to the frontend path(s) of the virtual host (`/`) 
or applications this pattern is assigned to.

Sub-paths ending with `/` are treated as a prefix,
otherwise an exact filter-mapping will be created.

The following table provides examples to illustrate the behaviour:

| Frontend Path | Sub-Path | Effective Filter Mapping |
|---|---|---|
| `/` | `secure/` | `/secure/*` |
| `/` | `accounts` | `/accounts` |
| `/` | `api/secure/` | `/api/secure/*` |
| `/` | `api/accounts` | `/api/accounts` |
| `/app/` | `secure/` | `/app/secure/*` |
| `/app/` | `accounts` | `/app/accounts` |
| `/app/` | `api/secure/` | `/app/api/secure/*` |
| `/app/` | `api/accounts` | `/app/api/accounts` |
--------------------------------------------------------------------------------
Section: ### Filter Phase
The phase when this filter should be applied depends on your use case.

- use `START` when the redirect / rewrite should be done as early as possible.
- use `AFTER_SANITATION` to redirect / rewrite after validating the request.
- use `AFTER_AUTHENTICATION` to redirect / rewrite after authentication.

## Unauthenticated Realm

Public applications typically do not have an `Authentication Realm` assigned.
However, there are some cases where you have to assign this pattern.

1) You have a public and an authenticated application with overlapping `Frontend Paths`. 

Assign this pattern to your public application
and select `disabled` in the `Session Tracking` drop-down.

This expresses that no sessions are expected.

This pattern ensures that session tracking and authentication are excluded from 
all frontend paths of your public application.

2) You are using nevisProxy features which need a session.

For instance, the `Cookie Customization` pattern needs a nevisProxy session to store cookies
when you configure `Shared Protected Cookies` or `Protected Cookies`.

In this case, set the `Session Tracking` drop-down to `COOKIE`.

In general, we do not recommended to have a proxy session for public applications, 
as it can lead to a high sessions count. Thus, we recommend to set the `Session Timeout` as low as possible.
--------------------------------------------------------------------------------
Section: ### Update Session Timestamp Interval
Sets the minimum time interval between two updates of the session timestamp.

If the parameter is set to "0", the system will update the session timestamp each time a request accesses a session.

The `Initial Session Timeout` is used as `Update Session Timestamp Interval` if it is shorter than the duration configured here.

## Virtual Host

The pattern represents a virtual host of a `nevisProxy Instance`. 

A virtual host provides access to applications: applications are reachable on their 
`Frontend Path(s)` on all of the `Frontend Addresses` of this virtual host. 

To assign an application, add a `Web Application`, `REST Service`, or `SOAP Service` pattern,
and reference this virtual host.

The pattern supports IP-based, port-based, and name-based virtual hosting.
Name-based virtual hosting with HTTPs requires server name indication (SNI).
--------------------------------------------------------------------------------
Section: ### Name-based Virtual Hosts
With name-based virtual hosting, the server relies on the client to report the hostname
as part of the HTTP headers. Using this technique, many different hosts can share the same IP address.
 
To configure name-based virtual hosts, set the `Frontend Addresses` to the virtual
name(s) of the host and set the `Bind Addresses` to the physical addresses of the host.

For example, to set up a two virtual hosts to be reachable on the same internal address IP and port
but with different public host names, configure as follows:

```yaml
Frontend Addresses: https://www.siven.ch http://www.siven.ch
Bind Addresses: https://0.0.0.0:8443 http://0.0.0.0:8080
```

Then configure another virtual host to use the same `Bind Addresses` but different `Frontend Addresses`:

```yaml
Frontend Addresses: https://partners.siven.ch http://partners.siven.ch
Bind Addresses: https://0.0.0.0:8443 http://0.0.0.0:8080
```

Note: name-based virtual hosts using HTTPS requires all clients supporting SNI.
--------------------------------------------------------------------------------
Section: ### nevisProxy
Assign the `nevisProxy Instance` this virtual host should be assigned to.
--------------------------------------------------------------------------------
Section: ### Frontend Addresses
Define addresses (HTTPS or HTTP) at which this host will be reachable from a client perspective.

The basic syntax is:

- `<scheme>://<hostname>`
- `<scheme>://<hostname>:<port>`

A variable may be used to define different addresses for different stages (e.g. DEV, TEST, PROD).

The expression `${deployment_host}` may be used when the name of the target host is required.

Examples:

- `http://www.siven.ch`
- `https://www.siven.ch`
- `http://${deployment_host}:8080`

The `port` will, if omitted, default to `443` for HTTPS and to `80` for HTTP.

You also have to set `Bind Addresses` if:

- the addresses cannot be resolved on the target host(s)
- the port should be opened on different addresses / IPs, or ports.
- multiple virtual hosts should listen on the same endpoint (name-based virtual hosts).
--------------------------------------------------------------------------------
Section: ### Bind Addresses
The physical address(es) to bind on, with scheme HTTP or HTTPS and ports. 

Must be set when multiple virtual hosts should listen on the same endpoint
(name-based virtual hosts).

If not set the `Frontend Addresses` will be used to bind.

The host name must resolve to an IP which is bound to a network interface.

You can also use `0.0.0.0` for the host name to listen on all network interfaces.

Examples:
```yaml
https://www.siven.ch:8443
http://localhost:8080
https://192.168.1.1:443
http://0.0.0.0:80
```
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Set a trust store to validate client certificates
for incoming TLS connections.

The trust store may contain an arbitrary number of CA certificates.
Client certificates must be signed by those CAs.

**Caution**: client certificate authentication is not enabled automatically. 
As of release 4.3.1 there are no dedicated patterns but client cert authentication 
can be enforced for the entire host (e.g. using `Generic nevisProxy Settings`) 
or in the authentication process (`X509State` and `IdentityCreationFilter` init-param `ClientCert`).
--------------------------------------------------------------------------------
Section: ### Hosted Resources
Upload a ZIP to provide your own resources.

By default, the following resources are provided:

* `/favicon.ico`
* `/index.html`
* `/errorpages/403.html`
* `/errorpages/404.html`
* `/errorpages/500.html`
* `/errorpages/502.html`
* `/resources/logo.png`
* `/resources/bootstrap.min.css`
* `/resources/default.css`

This host has its own error handler (`ErrorHandler_Default`) which is assigned to the root location (`/*`).
The error handler will replace the response body when an HTTP error code occurs and an error page is available.

Error pages for HTML must be added the sub-directory `errorpages` and named `<code>.html`.

The error code is returned to the caller as this may be required by some REST clients.

If you do not want this you can assign a specific `HTTP Error Handling` pattern 
to this `Virtual Host` or to applications via `Additional Settings`.

The servlet hosting the above resources is usually mapped to the root location (`/*`), however if there is already 
another servlet mapped there, the servlet is mapped to individual root files and directories. 

If there is an undesired mapping, it can be deleted by removing the given resource from the zip file.
--------------------------------------------------------------------------------
Section: ### Require Client Certificate
Choose from:

- `disabled (default)`: No client certificate is required to connect to this virtual host.

- `enabled`: Clients must present a client certificate signed by a CA.
The CA which has issued the client certificate must be part of the `Frontend Truststore`.
When no client certificate is presented or the certificate is not valid the connection will be aborted. 
As no error page is rendered this feature is not recommended when there are browser-based clients.
Use for technical clients only.
--------------------------------------------------------------------------------
Section: ### Qos Configuration (mod_qos)
nevisProxy uses the [mod_qos](http://mod-qos.sourceforge.net/) module 
to ensure quality of service (QoS). Choose between:

- `off`: the module is disabled on this virtual host.
- `standard`: provides a default configuration which protects against common denial of service (DoS) attacks.
- `custom`: configure `Generic mod_qos Configuration` via `Additional Settings`.
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the HTTP methods which are allowed on this virtual host.

The setting `default (complete)` is quite relaxed as it enables most methods. 
Only two are excluded:

- `CONNECT`: no use case of nevisProxy.
- `TRACE`: may be useful for debugging but can be a security vulnerability.

If you do not have any applications using WebDav select `basic`.

The allowed HTTP methods can be restricted further in application patterns.

For more fine-grained control you may use `Generic nevisProxy Instance Settings` 
to overwrite the `allowedMethods` (see pattern help for details).
--------------------------------------------------------------------------------
Section: ### ModSecurity Rule Set
Upload a `.zip` file containing configuration for ModSecurity.
The `.zip` must contain a configuration file called `modsecurity.conf`.

The `modsecurity.conf` file will be included for all `Web Application` patterns
which have `Request Validation` set to `standard`, `custom`, or `log only`.

Click `Download Default Configuration` to download the default configuration
which is applied when no `.zip` is uploaded.
There is one link per provided `OWASP ModSecurity CRS Version`.
--------------------------------------------------------------------------------
Section: ### HTTP/2 Support
Enables the support of HTTP/2 for incoming connections on this nevisProxy virtual host.

Note that mod_qos has limited support for HTTP/2, therefore only request level directives are supported if enabled.
--------------------------------------------------------------------------------
Section: ### Static Cache
Add a Static Content Cache pattern to the Virtual Host.

Use it to cache the early hint resources as static content in nevisProxy to further increase the performance.
Map the Static Content Cache pattern to the same paths as the Early Hints parameter.
--------------------------------------------------------------------------------
Section: ### Additional Settings
Assign add-on patterns to customize the behaviour of this virtual host.


## Web Application

Using the pattern, you can set up access to a web application 
on a nevisProxy `Virtual Host`.
--------------------------------------------------------------------------------
Section: ### Virtual Hosts
Assign `Virtual Host` patterns which shall serve as entry point for this application.
--------------------------------------------------------------------------------
Section: ### Frontend Path(s)
Enter the path(s) where this application shall be accessible on the assigned `Virtual Host`.

It is recommended to set only 1 path. Examples:

- `/app/` - defines a base path. 
Requests which have a path component starting with `/app/` will be sent to this application. This is the most common scenario.

- `/` - may be used when there are no other applications. 
The `Hosted Resources` of the `Virtual Host` are still accessible but all other requests will be sent to the backend application.

- `exact:/app.html` - matches requests to `/app.html` only (query parameters may also be added). 
Use for single-page applications which don't require any additional resources.
  
- `prefix:/app` - matches requests which have a path component starting with `/app`. 
Examples: `/application`, `/app/index.html`, `/app2/secure/`

In case the frontend path is different from the path used within `Backend Addresses` 
then the path will be rewritten in incoming requests. 

Note that for response by default only the headers are rewritten. See `Response Rewriting` for further options.

Note that when you enter multiple paths there are some limitations:

- Filters created by a `Realm` or `Additional Settings` will be mapped to all paths.
- The paths have to be the same on the backend server.
--------------------------------------------------------------------------------
Section: ### Backend Addresses
Enter the complete URLs (scheme, host, port and path) of the backend services. 

Note: 

- all URLs must use the same scheme and path.
- automatic path rewriting will be performed when the path differs from the `Frontend Path`.

In case you are setting multiple addresses, use `Load Balancing` to select a request dispatching strategy.
--------------------------------------------------------------------------------
Section: ### Load Balancing
Select a request dispatching strategy when several `Backend Addresses` are configured.

- `disabled` - all requests will be sent to the first address. If this address is not available the next address is chosen;
- `round-robin` - one of the addresses will be picked up for each request using a round-robin rotation;
- `session-sticky` - one of the addresses will be picked up for each new session using a round-robin rotation, then subsequent requests for the session will be sent to the same address.


Failover strategy:

* When the selected backend cannot be accessed, nevisProxy will attempt to use another one.
* Once the said backend can be accessed again, it can be picked up for new requests if the load balancing is `round-robin`, or for new sessions if the load balancing is `disabled` or `session-sticky`. 
The requests linked to an existing session will still go to the current backend until the end of the session if the load balancing is `disabled` or `session-sticky`.
--------------------------------------------------------------------------------
Section: ### Trust Store
Optional setting for enabling trust to HTTPS backends.

For securing production environments:
- set `Backend Addresses` starting with `https://`
- assign a `Trust Store` pattern containing the certificates required for verifying the backend certificate
- set `Hostname Validation` to `enabled`
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by the backend matches the hostname configured in `Backend Addresses`
--------------------------------------------------------------------------------
Section: ### Host Header
Defines the `Host` header for requests forwarded to the application.

When `backend` is selected then nevisProxy uses the host part of the backend address that has been selected.
This is the default behaviour and similar to what a browser would do.
Therefore, this configuration should work in most cases.

When `client` is selected then nevisProxy will keep the `Host` header as received from the client.
The following `init-param` will be generated:
              
```
<init-param>
  <param-name>HostName</param-name>
  <param-value>ENV:HTTP_Host;</param-value>
</init-param>
```

The configuration is dynamic to support virtual hosts with multiple frontend addresses.
Note that this may be less secure. 
Even though browsers do not allow this clients may sent an arbitrary value for the `Host` header.
It is therefore recommended to test how your application behaves in this case.
--------------------------------------------------------------------------------
Section: ### Response Rewriting
Enable to replace backend host names in responses
or set to `custom` for complex rewriting use cases.

- `off` - disables automatic response rewriting
- `header` - enables auto rewrite for response headers (including `Set-Cookie` header)
- `complete` - enables auto rewrite for the entire response (including body)
- `custom` - requires assignment of `Response Rewriting Settings` via `Additional Settings`
--------------------------------------------------------------------------------
Section: ### CSRF Protection
_Cross-Site Request Forgery_ (_CSRF_) is an attack to force an authenticated user to send unwanted requests.

- `off (default)` - no CSRF protection. Recommended for applications which may be called from other sites.
- `header-based` - `GET` and `HEAD` requests are allowed (assumption: these methods must not manipulate server-side state). 
For other requests the `Referer` and `Origin` headers must match the `Host` header.
--------------------------------------------------------------------------------
Section: ### Request Validation (ModSecurity)
- `off` - no request validation
- `standard` - uses ModSecurity OWASP Core Rule Set (CRS) with default paranoia level 1 - Basic security
- `custom` - configure `Request Validation Settings` via `Additional Settings`
- `log only` - uses `standard` in log only mode
--------------------------------------------------------------------------------
Section: ### Allowed HTTP Methods
Define the HTTP methods allowed for this application. 

Methods which are listed here must also be allowed on the `Virtual Host`.

You may also use the following method groups:

* `ALL-HTTP` includes common HTTP methods.

  These are: `GET, POST, HEAD, DELETE, TRACE, CONNECT, OPTIONS, PUT, PATCH`

* `ALL-WEBDAV` includes all methods required for WebDAV.
  
  These are: `MERGE, UNCHECKOUT, MKACTIVITY, PROPPATCH, LOCK, CHECKOUT, SEARCH, COPY, MKCOL, MKWORKSPACE, PROPFIND, UPDATE, REBIND, BASELINE-CONTROL, UNBIND, CHECKIN, VERSION-CONTROL, UNLOCK, LABEL, MOVE, ACL, BIND, REPORT` 

To remove methods from `ALL-HTTP` and `ALL-WEBDAV` simply add the method with a `-` sign in front of it.
--------------------------------------------------------------------------------
Section: ### Session Termination
Use this feature to terminate sessions on the backend application.

nevisProxy will send a `GET` request to this path when the nevisProxy session is terminated (due to logout or session timeout).
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param(s)` for the Http(s)ConnectorServlet. For example: ConnectionRetries=10

Please check the nevisProxy technical documentation for supported `init-params` of the servlet classes `ch::nevis::isiweb4::servlet::connector::http::HttpConnectorServlet` and `ch::nevis::isiweb4::servlet::connector::http::HttpsConnectorServlet`.

## WebSocket Support for Application

The pattern enables WebSocket support for backend applications. 
Assign to your application using `Additional Settings`.

The pattern generates two additional servlets:

- a `WebSocketServlet` named `Connector_<application>_WS`
- a `ServletMappingServlet` which selects `Connector_<application>_WS` when the HTTP Header `Upgrade` contains the value `websocket`

The TCP connection is reserved for each WebSocket connection.
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param` for the WebSocket servlet. 

Please check the nevisProxy technical documentation for supported `init-params` 
of the servlet class `ch::nevis::isiweb4::servlet::connector::websocket::WebSocketServlet`.

## nevisKeybox Store

Apply the pattern to use existing key material from nevisKeybox. 
You can assign the pattern where-ever a key store or trust store is required.

The nevisKeybox instance is to be named `default`.

The pattern does not deploy any key material. 
This is the intended behavior and not a limitation.

To deploy a private key and certificate you may use `PEM Key Store` instead,
for deploying trusted certificates use `PEM Trust Store` instead.
--------------------------------------------------------------------------------
Section: ### Slot
A `Slot` is a directory of a nevisKeybox instance.

By default, nevisKeybox is located at `/var/opt/neviskeybox/default/`.
If missing please run the following command on the affected target server(s):

`neviskeybox handover`

A `Slot` may contain:

- an arbitrary number of key stores (identified by label)
- up to 1 trust store.
--------------------------------------------------------------------------------
Section: ### Validation
Allows to the validation in case the nevisKeybox is deployed by this project (e.g. using `Generic Deployment`).

## nevisProxy Instance

The pattern represents a nevisProxy instance.

Create at least one `Virtual Host` pattern and assign this pattern.
--------------------------------------------------------------------------------
Section: ### Default Virtual Host
The default virtual host of this nevisProxy instance. 

The default will be used for requests without a `Host` header
or if there is no host with a corresponding frontend address.
--------------------------------------------------------------------------------
Section: ### Server LogFormat
Allows the configuration of the `LogFormat` Apache directive in the navajo.xml file.

For more information, check the [official Apache documentation](http://httpd.apache.org/docs/current/mod/mod_log_config.html#logformat) of the directive.

## nevisProxy Observability Settings

Sets up observability with OpenTelemetry for nevisProxy.

The OpenTelemetry settings are applied to each Virtual Host of the instance.
--------------------------------------------------------------------------------
Section: ### Metrics Interval
Interval of the metrics reader to initiate metrics collection.

## nevisProxy Remote / Hybrid Session Store

Configures nevisProxy to use a MariaDB database for storing sessions.
Assign to `Virtual Host` as `Session Store`.

Use this pattern when in-memory session storage cannot be used.
Note that in-memory sessions may be sufficient in the following cases:

- classic (VM) deployment: only 1 line or load balancing towards proxy is session sticky
- Kubernetes deployment: only 1 pod (not recommended)

The session store is used only when there are filters or servlet which require a session.
In particular, this is the case when you assign an `Authentication Realm` to applications.

You can choose between _remote_, or _hybrid_ session store.
An overview about different types can be found [here](https://docs.nevis.net/nevisproxy/Use-Cases-and-Best-Practices/Session-Store-Setups/).
The _hybrid_ session store can be used in classic deployment only.

When deploying to Kubernetes, the database and connection user will be created automatically.
The database schema will be migrated automatically when upgrading Nevis on the next deployment.

In classic VM deployment you have to create the database including tables.
Setup instructions can be found in the nevisProxy Technical Documentation. 
For details see [`Configuration of MariaDB-based remote session store`](https://docs.nevis.net/nevisproxy/Configuration/Servlets/MySQLSessionStoreServlet).
--------------------------------------------------------------------------------
Section: ### TLS Encryption
If `enabled` the query parameter `useSSL=true` will be added to enable 1-way TLS.

If no `Trust Store` is assigned then `trustServerCertificate=true` will be added to the connection string.

Assignment of a `Trust Store` is recommended for production use.

**Note:** `PostgresSQL` database connection configuration doesn't support TLS connection yet.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Session Store Peer Address
The hybrid session store requires that the `nevisProxy Instance` is deployed on 2 lines.
For illustration purposes let's call the hosts where the instances are deployed `p1` and `p2`.

Enter the URL where the other nevisProxy `Virtual Host` exposes its local session store.
The URL must be reachable and should not go via a load-balancer to ensure that the request reaches the peer proxy directly.

You can use variables to ensure that the correct host name is used for the configuration on each line.
For instance, the variable may be a host variable and have the following values:

- for server `p1` use: `https://p2:443`
- for server `p2` use: `https://p1:443`

Alternatively, you can use a semantic host name and and define this name in `/etc/hosts` on both `p1` and `p2`.

Example: `https://proxy-peer:443`
--------------------------------------------------------------------------------
Section: ### Peer Servlet Strategy
Controls the used strategy of the Peer Servlet:

 * `FAILOVER`: The loadbalancer sends all requests to the same instance (instance A). If instance A goes down, the loadbalancer will send now all requests to instance B. The loadbalancer should only switch back to instance A if it has been restarted.
 * `DISTRIBUTED`: The loadbalancer assure at least 90% session stickiness to both instances, for example by using the client IP address. Once the request for a session goes to the other instance, this one will get the session information from the first instance and copy into its local session store.
--------------------------------------------------------------------------------
Section: ### Custom Parameters
Add custom `init-param` for the MySQL session store servlet.

Check the nevisProxy technical documentation for supported parameters
of the servlet class `ch::nevis::nevisproxy::servlet::cache::mysql::MySQLSessionStoreServlet`.
--------------------------------------------------------------------------------
Section: ### Configuration: nevisfido.yml
This setting provides a low-level way to
add or overwrite configuration in `nevisfido.yml`.

Enter the configuration as it would appear in the `nevisfido.yml` using correct indentation.

For now, the only supported case is to add additional entries to the `dispatchers` block. 
The setting will be improved in a future release to support additional cases.

Example:

```yaml
fido-uaf:  
  dispatchers:
  - type: png-qr-code
    registration-redeem-url: http://localhost:9080/nevisfido/token/redeem/registration
    authentication-redeem-url: http://localhost:9080/nevisfido/token/redeem/authentication
    deregistration-redeem-url: http://localhost:9080/nevisfido/token/redeem/deregistration
```


## In-band Mobile Authentication Realm

Sets up [In-Band Authentication](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/in-band-authentication) 
to protect REST services.

If you want to protect a web application and use mobile authentication from a web browser, use `Out-of-band Mobile Authentication` instead.

In a nutshell, the pattern configures Nevis for the following use case:

1. The user opens the mobile application and accesses a protected resource, for which they have no authorization yet.
2. The mobile application prompts the user to authenticate.
3. The mobile app sends a request to `/auth/fidouaf` to authenticate.
4. The user is now authenticated, the mobile application is able to access the protected REST service.

Before executing mobile authentication, the user has to register their mobile device. 
The required APIs can be set up using `In-band Mobile Registration Service` pattern.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a pattern which provides the trust store for nevisAuth to connect to nevisFIDO.
--------------------------------------------------------------------------------
Section: ### Trust Store
Defines the trust store that nevisProxy uses to validate the nevisAuth HTTPs endpoint.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisAuth matches the configured hostname in the `nevisAuth Instance` or `nevisAuth Connector` pattern.
--------------------------------------------------------------------------------
Section: ### Internal SecToken Trust Store
Defines the trust store nevisProxy uses for validating the signature of the NEVIS SecToken issued by nevisAuth.
--------------------------------------------------------------------------------
Section: ### Custom Parameters (IdentityCreationFilter)
Add custom `init-param` elements to **each** `IdentityCreationFilter` generated by this pattern.

Most realms generate only 1 `IdentityCreationFilter` named `Authentication_<name>`, 
which is used to protect the application.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                 |
|----------------------|---------------------------------------|
| BodyReadSize         | 64000                                 |
| InterceptionRedirect | Condition:ENV:HTTP_USER_AGENT:mozilla\|Mozilla\ninitial\nnever |
| ClientCert           | want                                  |
--------------------------------------------------------------------------------
Section: ### Custom Parameters (Esauth4ConnectorServlet)
Add custom `init-param` elements to the `Esauth4ConnectorServlet` generated by this pattern.

That servlet is called `Connector_<name>`.

Multi-line values, as required for conditional configuration,
can be entered by replacing the line-breaks with `\n`. 

Examples:

| Key                  | Value                                                          |
|----------------------|----------------------------------------------------------------|
| EnablePollTerminatedCalls | true                                                      |
--------------------------------------------------------------------------------
Section: ### Trust Store
If nevisLogrend is used and the connection to nevisLogrend uses HTTPs then a trust store should be configured here.
  
If no pattern is assigned the nevisAdmin 4 automatic key management will set up a trust store.
--------------------------------------------------------------------------------
Section: ### Hostname Validation
Enable to verify that the hostname on the certificate presented by nevisLogRend matches the configured hostname in the `nevisLogrend Instance` or `nevisLogrend Connector` pattern.

This setting only applies if nevisLogrend is used in the `Login Renderer` setting and the connection to nevisLogrend uses HTTPs.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` which shall serve as entry point.
--------------------------------------------------------------------------------
Section: ### Virtual Host
A virtual host assigned will be used to expose the protected services.
--------------------------------------------------------------------------------
Section: ### nevisFIDO
Assign a `nevisFIDO UAF Instance`. This instance will be responsible for providing the mobile device deregistration services.

## Out-of-band Device Management App

#*DEMO/TESTING ONLY - NOT FOR PRODUCTION USE*

Provides a simple self-service application for mobile device management.
The application is a single page app (SPA) and will be hosted on the `Virtual Host` at the `Frontend Path`.

The SPA is **not** ready for production use. We recommend to implement your own Web application.
At least you have to adapt the HTML, CSS, and JavaScript based on your requirements.

The nevisIDM `bootstrap` user (or any other user with `nevisIdm.Root` role)
can not be used to test the device management as the nevisfido technical user
is not allowed to manage credentials of root users.

The SPA sends the following AJAX calls to render a device list:

1a) Get user attributes: `GET /nevisidm/api/principal/v1/me` (authentic)
1b) Get generic credentials: `GET /nevisidm/api/core/v1/100/users/<userExtId>/generic-credentials/` (authentic)

When you then click "Enroll new device", the following API calls are sent:

2a) Generate QR-Code: `POST /nevisfido/token/dispatch/registration` (authentic)
2b) Poll for completion: `POST /nevisfido/status` (public)

Now you can scan the displayed QR code with the mobile app. This leads to the following calls:

3a) `POST /nevisfido/token/redeem/registration` (authentic)
3b) `GET /nevisfido/uaf/1.1/facets` (public)

The registration is completed with by the mobile app with:

4a) `POST /nevisfido/uaf/1.1/registration/` (authentic)

This pattern does **not** validate that the required APIs are set up!
You **must** provide these APIs by adding appropriate patterns.
For instance, you can use the following patterns:

- `nevisIDM REST Service` or `nevisIDM Administration GUI` (provides 1a, 1b)
- `Out-of-band Mobile Registration Service` (provides 2a, 2b, 3a, 3b, 4a)

The same `Authentication Realm` must be assigned in all these patterns.
--------------------------------------------------------------------------------
Section: ### Virtual Host
A virtual host assigned will be used to expose services required for ```Out-of-band Management Application```.
--------------------------------------------------------------------------------
Section: ### Frontend Path
The path at which the management app shall be accessible at the frontend.
--------------------------------------------------------------------------------
Section: ### Virtual Host
To complete the authentication, the mobile app will send a request
to `/nevisfido/token/redeem/authentication`.

The domain is coded into the mobile app and has to be communicated
when ordering the app.

We recommend to assign the `Virtual Host` which serves that domain here
so that this pattern can generate the required configuration.

The `Virtual Host` assigned here will also be considered when calculating
the `Frontend Address` in the `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Key Store
Assign a key store for the TLS connection to nevisFIDO.

If no pattern is assigned, a key store will be provided
by automatic key management.

The client certificate in the key store must be trusted by nevisFIDO.

In case both sides use automatic key management, trust can be established automatically and there is nothing to configure.

However, if you are using a different kind of key store,
then you **must** configure `Frontend Trust Store` in the associated `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used to establish a connection with the nevisFIDO component.

The trust store must contain the certificate of the CA that has issued
the certificated contained in the `Key Store` of the `nevisFIDO UAF Instance`.

In case both sides use automatic key management, 
trust can be established automatically and there is nothing to configure.
--------------------------------------------------------------------------------
Section: ### Virtual Host
To complete the authentication, the mobile app will send a request
to `/nevisfido/token/redeem/authentication`.

The domain is coded into the mobile app and has to be communicated
when ordering the app.

We recommend to assign the `Virtual Host` which serves that domain here
so that this pattern can generate the required configuration.

The `Virtual Host` assigned here will also be considered when calculating
the `Frontend Address` in the `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Key Store
Assign a key store for the TLS connection to nevisFIDO.

If no pattern is assigned, a key store will be provided
by automatic key management.

The client certificate in the key store must be trusted by nevisFIDO.

In case both sides use automatic key management, trust can be established automatically and there is nothing to configure.

However, if you are using a different kind of key store,
then you **must** configure `Frontend Trust Store` in the associated `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used to establish a connection with the nevisFIDO component.

The trust store must contain the certificate of the CA that has issued
the certificated contained in the `Key Store` of the `nevisFIDO UAF Instance`.

In case both sides use automatic key management, 
trust can be established automatically and there is nothing to configure.
--------------------------------------------------------------------------------
Section: ### Profile ID Source
Enter a variable expression for the profile ID.

The default works when this step is a follow-up of
`nevisIDM Password Login` or `nevisIDM User Lookup`.


## Out-of-band Mobile Registration Service

Provides services for [Out-of-Band Registration](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-registration).

The following paths will be exposed:

- `/nevisfido/token/dispatch/registration`
- `/nevisfido/token/redeem/registration`
- `/nevisfido/uaf/1.1/facets`
- `/nevisfido/uaf/1.1/registration/`
- `/nevisfido/status`

Out-of-band registration requires a browser and works as follows:

1. The user accesses a Web application which generates a QR code.
2. The user scans the QR code with the mobile app.
3. The mobile app creates a client-side credential.
4. The mobile app calls services provided by this pattern to establish a FIDO UAF credential in nevisIDM.

Alongside the FIDO UAF credential a Generic credential is generated which makes the mobile device a dispatch target, to which push notifications can be sent.
For more information, see [Dispatch Target Management](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/dispatch-target-management).

The Web application, which is responsible for QR code generation, is *not* provided by Nevis.
However, you can use the 'Out-of-band Device Management App' pattern to test out-of-band registration.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign the `Virtual Host` which serves the domain where the nevisFIDO services shall be exposed
so that this pattern can generate the required configuration.

The domain is coded into the mobile app and has to be communicated
when ordering the app.

The `Virtual Host` assigned here will also be considered when calculating
the `Frontend Address` in the `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Virtual Host
Assign a `Virtual Host` to expose the transaction confirmation services.

The following public endpoints can be invoked:

- `/nevisfido/token/dispatch/authentication`
- `/nevisfido/status`
- `/nevisfido/token/redeem/authentication`
- `/nevisfido/uaf/1.1/facets`
- `/nevisfido/uaf/1.1/authentication`
--------------------------------------------------------------------------------
Section: ### Virtual Host
To complete the authentication, the mobile app will send a request
to `/nevisfido/token/redeem/authentication`.

The domain is coded into the mobile app and has to be communicated
when ordering the app.

We recommend to assign the `Virtual Host` which serves that domain here
so that this pattern can generate the required configuration.

The `Virtual Host` assigned here will also be considered when calculating
the `Frontend Address` in the `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Key Store
Assign a key store for the TLS connection to nevisFIDO.

If no pattern is assigned, a key store will be provided
by automatic key management.

The client certificate in the key store must be trusted by nevisFIDO.

In case both sides use automatic key management, trust can be established automatically and there is nothing to configure.

However, if you are using a different kind of key store,
then you **must** configure `Frontend Trust Store` in the associated `nevisFIDO UAF Instance`.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store used to establish a connection with the nevisFIDO component.

The trust store must contain the certificate of the CA that has issued
the certificated contained in the `Key Store` of the `nevisFIDO UAF Instance`.

In case both sides use automatic key management, 
trust can be established automatically and there is nothing to configure.
--------------------------------------------------------------------------------
Section: ### Authentication Level
Set an authentication level to apply when authentication is successful. 

The level is relevant only if there are is an `Authorization Policy` assigned to applications.


## nevisFIDO UAF Connector

Use to connect to an existing nevisFIDO UAF instance.

Use the pattern only when the instance is not set up by the project.

Ensure that the SecToken trust store of the instance allows the 
SecToken signers used in this project.
--------------------------------------------------------------------------------
Section: ### Trust Store
Assign a trust store which provides the CA certificate of the DB endpoint.
--------------------------------------------------------------------------------
Section: ### Frontend Address
Enter the address of the `Virtual Host` where the services of this instance are exposed.

Enter the address without any path component.

Example:

```
https://example.com
```

If no address is provided, the pattern tries to automatically determine a value based on the `Virtual Host` patterns,
that are associated with this instance through patterns for out-of-band use-cases.

The entered value is used to calculate:

* [AppID](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-appid-and-facets-v1.1-id-20170202.html#the-appid-and-facetid-assertions)
* _Dispatch payload_

The _dispatch payload_ informs the mobile device where to access nevisFIDO for the following use cases:
- [Out-of-band Registration](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-registration)
- [Out-of-band Authentication](https://docs.nevis.net/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication)
--------------------------------------------------------------------------------
Section: ### Frontend Trust Store
Assign the Trust Store provider for the HTTPs endpoint.
--------------------------------------------------------------------------------
Section: ### SecToken Signer Trust Store
Assign the Trust Store provider for SecToken verification.
--------------------------------------------------------------------------------
Section: ### Deep Link Host
If you have uploaded any `Deep Link App Files`, then assign a `Virtual Host`.

The files will be hosted with a base path of `/.well-known/`.

The domain of the `Deep Link` must point to this `Virtual Host`.

If the user does not have the mobile app installed,
the `Deep Link` will be opened in the browser instead.
--------------------------------------------------------------------------------
Section: ### Trust Store
The trust store nevisFIDO uses to connect to ```nevisIDM Instance```.
--------------------------------------------------------------------------------
Section: ### quickstart-appliance.md
---
sidebar_position: 2
---

# First steps (nevisAppliance)

This chapter helps you to get started with nevisAdmin 4.

It provides an introduction to the nevisAdmin 4 GUI, in the form of a tutorial.

The tutorial guides you through your first setup of Nevis Identity Suite and is based on classic VM deployment.

## Prerequisites

To use nevisAdmin 4 in your environment, the software has to be installed first.

It is recommended starting with one of these two variants:

* nevisAppliance installation with 2 VMs:

  * VM1 with an admin4 image, version 2019-02-20 or later.
    See [Software Installation](./Installation/Software-Installation) for image and nevisAdmin 4 installation instructions.

  * VM2 with the extended image, version 2019-02-20 or later. This image contains nevisProxy, nevisAuth, nevisIDM, and other components.
    See [Software installation](/nevisappliance/Installation/Software-installation) in the nevisAppliance documentation for image installation instructions.

 :::info
 We recommend using *remote* VMs instead of installing them on the same laptop. The reason is that it can be hard to configure the required networking/routing settings in VirtualBox or VMWare Workstation.
 :::

* RPM-based installation, all on the same VM:

  * Start with a basic RHEL 7 VM installation.
  * See "Software Installation" for RPM and nevisAdmin 4 installation instructions.
  * Install the RPM for nevisProxy 3.14.0.1 or higher.

For the tutorial below, it is assumed that:

* nevisAdmin 4 is up and running, and reachable via `http://nevisadmin4:9080/nevisadmin/`.
* nevisProxy, or the nevisAppliance *extended* image, is installed

  * The host is accessible via SSH at nevisproxy.
  * After completing the tasks below, it will host a website at `https://nevis`.

Depending on your environment, adapt the host names "nevisadmin4", "nevisproxy" and "nevis" as follows:

* nevisAppliance installation:

  * "nevisadmin4": Hostname of VM1.
  * "nevisproxy": Hostname of VM2.
  * "nevis": Hostname of VM2.
    * Or: Add "nevis" to */etc/hosts* on VM2 and on the device where the browser runs.

* RPM-based installation, all on the same VM:

  * "nevisadmin4": Hostname of the VM.
  * "nevisproxy": Hostname of the VM.
  * "nevis": Hostname of the VM.
    * Or: Add "nevis" to */etc/hosts* on the VM and on the device where the browser runs.

## Tutorial: Setting Up nevisProxy with nevisAdmin 4

The following steps will show you a basic example workflow of configuring and deploying your Nevis environment with nevisAdmin 4. It will guide you through the GUI to create your first patterns and thus configure a nevisProxy as a WAF.

The tutorial consists of the following tasks:

* Task 1: Creating Your First nevisAdmin 4 Project
* Task 2: Adding a Web Application
* Task 3: Protecting the Web Application with a nevisProxy WAF
* Task 4: Configuring the Infrastructure Components for nevisProxy
* Task 5: Deploying Your Configuration to nevisProxy
* Further Steps

:::info
Each task includes a movie that illustrates the steps to perform.
:::
--------------------------------------------------------------------------------
Section: ### Task 2: Adding a Web Application
As an example, we will protect the publicly available website [https://www.adnovum.ch](https://www.adnovum.ch/) with nevisProxy.

To create the necessary configuration with nevisAdmin 4, execute the following steps:

1. Click *New Web Application* in the *Get started with nevisAdmin 4* section.
2. Now you have a new pattern of the type *Web Application* in front of you. Each pattern comes with a *Pattern Editor* (visible in the middle part of the screen). In this editor, you configure the features of the pattern. We call the configuration options *properties*.
3. Click on the editor icon next to the pattern title on top of the *Pattern Editor*. Rename the pattern to "AdNovum Website".
4. Specify the following pattern properties in the corresponding fields:
    * In the *Basic Settings* tab:
      * *Frontend Paths*: "/adnovum-web/".
      All requests with this path will be forwarded to the application.
      * *Response Rewriting*: "complete".
      This configures nevisProxy to replace "/" in the request header and page body with "/adnovum-web/".
    * In the *Backend Connection* tab:
      * *Backend Addresses*: `http://www.adnovum.ch`.
      nevisProxy will use this URL to access the application.
      * *Trust Store*: "SwissSign CA".
      Because the backend `www.adnovum.ch` is secured with TLS, we need to add a truststore to nevisProxy with the root CA of the page's certificate. This enables nevisProxy to validate the certificate of the web application and use it as a backend. Execute the following steps:
        * Enter "SwissSign CA" in the drop-down menu of the *Trust Store* property.
        * Click *Add pattern 'SwissSign CA'*.
        * Select type *PEM Trust Store Provider*.
        * Click *Add pattern*.

5. Click *Save Changes*.

<img className="boxed" src={require('../assets/create-web-app.gif').default} alt="How to add a Web Application pattern" />

The public site `www.adnovum.ch` has an official certificate from SwissSign. nevisProxy needs to trust the certificate of this site to establish the TLS connection. Therefore, we add the CA to a PEM truststore:

1. Export the root CA of `https://www.adnovum.ch/` with your browser like shown in the movie.
2. Navigate to the newly added pattern *SwissSign CA*.
3. Attach the exported CRT file into the *Trusted Certificates: as file* field.
4. Save your modifications.

<img className="boxed" src={require('../assets/export-certificate.gif').default} alt="How to export CA and import to trust store" />

:::info
You have successfully created your first two patterns! By adding references between the patterns, you combine the various settings into one overall configuration. Our *AdNovum Website* pattern for example has a reference to the *SwissSign CA* pattern*.*
:::
--------------------------------------------------------------------------------
Section: ### Task 3: Protecting the Web Application with a nevisProxy WAF
After configuring the web application, we want to access it with nevisProxy as WAF in between, so we configure a virtual host for that:

1. Navigate back to the *AdNovum Website* pattern.
2. Enter "My nevisProxy Host" in the drop-down menu of the *Virtual Host* property.
3. Click *Add pattern 'My nevisProxy Host'*.
Click *Save changes* and follow the link to the newly added pattern "My nevisProxy Host".
4. The properties of the pattern "My nevisProxy Host" appear in the *Pattern Editor*. Specify the following properties of this pattern:

* *Frontend Addresses*: `https://nevis`.
      The property *Frontend Addresses* sets the external domain name hosted by your nevisProxy. In our example, we use `https://nevis`. Adapt this according to your Nevis setup.
* A nevisProxy host context must have a reference to a nevisProxy instance. You specify this reference in the property *nevisProxy*. Proceed as follows:
    1. Enter "My Proxy" in the drop-down menu field of the *nevisProxy* property.
    2. Click *Add pattern 'My Proxy'*.
    3. Click *Save changes* and follow the link to the newly added pattern "My Proxy".
    4. The properties of the pattern "My Proxy" appear in the *Pattern Editor*.
    Specify the following pattern property:
    *Deployment Target*: "proxies".
    This is where the proxy should run. Instead of defining a hostname, we enter a name of the hostgroup, here "proxies".
    The next section explains how to configure the host group.
    5. Click *Save changes*.

 <img className="boxed" src={require('../assets/Add-proxy.gif').default} alt="How to add a nevisProxy pattern" />
--------------------------------------------------------------------------------
Section: ### Protect-sub-application-paths.md
---
sidebar_position: 78
---

# Protect sub-application paths

This page describes two cases of protecting an application with **Frontend Path** `/app/`.

## The path /app/sub/ belongs to another application

If the path `/app/sub/` belongs to another application, that is, points to another backend server, simply add another application pattern (for example, a **Web Application**) and set **Frontend Path** to `/app/sub/`.

When a request comes in, nevisProxy first determines the most specific servlet, and then calculates the filter chain.

For filters with a known purpose (for example, authentication), nevisAdmin 4 automatically generates the required `exclude-url-regex` for filters mapped to `/app/`, thus avoiding that they are applied to `/app/sub/` as well.

Filtering inheritance may break the application isolation, and therefore nevisAdmin 4 ensures that filters are excluded for sub-paths belonging to other applications whenever possible.

## The path /app/sub/ is sensitive, and should not be accessible

Assign an **Access Restriction** pattern to the application using **Additional Settings**.

Configure it to block all IP addresses, and set the property **Apply only to sub-paths** to `sub/`.
--------------------------------------------------------------------------------
Section: ### nevisProxy Instance Pattern
The *nevisProxy Instance* pattern sets up an empty instance of nevisProxy.

You have to use the *Virtual Host* pattern to add a *web.xml* file and the required connector configuration.

Additionally, you can assign the *Generic nevisProxy Settings* add-on pattern to adapt low-level settings in the *navajo.xml* file.

Additional add-on patterns are planned for future releases (for example, for nevisProxy sizing).
--------------------------------------------------------------------------------
Section: ### Service Patterns
Patterns that implement the Service interface are used to make content accessible via nevisProxy.

The *Hosting Service* pattern facilitates the deployment of static pages on nevisProxy over a certain path.

Service access patterns support the integration of backend applications.  nevisAdmin 4 provides the following service access patterns:

* *Web Application*: Used for classic web applications (e.g., form-based) and hybrid applications. CSRF protection and ModSecurity are enabled by default.
* *REST Service*: Used for REST APIs. Basic JSON validation is enabled by default.
* *SOAP Service*: Used for SOAP APIs. Schema validation using WSDL is in development for nevisAdmin 4.2.

See [First Steps](../quickstart-appliance) on how to use these patterns to integrate an application.
--------------------------------------------------------------------------------
Section: ### Add-On Patterns
Several add-on patterns facilitate application protection. You can assign these add-on patterns to the following patterns:

* *Virtual Host* pattern - Assign an add-on to this pattern to change the behavior of the root location. This affects all services.
* Service patterns - Assign an add-on to a service pattern if you want to configure a feature for this service only. Service patterns are, for example, *REST Service* and *SOAP Service*.

Technically, assigning an add-on to a pattern is possible under the following conditions:
* The add-on pattern implements the *PathLocationAddon* interface, and
* the pattern supports the *PathLocation* interface.
* See also the figure: Application Protection patterns above.

The add-ons are mostly used to enable WAF features. Example add-ons are:

* *Access Restriction*: Use this add-on to white- or blacklist IPs.
* *ICAP Scanning*: Use this add-on to perform a virus scan of uploaded files.
* *Request Validation Settings*: Use this add-on to fine-tune the request validation by changing the configuration of ModSecurity.

See: [Standard Patterns Reference](../../../nevisadmin4/Appendixes/Standard-Patterns-Reference) for a complete list of the add-on patterns.

## What if my Use Case is not Covered by the Standard?

If your use case is not covered by the standard patterns, contact Nevis Support and explain your case. The nevisProxy patterns are in active development and we are interested in your requirements.

In the meantime you have several options:

* Customize the settings in the *navajo.xml* file with the *Generic nevisProxy Settings* pattern. The *Help* page of this pattern explains which cases are supported.
* Adapt the configuration in the *web.xml* file with the *Generic Virtual Host Settings* pattern or the *Generic Application Settings* pattern.
* Solve complex use cases with the Lua script, by means of the *Lua HTTP Processing* pattern.

## How to configure the nevisProxy examples with nevisAdmin 4?

The examples provided in the nevisProxy documentation and in the installed package under `/opt/nevisproxy/examples/` cover several aspects of a typical nevisProxy configuration.
They fall into three broad categories:
--------------------------------------------------------------------------------
Section: ### Examples with LuaFilters
Several examples show how to configure one or several LuaFilters to perform certain tasks.
The reason for using a LuaFilter can be that the use case is too specific to have its own filter, or that the process has to be fine-tuned for the target installation.
Let us know if you use one of the LuaFilter examples in your configuration.
We may create a dedicated filter or pattern for the widespread ones.

Proceed as follows to configure a *Lua HTTP Processing* pattern from an existing LuaFilter:

- Add a *Lua HTTP Processing* pattern to your configuration;
- Copy the content of the `Script` parameter from the LuaFilter in the *Lua Script* setting;
- Check that the names of the functions to be invoked for the requests and responses match the list in the description of the *Lua Script* setting;
- If the LuaFilter includes parameters, rename them in the script with the prefix `param_` and list them in the *Script Parameters* setting;
- Replace the placeholders as described in [Placeholders in the examples and default values](../../../nevisproxy/Placeholders-in-the-examples-and-default-values), generally:
  - `@PKG_HOME@` &rarr; `/opt/nevisproxy`
  - `@PKG_VAR@` &rarr; `/var/opt/nevisproxy`
  - `@PKG_INSTANCE@` &rarr; name of the nevisProxy instance
- Set the *Filter Phase* if your filter should be invoked during a specific processing step;
- Link the pattern to the *Additional Settings* of the target *Application* or *Virtual Host* pattern(s).
--------------------------------------------------------------------------------
Section: ### Filter-Mapping-Concepts.md
---
sidebar_position: 83
---

# Filter Mapping Concepts

Several nevisAdmin 4 patterns configure filters for nevisProxy. These filters have to be applied to requests and/or responses. For this, you need to configure *filter-mapping* elements in a nevisProxy *web.xml* file.

This chapter describes how patterns generate the *filter-mapping* elements, based on examples.

## Filter Inheritance

Suppose there is a nevisAdmin 4 project containing the following patterns:

<img className="boxed" src={require('../../../assets/50823525.png').default} alt="nevisAdmin 4 Test project with patterns"/>

This project sets up a nevisProxy instance with one virtual host serving the domain `www.mycompany.com`.

By default, the *Virtual Host* pattern sets up an *ErrorFilter* to handle HTTP error codes (such as the 404 Not Found code, or the 500 Internal Server Error code). This default error filter *ErrorHandler_Default* is applied to the root location via the following *filter-mapping* element:

```script title="Root Location Filter Mapping"
<filter-mapping>
 <filter-name>ErrorHandler_Default</filter-name>
 <url-pattern>/*</url-pattern>
</filter-mapping>
```

Because `/*` matches all paths, the default error filter is applied to all requests and responses: The filter is **inherited** to all sub-locations.

Filters are always inherited by default.

## Duplicated Filter Problem

Patterns often want to apply filters to specific sub-locations. This can cause the Duplicated Filter Problem. The following sample case illustrates this problem.

Suppose you have the following *Web Application* pattern:

<img className="boxed" src={require('../../../assets/50823527.png').default} alt="Sample Web Application pattern"/>

You want to give this application a different error handling: In case of an HTTP 404 Not Found error code, the application will return a nicer page than the default error page. In nevisAdmin 4, you can realize this by configuring a custom *HTTP Error Handling* pattern and assigning this pattern to the virtual host, via the *Additional Settings* field of the *Virtual Host* pattern:

<img className="boxed" src={require('../../../assets/50823524.png').default} alt="Assigning Error Handling pattern to Virtual Host pattern"/>

The *HTTP Error Handling* pattern "Custom 404" in the previous figure generates the following *filter-mapping* element, mapping the custom error filter *ErrorHandler_Custom_404* to `/myapp/*`:

```script title="Sub-location Filter Mapping"
<filter-mapping>
 <filter-name>ErrorHandler_Custom_404</filter-name>
 <url-pattern>/myapp/*</url-pattern>
</filter-mapping>
```

But: The *Virtual Host* pattern already maps the default error filter *ErrorHandler_Default* to `/*`. This means that error handling would be done twice for requests sent to your application. This is what we call the Duplicated Filter Problem.

## Filter Purpose Exclusion Mechanism

To solve the Duplicated Filter Problem, nevisAdmin 4 provides the *filter purpose exclusion* mechanism: When you declare a *purpose* for a filter, the nevisProxy generator automatically generates an *exclude-url-regex* expression for *filter-mapping* elements.

This algorithm works as follows:

* When generating a filter *F*, patterns can set a purpose for this filter.
* When *F* is mapped to a parent location *P* and a sub-location *C*, a regular expression *R* for *C* is generated.
* *R* is added to the *exclude-url-regex* of the *filter-mapping* for *F* at *P*.

Because of this *filter purpose exclusion* mechanism, the *filter-mapping* element for the default error filter *ErrorHandler_Default* of our example changes as follows:

```script title="Root Location Filter Mapping"
<filter-mapping>
 <filter-name>ErrorHandler_Default</filter-name>
 <url-pattern>/*</url-pattern>
 <exclude-url-regex>^/myapp/.*$</exclude-url-regex>
</filter-mapping>
```

As of nevisAdmin 4.6, the *filter purpose exclusion* mechanism is applied for the following use cases (patterns):

* HTTP Error Handling
* Request Validation (ModSecurity)
* CSRF Protection
--------------------------------------------------------------------------------
Section: ### Protecting-a-Web-Application.md
---
sidebar_position: 79
---

# Protecting a Web Application

The chapter [First Steps](../../quickstart-appliance) describes in detail how to make a web application accessible via nevisProxy. Depending on the type of application, you use one of the following patterns:

* *Web Application* pattern:
  * Suitable for form-based web applications as well as for hybrid applications consisting of a single-page application and REST API.
  * Provides simple header-based CSRF protection by default.
  * Provides ModSecurity with OWASP Core Rule Set by default.
  * You can customize the CSRF protection and the ModSecurity rules directly in the *Web Application* pattern screen:
    * CSRF protection: Select "custom" from the drop-down menu in the *Security: CSRF Protection* field, then assign and configure the add-on pattern *CSRF Protection Settings* via the *Additional Settings* field.
    * ModSecurity rules: Select "custom" from the drop-down menu in the *Security: Request Validation* field, then assign and configure the add-on pattern *Request Validation Settings* via the *Additional Settings* field.
* *REST Service* pattern:
  * Used for stand-alone REST APIs.
  * Will have options for CORS in future releases.
* *SOAP Service* pattern:
  * Will have options for schema validation in future releases.

:::note
You can add extra security features to all patterns in the GUI, by assigning add-on patterns via the *Additional Settings* field. You can find this field on the bottom of the screen where you configure the pattern.
:::
--------------------------------------------------------------------------------
Section: ### Upgrading-the-provided-OWASP-Core-Rule-Set-of-ModSecurity.md
---
sidebar_position: 80
---

# Upgrading the provided OWASP Core Rule Set of ModSecurity

## Introduction

The **Virtual Host** pattern provides the setting **OWASP ModSecurity CRS version**, where you can either select a pre-configured version of the Core Rule Set, or choose the **custom** option, and provide a customized rule bundle. The preconfigured versions include only slight changes compared to the official Core Rule Set releases.

In case you prefer to customize the Core Rule Set, the following guide describes how to create a rule bundle for the **Virtual Host** pattern, based on the Core Rule Set version 3.3.4 with ModSecurity engine version 3.0.8.

## Step 1: Set up the `modsecurity.conf`

First, create a new directory and download the default [`modsecurity.conf-recommended`](https://raw.githubusercontent.com/SpiderLabs/ModSecurity/v3.0.8/modsecurity.conf-recommended) file. The version of this file should match the version of the ModSecurity engine shipped with nevisProxy. Rename the configuration file to `modsecurity.conf` and apply the following changes:

1. Set the `SecRuleEngine` to `On`, which enables blocking requests.
2. In the file system configuration section, adapt the location where ModSecurity stores temporary files. This way admin4 will generate a proper instance level location for these files. Edit the following lines:
3. Replace `SecTmpDir /tmp/` with `${tmp_dir}`
4. Replace `SecDataDir /tmp/` with `${data_dir}`
5. Replace `SecAuditLog /var/log/modsec_audit.log` with `${audit_log}`
6. Comment out the rule `SecUnicodeMapFile unicode.mapping 20127` as it can fail the startup process if the file is not provided.
7. Finally, at the very end, insert the following line to include the CRS configuration file (which will be created in the second step):

```
Include crs-setup.conf
```
--------------------------------------------------------------------------------
Section: ### Recommended scaling considerations
* Adapt the `SecRequestBodyLimit` and `SecRequestBodyNoFilesLimit` parameters to your environment. For example:

```
SecRequestBodyLimit 104857600
SecRequestBodyNoFilesLimit 10485760
```

* The default value of `SecPcreMatchLimit` and `SecPcreMatchLimitRecursion` parameters may be too low for real world applications. To avoid false positives, they can be increased to the following values:

```
SecPcreMatchLimit 100000
SecPcreMatchLimitRecursion 100000
```

* If there are requests still exceeding the above limits, instead of blocking the request, a warning can be traced by adapting the following rule:

```
SecRule TX:/^MSC_/ "!@streq 0" \
 "id:'200005',phase:2,t:none,deny,msg:'ModSecurity internal error flagged: %{MATCHED_VAR_NAME}'"
```

To:

```
SecRule TX:MSC_PCRE_LIMITS_EXCEEDED "@eq 1" \
 "id:'200005',phase:5,t:none,log,pass,msg:'PCRE match limits were exceeded.'"
```

* Disable the `SecAuditEngine` by setting it to `Off`, as the navajo.log in nevisProxy already traces the necessary information.
* Disable sharing information by setting `SecStatusEngine` to `Off`.

## Step 2: Set up the Core Rule Set

Download the latest stable release of the [Core Rule Set](https://github.com/coreruleset/coreruleset/releases), and extract it. Move the following to the above created directory:

* `crs-setup.conf.example`, and rename it to `crs-setup.conf`
* The whole rules folder with all of its content, except the two exclusion file examples:
  * REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example
  * RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example

Once done, adapt the `crs-setup.conf` to your needs.

We recommend reviewing rule 900200 as the list of allowed HTTP methods is rather restrictive by default.

Finally, to include the rules from the `rules` folder, we need a new file named `rules.conf`, with the following content:

```
Include rules/REQUEST-901-INITIALIZATION.conf
Include rules/REQUEST-903.9001-DRUPAL-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9002-WORDPRESS-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9003-NEXTCLOUD-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9004-DOKUWIKI-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9005-CPANEL-EXCLUSION-RULES.conf
Include rules/REQUEST-903.9006-XENFORO-EXCLUSION-RULES.conf
Include rules/REQUEST-905-COMMON-EXCEPTIONS.conf
Include rules/REQUEST-910-IP-REPUTATION.conf
Include rules/REQUEST-911-METHOD-ENFORCEMENT.conf
Include rules/REQUEST-912-DOS-PROTECTION.conf
Include rules/REQUEST-913-SCANNER-DETECTION.conf
Include rules/REQUEST-920-PROTOCOL-ENFORCEMENT.conf
Include rules/REQUEST-921-PROTOCOL-ATTACK.conf
Include rules/REQUEST-922-MULTIPART-ATTACK.conf
Include rules/REQUEST-930-APPLICATION-ATTACK-LFI.conf
Include rules/REQUEST-931-APPLICATION-ATTACK-RFI.conf
Include rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf
Include rules/REQUEST-933-APPLICATION-ATTACK-PHP.conf
Include rules/REQUEST-934-APPLICATION-ATTACK-NODEJS.conf
Include rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf
Include rules/REQUEST-942-APPLICATION-ATTACK-SQLI.conf
Include rules/REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION.conf
Include rules/REQUEST-944-APPLICATION-ATTACK-JAVA.conf
Include rules/REQUEST-949-BLOCKING-EVALUATION.conf
Include rules/RESPONSE-950-DATA-LEAKAGES.conf
Include rules/RESPONSE-951-DATA-LEAKAGES-SQL.conf
Include rules/RESPONSE-952-DATA-LEAKAGES-JAVA.conf
Include rules/RESPONSE-953-DATA-LEAKAGES-PHP.conf
Include rules/RESPONSE-954-DATA-LEAKAGES-IIS.conf
Include rules/RESPONSE-959-BLOCKING-EVALUATION.conf
Include rules/RESPONSE-980-CORRELATION.conf
```

At the end, the directory should have the following structure:

```
├── crs-setup.conf
├── modsecurity.conf
├── rules
│   ├── crawlers-user-agents.data
│   ├── iis-errors.data
│   ├── java-classes.data
│   ├── java-code-leakages.data
│   ├── java-errors.data
│   ├── lfi-os-files.data
│   ├── php-config-directives.data
│   ├── php-errors.data
│   ├── php-function-names-933150.data
│   ├── php-function-names-933151.data
│   ├── php-variables.data
│   ├── REQUEST-901-INITIALIZATION.conf
│   ├── REQUEST-903.9001-DRUPAL-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9002-WORDPRESS-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9003-NEXTCLOUD-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9004-DOKUWIKI-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9005-CPANEL-EXCLUSION-RULES.conf
│   ├── REQUEST-903.9006-XENFORO-EXCLUSION-RULES.conf
│   ├── REQUEST-905-COMMON-EXCEPTIONS.conf
│   ├── REQUEST-910-IP-REPUTATION.conf
│   ├── REQUEST-911-METHOD-ENFORCEMENT.conf
│   ├── REQUEST-912-DOS-PROTECTION.conf
│   ├── REQUEST-913-SCANNER-DETECTION.conf
│   ├── REQUEST-920-PROTOCOL-ENFORCEMENT.conf
│   ├── REQUEST-921-PROTOCOL-ATTACK.conf
│   ├── REQUEST-922-MULTIPART-ATTACK.conf
│   ├── REQUEST-930-APPLICATION-ATTACK-LFI.conf
│   ├── REQUEST-931-APPLICATION-ATTACK-RFI.conf
│   ├── REQUEST-932-APPLICATION-ATTACK-RCE.conf
│   ├── REQUEST-933-APPLICATION-ATTACK-PHP.conf
│   ├── REQUEST-934-APPLICATION-ATTACK-NODEJS.conf
│   ├── REQUEST-941-APPLICATION-ATTACK-XSS.conf
│   ├── REQUEST-942-APPLICATION-ATTACK-SQLI.conf
│   ├── REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION.conf
│   ├── REQUEST-944-APPLICATION-ATTACK-JAVA.conf
│   ├── REQUEST-949-BLOCKING-EVALUATION.conf
│   ├── RESPONSE-950-DATA-LEAKAGES.conf
│   ├── RESPONSE-951-DATA-LEAKAGES-SQL.conf
│   ├── RESPONSE-952-DATA-LEAKAGES-JAVA.conf
│   ├── RESPONSE-953-DATA-LEAKAGES-PHP.conf
│   ├── RESPONSE-954-DATA-LEAKAGES-IIS.conf
│   ├── RESPONSE-959-BLOCKING-EVALUATION.conf
│   ├── RESPONSE-980-CORRELATION.conf
│   ├── restricted-files.data
│   ├── restricted-upload.data
│   ├── scanners-headers.data
│   ├── scanners-urls.data
│   ├── scanners-user-agents.data
│   ├── scripting-user-agents.data
│   ├── sql-errors.data
│   ├── unix-shell.data
│   └── windows-powershell-commands.data
└── rules.conf
```

Compress the content of the directory into a zip file, for example:

```
zip -r modseccrs.zip ./*
```

and upload the archive to the **Virtual Host** pattern.
--------------------------------------------------------------------------------
Section: ### PEM-Based-Key-Management.md
---
sidebar_position: 130
---

# PEM-Based Key Management

The *PEM Key Store* and *PEM Trust Store* patterns support the upload of key material in PEM format into nevisAdmin 4.

The key material can either be inserted into a text field or uploaded as PEM files. In both cases, you can use variables to store the content in the inventory instead.

The keys are automatically converted into JKS and PKCS12. Up to and including nevisAdmin 4.8, these files are re-generated on each deployment and thus there are always changes.

The key material will be deployed using the same folder structure as the one for the automatic key management.

Pros:

* Complete deployment of a keystore/truststore.
* Use the same content on multiple hosts.

Cons:

* KS and P12 files are created during generation. As these files contain timestamps, they change on each deployment.
* As nevisAdmin 4 is the master of the entire keystore content, the private key will be deployed as well.

Consider using this pattern when you need a simple solution for the complete deployment of a keystore/truststore and do not mind the limitations.

<img className="boxed" src={require('../../assets/pem.gif').default} alt="How to upload trusted certificates in PEM format"/>
--------------------------------------------------------------------------------
Section: ### Automatic-Key-Management.md
---
sidebar_position: 129
---

# Automatic Key Management

nevisAdmin 4 can automatically generate key material for Nevis components. Automatic key management is a convenience feature which allows you to deploy without concern for keystore and truststore content.

If you have complex requirements, consider the following alternatives:

* PEM-Based Key Management
* nevisKeybox-Based Key Management (classic deployment only)

The properties of automatic key management are as follows:

Pros:

* Keys are created on the target host / inside the Kubernetes cluster and never leaves those systems.
* Easier to get started as less configuration is required.
* One shot deployment in case the entire project is deployed.

Cons:

* Does not support using the same key on multiple hosts / for different services.
* Limited configuration options.
* Partial deployment of a project can lead to incomplete truststore content.
* In classic, not all failure cases (for example deleted files or expired CA) can be fixed in one deployment. Multiple deployments may be required.

To enable automatic key management, first set the following global variable in your inventory.

```
vars:
  __nevisadmin_pki_automatic_enabled: true
```

By default, it is not required to add keystore/truststore patterns to your project. The required keystores and truststores will be generated automatically (implicit mode).

As of nevisAdmin version 4.5, you can set the following variables to force users to assign *Automatic Key Store* / *Automatic Trust Store* patterns wherever a keystore/truststore is needed:

```
vars:
  __nevisadmin_pki_automatic_enabled: true
  __nevisadmin_pki_automatic_allowed_mode: explicit
```

## Deployment Scenarios

Automatic key management works differently in classic VM and Kubernetes deployments. This section highlights the differences.
--------------------------------------------------------------------------------
Section: #### Enforcing the Renewal of nevisAdmin 4 CA
As of nevisAdmin 4.6, there is no GUI or REST API to control the CA. The only way to exchange the CA is via the database.

nevisAdmin 4 will automatically create a new CA when no CA is found in the database. Associated certificates will be re-created with the next deployment. You can therefore just delete the CA in the database. Run the following SQL commands on the nevisAdmin 4 host:

```
# stop nevisAdmin 4
[root@nevisadmin4 ~]# nevisadmin4 stopService

# connect to the database as configured in /var/opt/nevisadmin4/conf/nevisadmin4.yml
[root@nevisadmin4 ~]# mysql -u <user> -p<password>

MariaDB [(none)]> use nevisadmin4;

# delete the nevsiAdmin 4 CA
MariaDB [nevisadmin4]> delete from ca;

# delete all the stored certificates to enforce that they are created again
MariaDB [nevisadmin4]> delete from pki_store_content;
MariaDB [nevisadmin4]> commit;
MariaDB [nevisadmin4]> quit

# start nevisAdmin 4
[root@nevisadmin4-dev ~]# nevisadmin4 startService
```

## Explicit Usage

Wherever a keystore / truststore is needed, you can assign the *Automatic Key Store* / *Automatic Trust Store* patterns to make the automatic key management explicit.

Further, explicit assignment is required in some patterns to enforce the use of 2-way TLS:

* Assign an *Automatic Key Store* to use a client certificate for outbound TLS connections.
* Assign an *Automatic Trust Store* to set up a truststore to validate incoming connections.
--------------------------------------------------------------------------------
Section: ### Linking an Automatic Trust Store with Automatic Key Store(s)
In the *Automatic Trust Store* you can assign one or multiple *Automatic Key Store* patterns via *Trusted Key Stores*. Use this method to inform nevisAdmin 4 about a trust relation. nevisAdmin 4 will make sure that any certificate issued for that keystore is automatically trusted. This is often required when using generic patterns, for example *Generic Authentication Realm* or *Generic Authentication Step,* which perform outbound TLS connections, create or validate tokens.

<img className="boxed" src={require('../../assets/1.gif').default} alt="How to link an automatic truststore with an automatic keystore"/>
--------------------------------------------------------------------------------
Section: ### Truststore
A *truststore* may contain:

* CA certificate(s) for trust validation (TLS)
* Certificate(s) used to validate signed tokens

For trust validation during a TLS handshake the truststore must contain the CA (or a parent thereof) which has issued the certificate of the other party.

For signature validation the truststore must contain the signer certificate.

## Patterns for Key Management

Patterns that require a keystore or truststore have dedicated references, which allow you to assign a pattern that provides the keystore / truststore.

The standard pattern library provides the following patterns for key management:

* *Automatic Key Store*/ *Automatic Trust Store:* See the chapter [Automatic Key Management](Automatic-Key-Management.md).
  * These patterns can be used in classic VM and Kubernetes deployments. nevisAdmin 4 automatically sets up the keystore / truststore during deployment. This is the default behavior when no pattern is assigned.
* *nevisKeybox Store:* See the chapter [nevisKeybox-Based Key Management](nevisKeybox-Based-Key-Management.md).
  * The *nevisKeybox Store* pattern can act as keystore or truststore or both. This pattern can be used for classic deployments only. The pattern requires that nevisKeybox is installed and an instance named *default* has been created on the target hosts. nevisAdmin 4 does not deploy into nevisKeybox. You have to manage the content manually using the *neviskeybox* command-line interface.
* *PEM Key Store* / *PEM Trust Store:* See the chapter [PEM-Based Key Management](PEM-Based-Key-Management.md).
  * These patterns can be used in classic and Kubernetes deployments. The key material is uploaded in PEM format in the pattern or via the inventory. Formats for Java-based components (JKS and PKCS12) are generated automatically. The files are deployed by nevisAdmin 4 and will be exposed to Nevis components.
--------------------------------------------------------------------------------
Section: ### Setting-Up-a-SAML-Identity-Provider.md
---
sidebar_position: 96
---

# Setting Up a SAML Identity Provider

## Preconditions

* You need a *Realm* pattern that defines the process for initial authentication. See Configuring LDAP Login for Web Application for an example configuration.

* To use the IDP, you have to integrate at least one SP. You need the following information about the SP:
  * The signer certificate
  * The SP issuer
  * The Assertion Consumer Service URL (used for IDP-initiated authentication only)
--------------------------------------------------------------------------------
Section: #### Realm Patterns
You can add a new *Realm* pattern, or reuse an existing *Realm* pattern. The *SAML IDP* pattern just exposes the realm as an authentication service via nevisProxy.

If you add a new pattern, you can pick any kind of *Realm* pattern.  The *Authentication Realm* is usually the most convenient choice because it offers many standardized configuration options.


## Quick Start

Perform the next steps to set up a SAML IDP.

1. Configure the *SAML IDP* pattern as follows:
   1. Enter a value for the SAML issuer in the *SAML Issuer* field.
      1. The SP needs this information to validate SAML responses.
      2. Some SPs require the issuer to be a URL that points to the IDP.
   2. Enter at least one frontend path in the *Frontend Paths* field, or use the default.
   3. Assign a *SAML SP Connector* pattern to the *SAML SP Connector(s)* field.
   4. Configure the SAML signer in the *SAML Signer* field, by assigning an (*Automatic) Key Store* pattern.
   5. Assign a *Virtual Host* pattern to the *Virtual Host* field. The assigned *Virtual Host* pattern defines where to make the frontend path accessible.
   6. In the *Authentication Realm* field, specify an *Authentication Realm* pattern that provides the authentication flow.
2. Configure the *SAML SP Connector* pattern as follows:
   1. Enter the SP issuer in the *SP Issuer* field.
   2. Establish SP signer trust by assigning a truststore provider pattern, such as an *Automatic Trust Store* pattern, to the *SP Signer Trust* field.

:::note Step 2
Describes how to configure the *SAML SP Connector* pattern. You can also have a look at the pattern on the right in the next figure.
:::
--------------------------------------------------------------------------------
Section: ### Automatic Key Management
For test setups and in case the SP is defined in the same nevisAdmin 4 project, you can use automatic key management. Proceed as follows:

* Assign an *Automatic Trust Store* pattern to the *SP Signer Trust* field of the *SAML SP Connector* pattern.
* Link the *Automatic Trust Store* pattern with the automatic keystore used by the SP, by assigning the relevant *Automatic Key Store* pattern to the *Trusted Key Stores* field of the *Automatic Trust Store* pattern.

For production setups, either use the *nevisKeybox Store* pattern, or the *PEM Trust Store / PEM Key Store* provider patterns.
--------------------------------------------------------------------------------
Section: ### Use-SAML-Authentication-for-a-Web-Application.md
---
sidebar_position: 97
---

# Configuring SAML Authentication for a Web Application

## Preconditions

* Make sure your application is accessible via nevisProxy as explained in [Protecting a Web Application](../../../Application-Protection/Protecting-a-Web-Application/Protecting-a-Web-Application).
* Make sure you have the following information about your IDP at hand:
  * The Issuer (also known as Entity ID) that uniquely identifies the IDP.
  * The certificate used by the IDP to sign SAML messages.
  * The Single-Sign-On URL.
--------------------------------------------------------------------------------
Section: ### Supported IDPs
You can integrate a third-party SAML Identity Provider (IDP) or set up your own as described in Setting Up a SAML Identity Provider.

## Quick Start

Authentication via SAML (Web Browser SSO) requires:

* The configuration of a SAML Service Provider (SP).
* The integration of the SP with the IDP.

Perform the next steps:

1. In the relevant *Web Application* pattern:
   1. Attach a *SAML SP Realm* pattern to the *Authentication Realm* field.
2. To configure the *SAML SP Realm* pattern:
   1. Go to the *nevisAuth Connection* tab and attach a *nevisAuth Instance* pattern to the *nevisAuth* field.
   2. Open the *Basic Settings* tab and make the following configurations:
      1. Enter an arbitrary value for the SAML issuer in the *SAML Issuer* field. Inform your IDP about the value you have chosen.
      2. Assign a *Key Store* pattern to the *SAML Signer* (field). By specifying the keystore, you define which key material to use for signing the outgoing SAML messages.
      3. Assign a *SAML IDP Connector* pattern to the *SAML IDP Connector(s)* field. See the next step for more information on how to configure the *SAML IDP Connector* pattern.
3. To configure the *SAML IDP Connector* pattern:
   1. Enter the IDP Issuer in the *IDP Issuer* field. To find out the correct value of the IDP Issuer, either check the metadata of the IDP, or base64-decode a received SAML Response.
   2. Enter the URL of the IDP in the *IDP URL* field. The SP may invoke the authentication process by sending an *AuthnRequest* SAML message to this URL.
   3. Assign a relevant truststore pattern to the *IDP Signer Trust* field. Depending on the type of truststore pattern, you have to do additional configuration.
--------------------------------------------------------------------------------
Section: ### Automatic Key Management
For testing purposes and if the IDP is configured in the same nevisAdmin 4 project, you can use automatic key management. Proceed as follows:

* *SAML SP Realm* pattern: Assign an *Automatic Key Store* pattern to the *SAML Signer* field.
* *SAML IDP Connector* pattern: Assign an*Automatic Trust Store* pattern to the *IDP Signer Trust* field.
* *Automatic Trust Store* pattern: Enter the *Automatic Key Store* pattern used by the IDP in the *Trusted Key Stores* field.

For production setups, either use the *nevisKeybox Store* pattern, or the *PEM Trust Store / PEM Key Store* provider patterns.

The following figure shows a sample configuration for all patterns involved:

<img className="boxed" src={require('../../../../assets/50823290.png').default} alt="Use SAML for a Web application - patterns with settings"/>

## Session Upgrade

For SP-initiated authentication, the SP sends a SAML *AuthnRequest* to the IDP. This *AuthnRequest* contains the following element:

```
<samlp:RequestedAuthnContext>
 <saml:AuthnContextClassRef>urn:nevis:level:1</saml:AuthnContextClassRef>
</samlp:RequestedAuthnContext>
```

This *RequestedAuthnContext* element defines the minimum required authentication level. If you want to demand a higher authentication level, you can assign an Authorization Policy to your application. When the session is not at this level yet, the SP will send an additional *AuthnRequest* to the IDP.
--------------------------------------------------------------------------------
Section: ### Supported-SAML-Flows.md
---
sidebar_position: 98
---

# Supported SAML Flows

## Overview

You can configure the following SAML flows:

* SAML Flows for Authentication
* SAML Flow for Session Upgrade
* SAML Flows for Logout

Configuring flows other than the ones above is not supported.

For information on how to configure the corresponding patterns, see:

* Setting Up a SAML Identity Provider (IDP)
* Configuring SAML Authentication for a Web Application (SP)

The patterns generate a configuration for nevisAuth, in particular for AuthState elements. This means that the nevisAuth documentation for these AuthStates applies as well. In some cases, you may not be able to configure certain AuthState properties via the patterns. If you run into such issues, raise a support ticket and explain your use case.

## Sample Setup

To describe the supported SAML flows, we use the following sample setup with two domains:

* `http://www.siven.ch`
  * Hosts a web application that requires authentication.
  * Authentication is enforced by a SAML Service Provider (SP).
* `http://sso.siven.com/`
  * Provides Single-Sign-On (SSO) for applications.
  * Hosts the SAML Identity Provider (IDP).

Nevis acts both as SP and as IDP.  But you can also use Nevis just for one party. For example, if the web application supports SAML out-of-the-box, the use of Nevis for the SP may not be required. However, Nevis can provide added value:

* **Perimeter authentication**
  * Authentication (and authorization) can be enforced by nevisProxy before the request reaches the application.
* **Support for multiple IDPs**
  * The IDP may be determined automatically based on complex custom criteria (for example, the source IP of the user or the current URL).
  * Support for IDP selection by the user is not available yet. Contact Nevis if you are interested in this feature.
--------------------------------------------------------------------------------
Section: ### SAML-Flows-for-Logout.md
---
sidebar_position: 91
---

# SAML Flows for Logout

This chapter describes the supported flows for SAML logout based on our sample setup. The SAML logout flows are best-effort; successful execution cannot be guaranteed.

Be aware of the following limitations:

1. SAML SPs must use the same endpoints for their *assertionConsumerService* and their *singleLogoutService*.
   1. This is the case if the SP is provided by Nevis, but can be problematic when integrating a third-party SP.
   2. Contact support if you want to integrate an SP that requires the use of different URLs for these two endpoints.
2. There is no feedback to the user if the session was successfully terminated for all affected parties.
   1. This can be improved by adapting the Javascript that is included in the default nevisLogRend template (see *macros.vm*).
3. The internal *nevisProxy Login Renderer* pattern cannot be used as it is not able to inject the Javascript required to distribute SAML messages.
   1. Use the *nevisLogrend* pattern instead if you want to support SAML logout flows.

## IDP-Initiated SAML Logout

<img className="boxed" src={require('../../../../assets/53124465.png').default} alt="IDP-initiated SAML logout flow"/>

IDP-initiated SAML logout works as follows (the numbers of the steps below correspond with the numbers in the figure above):

1. Logout is initiated by sending any HTTP request to a logout location of the SAML IDP. The SAML IDP provides two such locations:
   1. `<path>/logout` - logout with confirmation
   2. `<path>/?logout` - logout without confirmation
   3. Here `<path>` stands for any *Frontend Path* entered in the *SAML IDP* pattern.
2. The SAML IDP responds as follows:
   1. The *IdentityProviderState* produces an *AUTH_CONTINUE* response that contains a GUI descriptor.
   2. nevisLogRend transforms the GUI descriptor into an HTML page.
   3. nevisLogRend adds some Javascript (see *macros.vm*), which takes care of the remainder of this flow.
3. The browser sends a *LogoutRequest* message to each SP that has participated in this session.
   1. The requests are sent in parallel using AJAX calls.
   2. The *LogoutRequest* is included as a query parameter *SAMLRequest*.
   3. The SP terminates the session of the user.
   4. The SP clears any additional cookies used to detect expired sessions. See the *Session Expiration* features in the *SAML SP Realm* pattern.
   5. The SP returns a *LogoutResponse.* The default Javascript simply ignores these messages.
4. Once all SPs have been informed, the user is sent to a logout URL.
   1. The default logout URL is the root location ( */* ) of the virtual host that runs the SAML IDP.
   2. You can use the *Logout* pattern to change the logout URL.

## SP-Initiated SAML Logout

<img className="boxed" src={require('../../../../assets/53124468.png').default} alt="SP-initiated SAML logout"/>

SP-initiated SAML logout works as follows (the numbers of the steps below correspond with the numbers in the figure above):

1. Logout is initiated by sending a request to an application URL with the query parameter *logout*.
   1. Example: `https://www.siven.ch/myapp/?logout`
   2. The request is intercepted by nevisProxy and does not reach the application.
   3. The IDP is determined and the corresponding *ServiceProviderState* returns a *LogoutRequest.*
2. The browser is instructed to send a *LogoutRequest* to the SAML IDP.
   1. This request is typically sent using a POST request.
   2. The request is validated by the SAML IDP (*IdentityProviderState*).
3. The SAML IDP answers as follows:
   1. The *IdentityProviderState* produces an *AUTH_CONTINUE* response which contains a GUI descriptor.
   2. nevisLogRend transforms the GUI descriptor into an HTML page.
   3. nevisLogRend adds some Javascript (see *macros.vm*), which takes care of the remaining flow.
4. The browser sends a *LogoutRequest* message to each additional SP that has participated in this session.
   1. The requests are sent in parallel via AJAX calls.
   2. The *LogoutRequest* is added as a query parameter *SAMLRequest*.
   3. The SP terminates the session of the user.
   4. The SP clears any additional cookies used to detect expired sessions.
   5. The SP returns a *LogoutResponse.* The default Javascript just ignores these responses.
5. The session is terminated at the IDP by sending an additional request with *?logout* attached.
   1. This request is also sent in the background using an AJAX call.
   2. This is required to ensure that the session at the IDP is terminated.
6. The user is sent to the SP that has initiated the SAML logout.
   1. The URL contains a *LogoutResponse* message to signal a successful logout.
7. The SAML SP redirects the user to its logout target.
   1. By default the *RelayState* (URL of the application) is used and thus a new SAML authentication will be initiated.
   2. You can set a different *Logout Target* in the *SAML SP Realm* pattern.
--------------------------------------------------------------------------------
Section: ### Extended-Flow-for-Third-Party-Initiated-Authentication.md
---
sidebar_position: 91
---

# Extended Flow for Third-Party Initiated Authentication

The easiest way to integrate a third-party SAML Identity Provider (IDP) is to add a *SAML IDP Connector* pattern to your *SAML SP Realm* pattern*.*This approach is called *direct integration.*

Direct integration is not appropriate in the following cases:

* If you also have an own IDP. In this case, you may have to configure multiple *SAML IDP Connector* patterns and have to come up with a *Selection Expression* for each of them.
  * The expression can become complex, and you have to ensure that always exactly one expression evaluates to "True".
  * In some cases this can even be impossible as the IDP selection may depend on unknown criteria.
* If you have multiple *SAML SP Realm* patterns. In this case, maintaining the trust relationships for all IDPs can be cumbersome.

To overcome these issues, nevisAdmin 4 provides an experimental pattern called *SAML Response Consumer*.

The pattern itself is simple but the complete SAML flow is special and requires some explanation:
Let's assume that we already have a basic SAML setup that includes a Nevis SP and a Nevis IDP.
This basic setup is described in chapter SAML Flows for Authentication.
However, instead of integrating the third-party IDP in our SP, we want it to be associated with our Nevis IDP.
To achieve this, we configure a *SAML Response Consumer* pattern and select the same *Virtual Host* and *Authentication Realm* as in the *SAML IDP* pattern.

The following figure shows the resulting SAML flow:

<img className="boxed" src={require('../../../../../assets/53123699.png').default} alt="Third-party initiated authentication - SAML flow"/>

The SAML flow contains the following steps (the numbers of the steps correspond with the numbers in the figure above):

1. The user wants to access a web application.
   1. The web application is hosted on `www.siven.ch`.
   2. To access the application, the user requests a URL at the third-party IDP. This triggers an IDP-initiated authentication.
2. The third-party IDP authenticates the user and returns a SAML Response.
   1. The only known fact about this SAML Response is that the included assertion contains information about the user.
   2. The third-party IDP must also return a *RelayState* parameter, which contains the URL of the desired application.
   3. The browser is instructed to send both the SAML Response and the *RelayState* parameter to the SAML Response Consumer.
3. The SAML Response Consumer consumes the SAML Response and ensures that the user is authenticated.
   1. The Issuer is extracted to dispatch into a corresponding *ServiceProviderState*.
   2. The *ServiceProviderState* validates the signature of the received SAML message.
   3. An Authentication Processing flow is executed. This flow can be complex as the exact steps depend on what we know about the user and the information we have received.
4. The SAML Response Consumer now declares the authentication to be completed.
   1. The browser is redirected to the URL taken from the *RelayState* parameter. The remainder of the authentication flow is similar to an SP-initiated authentication. Check [SAML Flows for Authentication] for a more detailed description.
5. There is no authenticated session on `www.siven.ch`. Therefore, access to the application is denied.
   1. The request is handed over to the SAML SP, which triggers SP-initiated authentication.
6. The SAML SP forces the browser to send an *AuthnRequest* to our SAML IDP.
7. The SAML IDP consumes the *AuthnRequest*.
   1. As the SAML IDP and the SAML Response Consumer are associated with the same Authentication Realm there already is a session.
   2. As the session is authenticated already, the IDP immediately returns a SAML Response without any user interaction.
8. The browser is instructed to send the *AuthnRequest* to the SP.
9. The SP consumes the SAML Response, authenticates the session and redirects it to the application.
10. Now there is an authenticated session and the user is allowed to access the application.
--------------------------------------------------------------------------------
Section: ### SAML-Flows-for-Authentication.md
---
sidebar_position: 99
---

# SAML Flows for Authentication

This chapter describes the supported flows for SAML authentication based on the sample setup described in the Supported SAML Flows section.

## SP-Initiated Authentication

<img className="boxed" src={require('../../../../../assets/53123666.png').default} alt="SP-initiated SAML flow for authentication"/>

SP-initiated SAML authentication works as follows (the numbers of the steps below correspond with the numbers in the figure above):

1. The user wants to access the web application `www.siven.ch`:
   * The web application is behind a nevisProxy virtual host and protected by a SAML SP Realm*.*
   * The user uses a browser-based client.
2. As there is no authenticated session, access to the application is blocked.
   * Session tracking is based on a session cookie.
   * Authentication is enforced by nevisProxy.
   * The request is forwarded to nevisAuth, which acts as SP and initiates the SAML flow.
3. The SP checks if the session has been expired.
   * This check is optional and can be enabled in the *SAML SP Realm* pattern (*Session Expiration* tab*).*
   * The *SAML SP Realm* pattern provides different strategies on how to handle expired sessions. Each strategy corresponds with a field in the *Session Expiration* tab:
      * *Logout Reminder*: Renders a page that reminds the user to log out in the future.
      * *Timeout Page*: Renders a page that informs about the termination of the session due to timeout.
      * *Session Expiration Redirect*: Redirects to a configurable URL (for example, a hosted resource or the URL of the IDP to trigger IDP-initiated authentication).
4. The SP can also execute an optional custom pre-processing step.
   * You configure this step in the *Custom Pre-Processing* field of the *SAML SP Realm* pattern (*Advanced Settings* tab). Check the pattern's *Help* section for further information about this advanced feature.
5. The SP now determines which SAML IDP to invoke.
   * This step is not relevant when only one IDP is configured.
   * The IDP is selected based on a selection expression. You configure this expression in the *SAML IDP Connector* pattern (*Selection Expression* field, *Advanced Settings* tab). Check the pattern's *Help* section for examples.
6. The SP returns an *AuthnRequest*.
   * The *AuthnRequest* contains the Issuer of the SP and is signed with the SAML Signer of the SP.
   * The SP stores the current URL (of the application) in a *RelayState* parameter.
      * The SAML standard demands that the IDP returns this *RelayState* parameter unchanged.
   * The browser is instructed to send *AuthnRequest* and *RelayState* to the IDP. How these parameters are transmitted can be configured in the *SAML IDP Connector* pattern (*Binding: Outbound* field, *Basic Settings* tab):
      * POST-binding ("http-post"): Self-submitting form. This is the default setting.
      * Redirect-binding ("http-redirect"): Using query parameters and a 302 redirect.
7. The IDP consumes the *AuthnRequest*.
   * The IDP first extracts the Issuer from the *AuthnRequest* and dispatches the request into the correct *IdentityProviderState*.
      * Each *SAML SP Connector* pattern generates one *IdentityProviderState*.
   * The *IdentityProviderState* validates the signature of the *AuthnRequest*.
      * If the signature is not valid, then a standard SAML error response is returned.
8. If the user has no authenticated session on the IDP he has to log in first.
   * The authentication flow is defined by the *Authentication Realm* pattern assigned to the *SAML IDP* pattern.
9. Once the session is authenticated, the SAML IDP produces a SAML Response.

   * The Response is sent to the *AssertionConsumerServiceURL* that has been extracted from the *AuthnRequest*.
   * If no *AssertionConsumerServiceURL* is found, then the URL defined in the *SAML SP Connector* pattern is used.
10. The SP consumes the Response:

* Based on the Issuer of the Response the corresponding *ServiceProviderState* for this IDP is selected.
  * Each *SAML IDP Connector* pattern generates one *ServiceProviderState*.
* The *ServiceProviderState* validates the signature of the Response.
* If the Response contains an *AudienceRestriction* then it has to match the current URL.

11. The SP can execute an optional post-processing flow.

* You configure this flow in the *Post-Processing Flow* field of the *SAML SP Realm* pattern (*Advanced Settings* tab). Check the pattern's *Help* section for further information about this advanced feature.

12. The SP declares the authentication as done and redirects back to the web application.

* The URL of the application is taken from the *RelayState* parameter.

13. As there now is an authenticated session, nevisProxy allows the user to access the application.

* If an Application Access Token is assigned to the web application, the SAML SP is invoked again to produce that token.
* If an Authorization Policy is assigned that demands a higher authentication level, a session upgrade may be performed. See the chapter SAML Flow for Session Upgrade for details.

## IDP-Initiated Authentication

<img className="boxed" src={require('../../../../../assets/53123687.png').default} alt="IDP-initiated SAML flow for authentication"/>

IDP-initiated SAML authentication works as follows:

1. A user requests a URL that points to the IDP.
   1. The request may be sent to any of the frontend paths configured in the *Frontend Paths* field/property of the *SAML IDP* pattern (*Basic Settings* tab).
   2. Some parameters must be included (as POST or query parameters):
      1. Issuer: As used by the SP and configured in a *SAML SP Connector* pattern*.*
      2. *RelayState*: will be returned to the SP together with the SAML Response.
   3. The IDP uses the Issuer to determine the correct *IdentityProviderState* for this SP.
2. In case the user has no authenticated session he has to log in first.
   1. The authentication flow is defined by the *Authentication Realm* pattern assigned to the *SAML IDP* pattern.
3. Once the user has been authenticated, the SAML IDP returns a SAML Response.
   1. The *SAML SP Connector* pattern defines how the Response is returned:
      1. You can choose between POST-binding and redirect-binding.
      2. As there is no incoming *AuthnRequest,* configure the SP URL.
   2. The browser is instructed to send the Response and the *RelayState* parameter to the SP URL.
4. The SP consumes the Response:
   1. Based on the Issuer of the Response the corresponding *ServiceProviderState* for this IDP is selected.
   2. The *ServiceProviderState* validates the signature (either the Response or the contained Assertion may be signed).
   3. If the Response contains an *AudienceRestriction* then it has to match the URL of the SP.
5. The SP may execute an optional *Post-Processing Flow*.
   1. You configure this optional flow in the *Post-Processing Flow* field of the *SAML SP Realm* pattern (*Advanced Settings* tab). Check the pattern's *Help* section for further information about this advanced feature.
6. The SP declares the authentication done and redirects back to the web application.
   1. The URL of the web application is taken from the *RelayState* parameter.
7. As there now is an authenticated session, nevisProxy allows the user to access the application.
   1. If an Application Access Token is assigned to the web application, the SAML SP is invoked again to produce that token.
   2. If an Authorization Policy is assigned that demands a higher Authentication Level, a session upgrade may be performed. See the chapter SAML Flow for Session Upgrade for further information.

Be aware of the following warning/recommendation:

IDP-initiated authentication is harder to initiate (as it requires additional parameters to be sent) and potentially less secure (as the initial AuthnRequest from the SP is skipped). Thus, we recommend using SP-initiated authentication whenever possible.
--------------------------------------------------------------------------------
Section: ### Setting-up-an-OAuth-2.0-Authorization-Server.md
---
sidebar_position: 93
---

# Setting up an OAuth 2.0 Authorization Server

This chapter explains how to set up an OAuth 2.0 Authorization Server. There is no dedicated pattern for this case, but you can use standard nevisAuth patterns. Here, we use the following patterns:

* *Generic Authentication Step:* This pattern configures an *AuthorizationServer* AuthState. Check the nevisAuth documentation for further information.
* *Standalone Authentication Flow:* This pattern exposes the *Generic Authentication Step* pattern on a nevisProxy virtual host.

## Preconditions

* nevisMeta is set up. For more information, see the chapter [Setting up a nevisMeta Instance](Setting-up-a-nevisMeta-Instance.md).
* The nevisAuth host is able to reach the nevisMeta API.
* OAuth 2.0 setup is defined.
  * The OAuth 2.0 setup is defined with the nevisMeta Web Console pattern.
  * The ID of the setup is available, to configure the AuthorizationServer AuthState.
* An *Authentication Realm* pattern is available, to host the Authorization Server.
  * As part of the Authentication Realm pattern's settings, an initial authentication flow is specified in the Initial Authentication Flow field/property. The initial authentication flow is invoked when the user is not yet authenticated. The initial authentication flow is also used later on, when you configure the Generic Authentication Step pattern.

## Quick Start

This quick start shows how to set up an OAuth 2.0 Authorization Server. This quick start is kept as simple as possible for illustration purposes.

Be aware of the following potential issues:

* The user will not be asked for confirmation if no *ConsentState* AuthState is configured.
  * Check the nevisAuth technical documentation for details.
* You may have to configure key management, because:
  * The *AuthorizationServer* AuthState uses signer key material.
  * nevisAuth must be able to call nevisMeta. For this, set the *Nevis SecToken Trust* property of the *nevisMeta Instance* pattern.
* As input for the *AuthState(s): Parameters* field in *Generic Authentication Step* pattern, you may want to use a variable and define the values in the inventory. See the pattern's *Help* tab for details.
--------------------------------------------------------------------------------
Section: #### Perform the following steps
1. Add a *Generic Authentication Step* pattern. Configure the pattern as follows:
   1. Configure the *AuthorizationServer* AuthState in the *AuthState(s): direct input* field. Use the configuration from the code block below.
   2. Use the *AuthState(s): Parameters* field to externalize an environment-specific configuration, such as:
      * the host name of nevisMeta, or  
      * the ID of the OAuth 2.0 setup in nevisMeta.
   3. The *Additional Follow-up Steps* field defines the first step of the initial authentication flow. This step is executed if the user is not authenticated yet.  
      * Use the same authentication flow as the one in the *Initial Authentication Flow* field of the relevant *Authentication Realm* pattern. You have configured this pattern as a precondition, see the section Preconditions above.
2. Add a *Standalone Authentication Flow* pattern. Configure the pattern as follows:
    1. Assign a nevisProxy virtual host to the *Virtual Host* field.
    2. Enter a frontend path in the *Frontend Path* field.
    3. Assign the previously configured authentication realm to the *Authentication Realm* field (see also the section Preconditions).
    4. Assign the *Generic Authentication Step* pattern that you created in step 1 to the *Authentication Flow* field.

```script title="AuthState(s): direct input"
<AuthState name="${state.entry}" class="ch.nevis.esauth.auth.states.oauth2.AuthorizationServer" final="false">
 <ResultCond name="authenticate:valid-authorization-request" next="${state.exit.1}"/> <!-- execute the first assigned Additional Follow-Up Step -->
 <ResultCond name="invalid-authorization-request" next="${state.failed}"/>
 <ResultCond name="invalid-client" next="${state.failed}"/>
 <ResultCond name="invalid-redirect-uri" next="${state.failed}"/>
 <ResultCond name="invalid-token-request" next="${state.failed}"/>
 <ResultCond name="server-error" next="${state.failed}"/>
 <ResultCond name="stepup:valid-authorization-request" next="${state.done}"/>
 <property name="keyobjectref" value="DefaultSigner"/>
 <property name="keystoreref" value="DefaultKeyStore"/>
 <property name="dataSource" value="nevismeta"/>
 <property name="nevismeta.location" value="https://${param.meta}:8996/nevismeta/rest/modules/oauthv2/setups/Setup_${param.setup_id}/entities"/>
</AuthState>
```

The following figure shows the required patterns in an example configuration:

<img className="boxed" src={require('../../../assets/53125206.png').default} alt=""/>

<img className="boxed" src={require('../../../assets/53125208.png').default} alt=""/>

<img className="boxed" src={require('../../../assets/53125207.png').default} alt="Setting up an OAuth 2.0 Authorization Server - Patterns with entries"/>
--------------------------------------------------------------------------------
Section: #### Realm Patterns
nevisAdmin 4 provides several *Realm* patterns. You can use any *Realm* pattern for this purpose. The *Authentication Realm* is the most high-level and convenient pattern.

## Quick Start

Perform the following steps to set up a nevisMeta instance:

1. Add a *nevisMeta Instance* pattern. Configure the pattern as follows:

   1. Enter a deployment target in the *Deployment Target* field.
      1. Use a group, host, or service that exists in your inventory.
      2. The target hosts must have nevisMeta installed (version >= 1.5.1.6).
   2. Add a *nevisMeta Database Connector* pattern in the *Database Connector* field.
2. Configure the *nevisMeta Database Connector* pattern as follows:
   1. Enter a relevant URL in the *Connection URL* field. For example: "jdbc:mariadb://nevisdb:3306/nevismeta".
   2. Enter the name of the DB schema owner in the *Username* field. For example: "umet01".
   3. Connect a variable to the *Password* field.
      1. Set the value for this variable in your inventory.
3. Add a *nevisMeta Web Console* pattern. Configure the pattern as follows:
   1. Assign the previously configured *nevisMeta Instance* pattern to the *nevisMeta* field.
   2. Assign a *Virtual Host* pattern to the *Virtual Host* field. The nevisMeta Web Console is accessible on this virtual host via the path */nevismeta/*.
   3. Assign an *Authentication Realm* pattern to the *Authentication Realm* field.
   4. Assign a *Nevis SecToken* pattern to the *Application Access Token* field.
      1. The pattern verifies that this *Nevis SecToken* pattern is also assigned to the Realm pattern that you configured as a precondition (see the section: Preconditions above).

The following figure shows the nevisMeta patterns in an example configuration:

<img className="boxed" src={require('../../../assets/53125195.png').default} alt=""/>

<img className="boxed" src={require('../../../assets/53125196.png').default} alt=""/>

<img className="boxed" src={require('../../../assets/53125197.png').default} alt="Setting up a nevisMeta instance - Patterns with entries"/>

This example uses automatic key management.

For production setups, use the *PEM-* or *nevisKeybox Store* patterns instead.
--------------------------------------------------------------------------------
Section: ### User-Behavior-Analytics-Troubleshooting.md
---
sidebar_position: 117
---

# User Behavior Analytics Troubleshooting

You can check the status of the components in the nevisDetect web application, for more information see the Operator section in the nevisDetect User guide.

The detailed description of the monitoring messages can be found under the Monitoring chapter in the nevisDetect Reference guide.

## Logfiles

You can find the log files on the path below. You can also override the log files in the configuration: `/var/opt/nevisdetect/<component>/logs/nevisdetect-<component>.log`.

| Component | Log file |
| --- | --- |
| Persistency | `/var/opt/nevisdetect/persistency/logs/nevisdetect-persistency.log` |
| Admin | `/var/opt/nevisdetect/admin/logs/nevisdetect-admin.log` |
| Core | `/var/opt/nevisdetect/core/logs/nevisdetect-core.log` |
| Entrypoint | `/var/opt/nevisdetect/entrypoint/logs/nevisdetect-entrypoint.log` |

For troubleshooting, use the log entries created by the *OpTracer.* This helps you to find the service calls in the log. For example:

```
 2018-01-16_22:13:23.158 [https-jsse-nio-10.0.205.195-8181-exec-4] DEBUG c.n.nevisDetect.util.logging.OpTracer - ==>'GET https://nevisdetect-dev.nevis-security.com:8181/nevisdetect/persistency/runtimeconfiguration/getRuntimeConfiguration?waitTime=30000' remoteAddr='10.0.205.195' user='DETECT_CORE'

 2018-01-16_22:13:53.183 [https-jsse-nio-10.0.205.195-8181-exec-4] INFO c.n.nevisDetect.util.logging.OpTracer - <== 'GET https://nevisdetect-dev.nevis-security.com:8181/nevisdetect/persistency/runtimeconfiguration/getRuntimeConfiguration?waitTime=30000' remoteAddr='10.0.205.195' user='DETECT_CORE' in 30025 [msec]
```
--------------------------------------------------------------------------------
Section: #### nevisDetect Administration GUI
The administration of the service is conducted via a web application so add a *nevisDetect Administration GUI* pattern. The following properties are mandatory to set:

* *nevisDetect Admin*: set a reference to the *nevisDetect Admin Instance* pattern created above.
* *Virtual Host*: set a reference to the *Virtual Host* pattern created during the base setup.
* *Authentication Realm*: set a reference to the *Authentication Realm* pattern of the nevisIDM configuration.
* *Application Access Token*: set a reference to the *Nevis SecToken* pattern of the nevisIDM configuration.

<img className="boxed" src={require('../../assets/adminGUI.gif').default} alt="How to create a nevisDetect Administration GUI"/>
--------------------------------------------------------------------------------
Section: #### nevisDetect Persistency REST API
We use the Persistency REST services from the administration UI. To make it available, add a *nevisDetect Persistency REST API* pattern.

* nevisDetect Persistency: add a reference to the *nevisDetect Persistency Instance* pattern configured above.
* Virtual Host: set the same *Virtual Host* as for nevisDetect Admin Web Application Access.
* Authentication Realm: set the same *Authentication Realm* as for nevisDetect Admin Web Application Access.
* Application Access Token: set the same *Nevis SecToken* as for nevisDetect Admin Web Application Access.

<img className="boxed" src={require('../../assets/persistencyREST.gif').default} alt="How to create a nevisDetect Persistency REST API"/>
--------------------------------------------------------------------------------
Section: #### Risk Plugins
There are currently 3 different options available, at least one should be picked based on the use case and added under *Risk Plugins*. They are described in detail in the User Behavior Analytics Use Cases section.

## Integration with other Nevis components to protect web applications
--------------------------------------------------------------------------------
Section: #### nevisDetect Feature Correlator Instance
The nevisDetect Feature Correlator receives the HTTP request from nevisProxy and correlates and passes it on to the message bus.

* Deployment Target: it is advised to set the same target host as for *nevisProxy Instance.*
* nevisDetect Persistency Instance: add the reference for the instance configured above.
* nevisDetect Message Queue Instance: add the reference for the instance configured above.

To protect your web application, add this pattern to the Additional Settings in the Web application pattern on the Advanced Settings tab or for the Virtual host, otherwise it will have no effect.

<img className="boxed" src={require('../../assets/featureCorrelator.gif').default} alt="How to create a nevisDetect Feature Correlator Instance"/>
--------------------------------------------------------------------------------
Section: #### Further resources
If you want to set up User Behavior Analytics from scratch, also see the following resources:

* [Main Concepts](../../../nevisadmin4/introduction) of nevisAdmin 4.
* [First Steps](../quickstart-appliance), which explains how to configure a web application protected by nevisProxy.
* Alternatively, the following Nevis yoU books are also available (requires registration):
  * nevisAdmin 4 in a Nutshell, which provides an easy-to-read overview of Nevis administration and the concepts used.
  * Working with nevisAdmin 4, explaining how to configure a web application protected by nevisProxy in more detail.

## Basic Steps

If you are starting with an empty project, have a look at the [Base Setup](../Mobile-Authentication/Base-Setup) for Nevis Mobile Authentication which covers the same steps with more details (note that you can skip the nevisFIDO setup).
--------------------------------------------------------------------------------
Section: ### Virtual Host, nevisProxy, nevisAuth, nevisIDM
Nevis User Behavior Analytics relies on a *Virtual Host* where the services are exposed. It also needs a *nevisAuth Instance* where its authentication flows are configured. Note that a *nevisLogRend Instance* is created automatically if you did not create one beforehand.
--------------------------------------------------------------------------------
Section: ### nevisIDM and nevisIDM Web Application
Nevis User Behavior Analytics uses nevisIDM as its user and credential database. To be able to access the nevisIDM UI, we configure a *nevisIDM Web Application* as well. It is possible to use another user database for example LDAP, however in this guide we only show its configuration with nevisIDM. In the future, some use cases might only be available for nevisIDM, so we would recommend to use that if it is possible.
--------------------------------------------------------------------------------
Section: ### Web Application to protect
If it has not been added yet, the protected Web Application should also be configured. For more details visit: Adding a Web Application.
--------------------------------------------------------------------------------
Section: ### User-Behavior-Analytics-Use-Cases.md
---
sidebar_position: 120
---

# User Behavior Analytics Use Cases

The configuration of User Behavior Analytics Use Cases can be divided into two categories.

The first category is the integration of different detection technologies that can be used for fraud detection. Check the following chapters for details:

* [Adaptive and Continuous Authentication](../User-Behavior-Analytics-Use-Cases/Adaptive-and-Continuous-Authentication/Adaptive)
* [Custom Risk Score Provider Integration](../User-Behavior-Analytics-Use-Cases/Custom-Risk-Score-Provider-Integration)
* [User Behavior Analysis](../User-Behavior-Analytics-Use-Cases/User-Behavior-Analysis)

The second category is related to the operation and configuration of risk score normalization and policies. The configuration for those use cases is available in the nevisDetect Administration Web Application. For more details, see the nevisDetect User Guide:

* [Policy handling](../../../../nevisdetect/nevisDetect-User-Guide/Use-Cases-and-Personas/Security-expert/Policy-handling)
* [Normalized risk score calculation](../../../../nevisdetect/nevisDetect-User-Guide/Use-Cases-and-Personas/Security-expert/Normalized-risk-score-calculation)
* [Application management](../../../../nevisdetect/nevisDetect-User-Guide/Use-Cases-and-Personas/Security-expert/Application-management)
--------------------------------------------------------------------------------
Section: ### Base-Setup.md
---
sidebar_position: 1
---

# Base Setup

Nevis Mobile Authentication relies on the following Nevis components: nevisProxy, nevisAuth, nevisLogRend, nevisIDM and nevisFIDO.

The amount of base setup you have to do depends on your existing configuration (if any):

* If you are configuring Mobile Authentication for an existing setup, you already have a project. In this case, check the steps in this section and adapt your already configured patterns to the instructions, if required.
* In case you are starting from scratch, or with a setup that has only a subset of the needed patterns, then follow the instructions below.

The movies in the next sections show the base patterns you need to configure:

* Virtual Host, nevisProxy and nevisAuth
* nevisIDM
* nevisIDM Web Application
* nevisFIDO
--------------------------------------------------------------------------------
Section: ### Further resources
If you want to set up Mobile Authentication from scratch, also consult the following resources:

* [Main Concepts](../../../nevisadmin4/introduction) of nevisAdmin 4.
* [First Steps](../patterns-overview), which shows how to configure a web application protected by nevisProxy.
* Alternatively, the following Nevis yoU books are available (requires registration):
   * nevisAdmin 4 in a Nutshell, which provides an easy-to-read overview of Nevis administration and the concepts used.
   * Working with nevisAdmin 4, explaining how to configure a web application protected by nevisProxy in more detail. 

## Virtual Host, nevisProxy and nevisAuth

Nevis Mobile Authentication needs a *Virtual Host* where the Mobile Authentication services will be exposed.

<img className="boxed" src={require('../../assets/VirtualHost.gif').default} alt="How to create a virtual host"/>

Some settings in the movie above, such as *Frontend* and *Bind Addresses*, will be different or skipped in your setup. See the documentation listed in the *Further resources* chapter above in case you need more detailed instructions.

Nevis Mobile Authentication needs a *nevisAuth Instance* where its authentication flows will be configured. Note, that a *nevisLogRend Instance* will be created automatically.

<img className="boxed" src={require('../../assets/nevisAuth.gif').default} alt="How to create a nevisAuth instance"/>

## nevisIDM

Nevis Mobile Authentication uses nevisIDM as its user and credential database.

In classic deployments, the nevisIDM database is not managed by nevisAdmin 4. In our example, we use a prepared database docker image as DB. Make sure to create or attach your own database.

<img className="boxed" src={require('../../assets/nevisIDM.gif').default} alt="How to create a nevisIDM instance"/>

## nevisIDM Web Application

To be able to access the nevisIDM UI, we have to configure a *nevisIDM Web Application:*

<img className="boxed" src={require('../../assets/nevisIDM-webapp.gif').default} alt="How to create a nevisIDM web application"/>

## nevisFIDO

Now continue with the setup of nevisFIDO.
--------------------------------------------------------------------------------
Section: #### Uploading the Key Material into the nevisAdmin 4 Project
Now that you have generated and imported the key material into nevisIDM, you need to configure the nevisAdmin 4 patterns to use the keys. Therefore, upload the "nevisFIDO Private Key" into a *PEM Key Store*pattern used by the *nevisFIDO Instance* pattern, and the "nevisFIDO Certificate" into a *PEM Trust Store* pattern used by the *nevisIDM Instance* pattern. The next movie shows you how to do this:

<img className="boxed" src={require('../../assets/copy-key-material-to-admin.gif').default} alt="How to upload the generated key material to the nevisAdmin 4 GUI"/>

:::info
You may need different key material depending on your inventory. For example: you use different key material for the DEV and the PROD stage. To support this, follow these steps:

* Create the same patterns as in the movie above, but instead of pasting the key material, you create variables. For more information, see Working with Variables.
* Within each inventory, add each variable and upload the key material to each variable as a file. For more information, see Working with Inventory File Attachments.
:::

## Mobile Authentication Use Cases

Now you are ready to configure the actual use cases. Go to Mobile Authentication Use Cases.
--------------------------------------------------------------------------------
Section: ### Authentication.md
---
sidebar_position: 112
---

# Authentication

Nevis Mobile Authentication supports two authentication use cases:

* In-band authentication: 
For more information, see [In-Band Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/in-band-authentication) in the Nevis Mobile Authentication Concept and Integration Guide.
* Out-of-band authentication: 
For more information, see [Out-of-Band Authentication](/configurationguide/mobile-auth-concept-and-integration-guide/use-cases-and-best-practices/out-of-band-authentication) in the Nevis Mobile Authentication Concept and Integration Guide.

## In-Band Authentication

You use the *In-band Mobile Authentication Realm* pattern to protect a backend resource used by a mobile application (for example a REST Service).

The pattern is similar to a regular *Authentication Realm* pattern, however limited to the protection of *REST Service* or *Mobile Device Deregistration* patterns.

The next figure shows the connections of the *In-band Mobile Authentication Realm* pattern with other patterns:

<img className="boxed" src={require('../../../assets/43122911.png').default} alt="The In-band Mobile Authentication Realm pattern and its connections"/>

The next movie shows how to configure in-band authentication to protect a REST Service, with the *In-band Mobile Authentication Realm* pattern:

<img className="boxed" src={require('../../../assets/InbandMobileAuthenticationRealm.gif').default} alt="How to configure in-band authentication protecting a REST service"/>

## Out-of-Band Authentication

When a web application needs to be protected by mobile authentication, you can use the *Out-of-band Mobile Authentication* pattern.

The figure below shows a setup with out-of-band mobile authentication. The white text boxes represent the corresponding patterns.

<img className="boxed" src={require('../../../assets/43122917.png').default} alt="Out-of-band authentication setup with the relevant patterns"/>

The next sections explain how you can configure such an out-of-band authentication setup, including two-factor authentication.
--------------------------------------------------------------------------------
Section: ### Part 1 - Requesting an Access App
1. Open the *Virtual Host* pattern of your nevisAdmin 4 project. Go to the *Frontend Address* field/property in *Basic Settings* tab.
   1. Enter the **backend** URL in this field.
   2. Then enter a second URL in the same field.
      1. This second address must be the same as the first one, except for the "app" subdomain. For example, if your first address is `https://**app**.example.siven.dev/`,  `https://app.user9000.admin4aks.azure.nevis.dev`.
      2. The domain in this second address will be the **Deep Link Domain**. So in our example, the deep link domain would be*app.example.siven.dev*.
2. Now you can order an Access App:
   1. Follow the instructions on the page Ordering an Access App of the Nevis Access App Guide.
   2. Make sure to provide the **backend URL** and the **deep link domain** you specified in [step 1], so that they can be built into the application.
   3. When the application is built, note down the information in the following table. You will need this information later on - without it, deep linking support is not possible.

| System | Information to obtain |
| --- | --- |
| iOS | Team Identifier, Bundle Identifier |
| Android | Package Name, SHA256 Fingerprint |
--------------------------------------------------------------------------------
Section: ### Part 2 - Creating the basic Mobile Authentication with Deep Links pattern
1. Add the *Mobile Authentication with Deep Links* pattern to your nevisAdmin 4 project. Set the following fields:
2. Assign the existing *nevisFIDO Instance* pattern to the *nevisFIDO* field/property.
3. Assign the existing *Virtual Host* pattern to the *Virtual Hosts* field/property.
4. Specify the **Deep Link Path** in the *Deep Link Base Path* field/property. The deep link path is the path rendered into the deep links. For example, a deep link path that will only be used for registration would look like this:

```
/registration
```

You can only set one deep link path

You cannot set multiple deep link paths. The path set in the *Deep Link Base Path* field will be used in every deep link that the backend generates.
--------------------------------------------------------------------------------
Section: ### Part 4 - Configuring the relying party application
See also Protecting a Web Application.

The relying party application is responsible for requesting the deep link from the nevisFIDO component and rendering/displaying the link to the end user. This application is **not** provided by Nevis. Deploy it independently. This section shows how to integrate the relying party application into the project to enable deep links.

1. Add a *Web Application* pattern to your nevisAdmin 4 project (or open the pattern, in case there already exists one for the relying party application). Specify the following fields:
2. *Virtual Hosts* field, *Basic Settings* tab: Assign the **same** *Virtual Host* pattern to this field as the one assigned to the *Mobile Authentication with Deep Links* pattern.
3. *Frontend Paths* field, *Basic Settings* tab: Specify any desired frontend path.
4. *Authentication Realm* field, *Basic Settings* tab: Assign the **same** *Authentication Realm* pattern as the one assigned to the *Mobile Device Registration* pattern (which you created when you configured the Out-of-Band Registration).
5. *Application Access Token* field, *Basic Settings* tab: Assign the **same** token as the one assigned to the *Mobile Device Registration* pattern.
6. *Backend Addresses* field, *Backend Connection* tab: Provide an accurate backend address that points to the relying party application's backend.
--------------------------------------------------------------------------------
Section: ### Part 5 - Deployment
Deploy the configuration with nevisAdmin 4.

## Test

Now that we have deployed the Mobile Authentication with Deep Links use case, we can test it.

1. Open a browser on the mobile device where the Access App is installed
2. Navigate to the relying party application. The URL of the application can be constructed by merging the Backend URL and whatever you configured in the *Frontend Paths*field of the *Web Application* pattern.
3. Log in.
4. The relying party application will approach nevisFIDO for a deep link, which it should render on the screen.
      The following figure shows how it might look like:

      <img className="boxed" src={require('../../../assets/65964860.jpg').default} alt="Deep link sample"/>

      For debugging purposes, this is an example how the generated link should look like:

      ```
      https://app.example.siven.dev/registration?dispatchTokenResponse=eyJubWFfZGF0YSI6eyJ0b2tlbiI6ImZjNGYyNGRjLWU4OGQtNGNhNC04ZWU5LTQ0OTM2NDdhNTViMyIsInJlZGVlbV91cmwiOiJodHRwczovL3VzZXI5MDAwLmFkbWluNGFrcy5henVyZS5uZXZpcy5kZXYvbmV2aXNmaWRvL3Rva2VuL3JlZGVlbS9yZWdpc3RyYXRpb24ifSwibm1hX2RhdGFfY29udGVudF90eXBlIjoiYXBwbGljYXRpb24vanNvbiIsIm5tYV9kYXRhX3ZlcnNpb24iOiIxIn0
      ```

5. Click the link, after which a banner should be visible, prompting you to choose the application to open the link.
6. Choose the Access App.
7. Complete the registration process shown in the Access App user interface.

:::tip Congratulations
You just executed out-of-band mobile registration, using deep links!
:::

[1] <http://developer.android.com/training/app-links>,<http://github.com/google/digitalassetlinks/blob/master/well-known/details.md>

[2] <http://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html/>
--------------------------------------------------------------------------------
Section: ### Registration.md
---
sidebar_position: 112
---

# Registration

If you want to use a mobile device in mobile authentication operations, register it beforehand.

Nevis Mobile Authentication offers two registration use cases:

* In-band registration
For more information, see In-Band Registration in the Nevis Mobile Authentication Concept and Integration Guide.
* Out-of-band registration
For more information, see Out-of-Band Registration in the Nevis Mobile Authentication Concept and Integration Guide.

Both can be configured with the *Mobile Device Registration* pattern via the *Registration Type* property.

## Pattern Structure

The next figure shows the connections of the *Mobile Device Registration* pattern to other patterns:

<img className="boxed" src={require('../../../assets/43122775.png').default} alt="The Mobile Device Registration pattern and its connections"/>

The *Mobile Device Registration* pattern requires the following patterns:

* *Authentication Realm*, to configure the legacy login.
* *Virtual Host*, to expose the backend services.
* *nevisFIDO Instance*, to provide the *FIDO UAF* related services.
--------------------------------------------------------------------------------
Section: ### QR Code Integration
Out-of-band registration is designed to be integrated into existing web applications. This integration happens via browser-rendered QR codes. The existing web application obtains the QR code data from the relevant nevisFIDO instance and renders the code on the UI. Therefore, the application must be able to connect to the nevisFIDO instance.

If you are interested in the details, check out Out-of-Band Registration and Out-of-Band Registration Client Code Examples in the Nevis Mobile Authentication Concept and Integration Guide.

The next movie shows QR code integration into an existing web application. For this, it uses a demo application that is specifically prepared for this goal.

The existing web application (*QR Demo Web App* in the movie) and the *Mobile Device Registration* pattern/service must be protected by the **same** Authentication Realm!

<img className="boxed" src={require('../../../assets/MobileDeviceRegistration-qrdemo.gif').default} alt="How to create and protect a QR Demo Web App"/>

## In-Band Registration

For in-band registration, legacy login is generated automatically into the realm, since it is an exposed REST service consumed by the mobile app. Multi-step legacy login authentication flows are not supported by the Nevis Access App and cannot be configured using this pattern.

When in-band registration is selected as registration type, the authentication flow provided in the authentication realm will be transparently generated. But an *Authentication Realm*  pattern has to be provided nevertheless. In case no browser authentication is configured in the realm, set up a *User Information* pattern.

The next movie shows how to configure in-band registration.

<img className="boxed" src={require('../../../assets/MobileDeviceRegistration-inband.gif').default} alt="How to configure in-band registration"/>

## In-Band and Out-of-Band Registration Together

In-band and out-of-band registration can be configured together (independent of each other). You do this by selecting the option "both" in the *Registration Type* drop-down menu of the *Mobile Device Registration* pattern. The following movie shows how to proceed:

<img className="boxed" src={require('../../../assets/MobileDeviceRegistration-both.gif').default} alt="How to configure in-band and out-of-band registration together"/>
--------------------------------------------------------------------------------
Section: ### Mobile-Authentication-Use-Cases.md
---
sidebar_position: 110
---

# Mobile Authentication Use Cases

The figure below shows all Nevis Mobile Authentication patterns and the connections between them:

<img className="boxed" src={require('../../../assets/34643852.png').default} alt="The Mobile Authentication patterns and their connections"/>

As you can see, all patterns or use cases reference the *nevisFIDO Instance* pattern.

Be careful when creating multiple *nevisFIDO Instance*s: Each instance must be connected to a different *Virtual Host*. The reason is that the URLs allocated for nevisFIDO services on the virtual host are fixed, that is, they always start with */nevisfido/*. These URLs are then mapped to exactly one nevisFIDO backend.

## List of Use Cases

The following use cases are supported by the pattern library:

* Registration
* Authentication
* Deregistration
* Transaction Confirmation
* Mobile Authentication with Deep Links
--------------------------------------------------------------------------------
Section: ### Key-Management-Report.md
---
sidebar_position: 134
---

# Key Management Report

This report provides information about the *key stores* and *trust stores* used in a project. What is shown in the *Details* column depends on the *Type* and may change in future releases.

As of nevisAdmin 4.10 the following *Type* exist:

* *automatic*:
  * No pattern is assigned / this store is implicit.
  * Key material will be created / renewed automatically on deployment if required.
  * No Details are displayed as meta data / certificate(s) are not reachable for the report.
* *Automatic Key Store*:
  * A pattern is assigned / the store is explicit.
  * No Details are displayed as meta data / own certificate are not reachable for the report.
* *Automatic Trust Store*:
  * A pattern is assigned / the store is explicit.
  * No Details are displayed as meta data / trusted certificate(s) are not reachable for the report.
  * Since nevisAdmin 4.10, this pattern supports the upload of additional trusted certificates, similarly to PEM Trust Store.
* *nevisKeybox Store*:
  * Key material must be managed on the target host. Not supported in Kubernetes.
  * The Details column shows slot / label.
* *PEM Key Store*:
  * Key material must be uploaded in the pattern.
  * Details column shows expiration of owned certificate.
* *PEM Trust Store*:
  * Trusted certificates must be uploaded in the pattern.
  * Details column shows expiration of trusted certificates.

The *Instance* links the *Instance Pattern* the store belongs to.

## Example

<img className="boxed" src={require('../../assets/65964410.png').default} alt="Key Management Report - Example"/>
--------------------------------------------------------------------------------
Section: ### Application-Mapping-Report.md
---
sidebar_position: 132
---

# Application Mapping Report

This report lists the applications of each virtual host and how they are mapped to backend addresses.

## Example

<img className="boxed" src={require('../../assets/60753576.png').default} alt="Application Mapping Report - Example"/>
--------------------------------------------------------------------------------
Section: ### Security-Configuration-Report.md
---
sidebar_position: 132
---

# Security Configuration Report

This report provides a detailed overview of the security configuration for virtual hosts and the backend applications on these virtual hosts.

Each topic in the report directly links to the pattern property where you can configure the setting.

For many topics, you can click on *Show details...* to see the exact configuration that is generated into the configuration files of nevisProxy.

## Example

<img className="boxed" src={require('../../assets/60753573.png').default} alt="Security Configuration Report - Example"/>
--------------------------------------------------------------------------------
Section: ### Application Add-on Patterns
The nevisAuth plug-in provides several patterns that you can assign to applications. You assign these patterns in the property field *Additional Settings*, which is available in the application patterns (for example, the *Web Application* pattern). Here are some examples:

* The *Authorization Policy* pattern allows the definition of the required roles or authentication level.
* Token patterns (for example, the *Nevis SecToken* pattern) can be assigned to propagate the user identity to the backend.

## What if my Use Case is not Covered by the Standard?

If your use case is not covered by the standard patterns, contact Nevis Support and explain your case.

The nevisAuth patterns are in active development and we are interested in your requirements.

In the meantime you have several options:

* Use the *Generic Authentication Step* pattern to add a custom step to an authentication flow configured with the *Authentication Realm* pattern. See the *Help* page of the *Generic Authentication Step* pattern for further information.
* Use the *Generic Authentication Realm* pattern for complex authentication flows.
--------------------------------------------------------------------------------
Section: ### Further resources
If you want to set up Nevis Authentication Cloud from scratch, also see the following resources:

* [Main Concepts](../../../nevisadmin4/introduction) of nevisAdmin 4.
* [Getting Started](../quickstart-appliance), which explains how to configure a web application protected by nevisProxy.
* Alternatively, the following Nevis yoU books are also available (requires registration):
  * nevisAdmin 4 in a Nutshell, which provides an easy-to-read overview of Nevis administration and the concepts used.
  * Working with nevisAdmin 4, explaining how to configure a web application protected by nevisProxy in more detail.

## Basic Steps

If you are starting with an empty project, have a look at the [Base Setup](../Mobile-Authentication/Base-Setup) for Nevis Mobile Authentication which covers the same steps with more details. Skip the nevisFIDO setup, as that is the functionality that the Nevis Authentication Cloud will provide for you.
--------------------------------------------------------------------------------
Section: ### LDAP-Login.md
---
sidebar_position: 89
---

# LDAP Login

## Preconditions

* Make your web application accessible via nevisProxy as explained in Protecting a Web Application.

## Quickstart

1. Assign an *Authentication* *Realm* pattern to your web application.
2. Assign an *LDAP Login* pattern to your *Authentication Realm* pattern.
   1. You do this in the *Initial Authentication Flow* field, *Basic Settings* tab of the *Authentication Realm* pattern.
3. Configure the *LDAP Login* pattern as follows:
   1. Select the type of LDAP you have.
   2. Enter the LDAP URL.
   3. Enter the base DN where the users are located.

## LDAPS Integration

In case of LDAPS, you have to ensure that the issuing CA of the LDAP endpoint certificate is trusted.

For this, you have to assign a provider for the backend truststore in the *nevisAuth Instance* pattern.

* You do this in the *Backend Trust Store* field, *Key Management* tab.

You can assign the following patterns as provider:

* *nevisKeybox Store*: To use CA certificates managed via nevisKeybox on the target servers.
* *PEM Trust Store*: To deploy the CA certificates using nevisAdmin 4.
--------------------------------------------------------------------------------
Section: ### nevisIDM-Password-Login.md
---
sidebar_position: 86
---

# nevisIDM Password Login

## About nevisIDM Password Login

The *nevisIDM Password Login* pattern provides a username/password based authentication for applications based on nevisIDM users.

For information on how to configure authentication for the nevisIDM Administration GUI, refer to: Accessing the nevisIDM Administration GUI.

The user identity can be propagated to your backend application via an application access token, for example a *Nevis SecToken* or a *JWT Token*.

The next diagram gives an overview of the patterns involved and their relationship:

<img className="boxed" src={require('../../assets/7636779.png').default} alt="Patterns involved in nevisIDM Password Login"/>

## Preconditions

* Make your web application accessible via nevisProxy as explained in [Protecting a Web Application](../Application-Protection/Protecting-a-Web-Application/Protecting-a-Web-Application).
* Add a nevisIDM Instance pattern as explained in [Setting up a nevisIDM Instance](../Identity-Management/Setting-up-a-nevisIDM-Instance).

## Basic Steps

1. Assign an *Authentication Realm* pattern to your web application.
2. Assign the *nevisIDM Password Login* pattern to the *Authentication Realm* pattern.
3. Assign the *nevisIDM Instance* pattern to the *nevisIDM Password Login* pattern.
4. Assign a *Nevis SecToken* pattern to the *Authentication Realm* pattern.
5. Assign the same *Nevis SecToken* pattern to your web application.

## Use Case: Mandatory Password Change

The *nevisIDM Password Login* pattern also configures the mandatory password change after a user's first login to the system. The mandatory password change is enabled by default. It is enforced by the password policy in nevisIDM. When the user enters a password, the *nevisIDM Password Login* pattern verifies it against the default password policy of the relevant client.
--------------------------------------------------------------------------------
Section: ### identity-management.md
---
sidebar_position: 1
---

# Identity Management

The standard nevisIDM patterns provide a means to set up and configure a nevisIDM instance in a standardized way. 
Patterns are classified into categories for easy access; the nevisIDM patterns are classified in the *Identity Management* category.

The next diagram gives an overview of the available nevisIDM patterns:

<img className="boxed" src={require('../../assets/7640279.png').default} alt="Available nevisIDM patterns"/>

## Prerequisites

The nevisIDM patterns require nevisIDM to be already installed on the target host(s).

The following packages are required:

* *nevisidm*: Contains the nevisIDM web application. This package must be installed on the nevisIDM target host(s).
* *nevisidmcl*: Contains the nevisIDM authentication plug-ins (AuthStates). This package must be installed on the nevisAuth target host(s).

:::note
The *nevisidmdb* package is not required.
:::

The nevisIDM patterns only support nevisIDM in standalone mode. Before nevisAdmin 4 deploys the nevisIDM configuration, the system checks whether the installed nevisIDM version will suffice.

## Standard nevisIDM Patterns

The next chapters describe the standard nevisIDM patterns.
--------------------------------------------------------------------------------
Section: ### Patterns to Access the nevisIDM Web Application and the REST/SOAP Services
The following patterns are used to make the corresponding services of nevisIDM accessible via nevisProxy:

* The *nevisIDM Web Application* pattern configures nevisProxy to access the nevisIDM administration web application via the */nevisidm/admin* frontend path.
* The *nevisIDM REST Service* pattern makes the REST services of nevisIDM accessible via the */nevisidm/api* frontend path.
* The *nevisIDM SOAP Service* pattern makes the SOAP services of nevisIDM accessible via the */nevisidm/services* frontend path. See chapter [Accessing the nevisIDM Administration GUI](Accessing-the-nevisIDM-Administration-GUI.md) for more details.

All nevisIDM services require authentication, which is provided by the *nevisIDM Password Login* pattern. See the next section.
--------------------------------------------------------------------------------
Section: ### Accessing-the-nevisIDM-Administration-GUI.md
---
sidebar_position: 106
---

# Accessing the nevisIDM Administration GUI

The *nevisIDM Administration GUI* pattern is used to configure the access to the nevisIDM administration web application.

For information on how to configure nevisIDM user identity propagation to 3rd party web application, refer to nevisIDM Password Login.

## Preconditions

* Make your web application accessible via nevisProxy as explained in Protecting a Web Application.
* Add a nevisIDM Instance pattern as explained in Setting up a nevisIDM Instance.

## Quickstart

1. Add a new *nevisIDM Administration GUI* pattern to your project.
2. Assign an *Authentication Realm* pattern to the *nevisIDM Administration GUI* pattern.
3. Assign the *nevisIDM Password Login* pattern to the *Authentication Realm* pattern.
4. Assign the *nevisIDM Instance* pattern to the *nevisIDM Password Login* pattern.
5. Assign a *Nevis SecToken* pattern to the *Authentication Realm* pattern.
6. Assign the same *Nevis SecToken* pattern to the *nevisIDM Administration GUI* pattern.

After you have deployed the pattern, the application will be available on the */nevisidm/admin* frontend path.

For more information about the nevisIDM Administration GUI, see the [nevisIDM Technical Documentation](../../../nevisidm/introduction).

## Overview

The next diagram gives you an overview of the patterns involved and their relationship.

<img className="boxed" src={require('../../assets/7636793.png').default} alt="Patterns involved in configuring access to nevisIDM Web Application"/>

## nevisIDM Self-Administration

The nevisIDM self-administration web application is not accessible by default. Map the */nevisidm/selfadmin* frontend path with the *Generic Application Settings* pattern to make the application available. Proceed as follows:

1. Open the *nevisIDM Administration GUI* pattern in nevisAdmin 4.
2. Create the pattern *Generic Application Settings* in the *Additional Settings* field.
3. Define the settings for the *Generic Application Settings* pattern: enter the following code block in the *Filters and Mappings* field:

```
<servlet-mapping>
 <servlet-name>Connector_${service.name}</servlet-name>
 <url-pattern>/nevisidm/selfadmin/*</url-pattern>
</servlet-mapping>
```
--------------------------------------------------------------------------------
Section: ### Social-Login-Pattern-Map.md
---
sidebar_position: 54
---

# Pattern map

<img className="boxed" src={require('../../assets/social-login-pattern-map.png').default} alt="Social Login Pattern map"/>

<span style={{color: "blue"}}>Dark blue background:</span>

Used to denote patterns labeled as Applications, which are web applications accessible after deployment.

<span style={{color: "darkgoldenrod"}}>Yellow background:</span>

Used to denote pattern labeled as Social Login Flow.

<span style={{color: "green"}}>Green background:</span>

Used to denote patterns labeled as Nevis Components which describe the infrastructure.
--------------------------------------------------------------------------------
Section: ### passkey-pattern-map.md
---
sidebar_position: 62
---

# Pattern Map

<img className="boxed" src={require('../../assets/passkey-pattern-map.png').default} alt="Passkey pattern map"/>

<body text = "darkgreen">Dark green background:</body> Used to denote patterns labeled as ‘Nevis Components’ which describes the infrastructure.

<body text = "blue">Blue background:</body> Used to denote patterns labeled as ‘Admin UI’ which describes the admin infrastructure.

<body text = "darkgoldenrod">Yellow background:</body> Used to denote patterns labeled as ‘Login’ which are used to set up a general login flow with Passkey.

<body text = "lightgreen">Light green background:</body> Used to denote patterns labeled as ‘Applications’ which are web applications accessible after deployment.

<body text = "red">Red background:</body> Used to denote patterns labeled as ‘Self Registration’ which are needed for the self Registration Flow.

<body text = "pink">Pink background:</body> Used to denote patterns labeled as ‘SMTP’ which describes the SMTP infrastructure.
--------------------------------------------------------------------------------
Section: ### SAML-2.0-Identity-provider.md
---
sidebar_position: 21
sidebar_label: SAML 2.0 Identity provider
---
import Vimeo from '../../../../src/components/Vimeo';

# SAML 2.0 Identity Provider

Security Assertion Markup Language (SAML) is an *authentication protocol* and therefore a crucial part in identity federation between organisations.

As an open standard that allows identity providers (IdP) to pass authorization credentials to service providers (SP), SAML builds the link between the authentication of a user’s identity and the authorization to use a service. SAML only works for web applications.

For further information you could read more [here](https://www.nevis.net/en/fundamentals/what-is-saml).

For detailed view of the technical components used please visit [this](SAML-Pattern-map.md) page.

## The project template

The Nevis project template **SAML 2.0 Identity Provider** supports username / password login infrastructure. For demonstration purposes, the template includes an **example service provider**: it is the nevisIDM GUI and supports **SP initiated** login & logout procedures!

<img className="boxed" src={require('../../assets/SAML2.0-identity-provider.png').default} alt="SAML 2.0 Identity Provider"/>

<Vimeo src="https://player.vimeo.com/video/853672541" title="SAML 2.0 Identity Provider Project Template"/>

<img className="boxed" src={require('../../assets/SAML2.0-identity-provider2.png').default} alt="SAML 2.0 Identity Provider 2"/>

## Scenario for testing a successful deployment

1. Launch your Service Provider (in our example, the nevisIDM Administration GUI application) at `https://your_domain_goes_here/nevisidm/` - replace “your_domain_goes_here” with your real domain name!
2. First time you log-in using your “bootstrap” credentials (bootstrap/generated), you need to change your password before actual login could happen.
3. You land at your IDM admin page. Success!

 You can always observe the relevant SAML communication exchange via a SAML-tracer browser extension e.g. like this: SAML-login.png 

 <img className="boxed" src={require('../../assets/SAML-login.png').default} alt="SAML Login"/>

4. Optionally you could also try logout and observe corresponding SAML entries in a SAML-tracer browser extension:

 <img className="boxed" src={require('../../assets/SAML-logout.png').default} alt="SAML Logout"/>

5. Now it is time to replace the example SP (nevisIDM Admin GUI) with your own service provider and enjoy the Nevis security experience!

## User-facing flows

1. [Login](SAML-2.0-Login.md)
2. [Logout](SAML-2.0-Logout.md)
--------------------------------------------------------------------------------
Section: ### SAML-2.0-Login.md
---
sidebar_position: 22
---

# SAML 2.0 Login

## SP-Initiated Authentication

<img className="boxed" src={require('../../assets/SP-initiated-authentication.png').default} alt="SP initiated authentication.png"/>

SP-initiated SAML authentication works as follows (the numbers of the steps below correspond with the numbers in the figure above):
1. The user wants to access the web application www.siven.ch:
   * The web application is behind a nevisProxy virtual host and protected by a SAML SP Realm.
   * The user uses a browser-based client.
2. As there is no authenticated session, access to the application is blocked.
   * Session tracking is based on a session cookie.
   * Authentication is enforced by nevisProxy.
   * The request is forwarded to nevisAuth, which acts as SP and initiates the SAML flow.
3. The SP checks if the session has been expired.
   * This check is optional and can be enabled in the SAML SP Realm pattern (Session Expiration tab).
   * The SAML SP Realm pattern provides different strategies on how to handle expired sessions. Each strategy corresponds with a field in the Session Expiration tab:
      * Logout Reminder: Renders a page that reminds the user to log out in the future.
      * Timeout Page: Renders a page that informs about the termination of the session due to timeout.
      * Session Expiration Redirect: Redirects to a configurable URL (for example, a hosted resource or the URL of the IDP to trigger IDP-initiated authentication).
4. The SP can also execute an optional custom pre-processing step.
   * You configure this step in the Custom Pre-Processing field of the SAML SP Realm pattern (Advanced Settings tab). Check the pattern's Help section for further information about this advanced feature.
5. The SP now determines which SAML IDP to invoke.
   * This step is not relevant when only one IDP is configured.
   * The IDP is selected based on a selection expression. You configure this expression in the SAML IDP Connector pattern (Selection Expression field, Advanced Settings tab). Check the pattern's Help section for examples.
6. The SP returns an AuthnRequest.
   * The AuthnRequest contains the Issuer of the SP and is signed with the SAML Signer of the SP.
   * The SP stores the current URL (of the application) in a RelayState parameter.
      * The SAML standard demands that the IDP returns this RelayState parameter unchanged.
   * The browser is instructed to send AuthnRequest and RelayState to the IDP. How these parameters are transmitted can be configured in the SAML IDP Connector pattern (Binding: Outbound field, Basic Settings tab):
      * POST-binding ("http-post"): Self-submitting form. This is the default setting.
      * Redirect-binding ("http-redirect"): Using query parameters and a 302 redirect.
7. The IDP consumes the AuthnRequest.
   * The IDP first extracts the Issuer from the AuthnRequest and dispatches the request into the correct IdentityProviderState.
      * Each SAML SP Connector pattern generates one IdentityProviderState.
   * The IdentityProviderState validates the signature of the AuthnRequest.
      * If the signature is not valid, then a standard SAML error response is returned.
8. If the user has no authenticated session on the IDP he has to log in first.
   * The authentication flow is defined by the Authentication Realm pattern assigned to the SAML IDP pattern.
9. Once the session is authenticated, the SAML IDP produces a SAML Response.
   * The Response is sent to the AssertionConsumerServiceURL that has been extracted from the AuthnRequest.
   * If no AssertionConsumerServiceURL is found, then the URL defined in the SAML SP Connector pattern is used.
10. The SP consumes the Response:
   * Based on the Issuer of the Response the corresponding ServiceProviderState for this IDP is selected.
      * Each SAML IDP Connector pattern generates one ServiceProviderState.
   * The ServiceProviderState validates the signature of the Response.
   * If the Response contains an AudienceRestriction then it has to match the current URL.
11. The SP can execute an optional post-processing flow.
   * You configure this flow in the Post-Processing Flow field of the SAML SP Realm pattern (Advanced Settings tab). Check the pattern's Help section for further information about this advanced feature.
12. The SP declares the authentication as done and redirects back to the web application.
   * The URL of the application is taken from the RelayState parameter.
13. As there is an authenticated session now, nevisProxy allows the user to access the application.
   * If an Application Access Token is assigned to the web application, the SAML SP is invoked again to produce that token.
   * If an Authorization Policy is assigned that demands a higher authentication level, a session upgrade may be performed. See the chapter SAML Flow for Session Upgrade for details.
--------------------------------------------------------------------------------
Section: ### SAML-Pattern-map.md
---
sidebar_position: 24
---

# Pattern map

<img className="boxed" src={require('../../assets/SAML-patterns-map.png').default} alt="SAML Pattern map"/>

<body text = "blue">Dark blue background:</body> Used to denote patterns labeled as `Applications`, which are web applications accessable after deployment.

<body text = "darkgoldenrod">Yellow background:</body> Used to denote pattern labeled as `SAML Identity Provider` which are needed for the SAML flow.

<body text = "green">Green background:</body> Used to denote patterns labeled as `Nevis Components` which described the infrastructure.
--------------------------------------------------------------------------------
Section: ### mobile-pattern-map.md
---
sidebar_position: 72
---

# Pattern Map

<img className="boxed" src={require('../../assets/mobile_auth_pattern_map.png').default} alt="Pattern map"/>

<body text = "darkgreen">Dark green background:</body> Used to denote patterns labeled as ‘Nevis Components’ which describes the infrastructure.

<body text = "blue">Blue background:</body> Used to denote patterns labeled as ‘Admin UI’ which describes the admin infrastructure.

<body text = "darkgoldenrod">Yellow background:</body> Used to denote patterns labeled as ‘Login’ which are used to set up a general login flow with Passkey.

<body text = "lightgreen">Light green background:</body> Used to denote patterns labeled as ‘Applications’ which are web applications accessible after deployment.

<body text = "red">Red background:</body> Used to denote patterns labeled as ‘Self Registration’ which are needed for the self Registration Flow.

<body text = "pink">Pink background:</body> Used to denote patterns labeled as ‘SMTP’ which describes the SMTP infrastructure.
--------------------------------------------------------------------------------
Section: ### mobile-authentication.md
---
sidebar_position: 71
sidebar_label: Mobile Authentication
---

import Vimeo from '../../../../src/components/Vimeo';

# Mobile authentication

Mobile authentication is the verification of a user’s identity through the use of a mobile device and one or more authentication methods to ensure secure access. To keep your online services safe, enabling your users to use mobile authentication across their devices is the single most important step you can take.

<img className="boxed" src={require('../../assets/how-fido-works.png').default} alt="How FIDO works in a nutshell"/>

Using biometric capabilities of modern mobile devices is a convenient solution to multi-factor authentication (MFA). To verify an individual's identity it uses possession of a mobile device as a first factor, and a unique biometric identifier on that device as a second factor. Combining two factors into one.

<img className="boxed" src={require('../../assets/scan-qr.png').default} alt="QR Code Sign-in"/>

Our product allows organisations to build a seamless mobile authentication experience. The Access App and Mobile SDK are based on the open FIDO UAF standard. We support various biometric authentication methods and fallbacks:

* Complete FaceID, TouchID support on Apple iPhone devices.
* Fingerprint support and Biometric Prompt support on Android devices.
* Secure PIN-based fallback method, if a user does not have biometrics enabled.

For more details please visit our doc repository: [Overview | Nevis documentation](../../mobile-auth-concept-and-integration-guide/overview.md) & FIDO Alliance materials: [User Authentication Specifications Overview - FIDO Alliance](https://fidoalliance.org/specifications/).

Using this project template, users can sign-up for an account or sign-in using username & password followed by a QR code based 2nd factor authentication - representing the UAF based, out-of-band registration & authentication flows. 

There is always a fallback mechanism providing a one-time-password sent to the registered email address as eTAN code.

:::info Important Note

In order to work with this project template you need to have a proper access app installed on your mobile device. There is 2 options:

1. You can use a demo one (available for both [iOS](https://testflight.apple.com/join/q0lkyEVR) & [Android](https://appdistribution.firebase.google.com/pub/i/b58532b9c7f4ced2)).
2. You can go through the official process of [Ordering an access app](../../../nevisaccessapp/ordering-an-access-app) and have it dedicated, branded and configured for you.
:::

## The project template​

The NEVIS project template Mobile authentication is configured to use an example Web application (`http://example.com`) by default as a protected web service.

<img className="boxed" src={require('../../assets/mobile-auth.png').default} alt="Mobile Authentication"/>

<Vimeo src="https://player.vimeo.com/video/924603338" title="Mobile authentication tutorial"/>
--------------------------------------------------------------------------------
Section: ### Scenario for testing a successful deployment
0. Install your mobile access app (iOS or Android) and configure your project according to the template description.
1. Deploy your project.
2. Launch your example Web application at https://your_domain_goes_here/app/ - replace “your_domain_goes_here” with your real domain name!
3. Register a new user and use your access app (already installed on your mobile phone) to authenticate by reading a QR code provided by the server.
4. Log-out.
5. Log-in with the account you just registered using your access app to authenticate by reading a QR code provided by the server.
6. Now it is time to replace the exposed example application by your own service and enjoy the NEVIS security experience!
--------------------------------------------------------------------------------
Section: ### Pattern-map.md
---
sidebar_position: 14
---

# Pattern map

<img className="boxed" src={require('../../assets/Basic-IDM-template-overall.png').default} alt="Basic IDM template"/>

<body text = "blue">Dark blue background:</body> Used to denote patterns labeled as `Applications`, which are web applications accessible after deployment.

<body text = "darkcyan">Light blue background:</body> Used to denote patterns labeled as `Login Flow` which are used to set up a general login flow with password.

<body text = "darkgoldenrod">Yellow background:</body> Used to denote pattern labeled as `Self Registration Flow` which are needed for the self Registration Flow.

<body text = "green">Green background:</body> Used to denote patterns labeled as `Nevis Compontents` which described the infrastructure.

<body text = "lightgreen">Light green background:</body> Used to denote patterns labeled as `SMTP` which is used to set up mailing for `E-mail TAN` AuthState.

## Infrastructure patterns

<img className="boxed" src={require('../../assets/Basic-IDM-template-infrastructure.png').default} alt="Infrastructure pattern"/>
--------------------------------------------------------------------------------
Section: ### Open-ID-Connect-Provider.md
---
sidebar_position: 31
sidebar_label: OpenID Connect
---
import Vimeo from '../../../../src/components/Vimeo';

# OpenID Connect

Like SAML, OpenID Connect (OIDC) is an *authentication protocol*, facilitating the exchange of authorization credentials and basic profile information between identity providers and reliant parties (aka service providers). In other words, OIDC is a set of defined process flows for *federated authentication*. These flows are built using the OAuth 2.0 process flows as a base, adding a simple identity layer over it to allow for federated authentication.

OpenID Connect works both for *web and mobile applications*. Considering the fact that SAML only works for web applications, OIDC is the standard to follow when it comes to mobile applications and Javascript.

OpenID Connect lets reliant parties (RP’s) authenticate users across websites and apps without having to own and manage password files. Thanks to OIDC the reliant party knows at anytime what the identity of the person, currently using the browser or native app, is, without having to manage the users identity themselves.

For further information you could read more [here](https://www.nevis.net/en/fundamentals/what-is-oidc).

## The Project template

The Nevis project template OpenID Connect Provider supports username / password login infrastructure. 

<img className="boxed" src={require('../../assets/OpenID-connect-provider.png').default} alt="OpenID connect provider"/>

<Vimeo src="https://player.vimeo.com/video/853677095" title="OpenID Connect Provider Project Template"/>

<img className="boxed" src={require('../../assets/OIDC-project-template.png').default} alt="OIDC project template"/>

## Scenario for testing a successful deployment

Before hooking your services you can fairly simply make sure your deployment works as intended. Following the step-by-step guide below you would be able to verify the major OpenID Connect calls e.g. obtaining access tokens.

The purpose of the Authorization Code flow with PKCE is to acquire an Access Token, which can be added as Bearer token to REST calls made towards a Resource Server.

This flow should be used by single-page (SPA) and other client-side applications which cannot store a client secret as it could easily be extracted.

In order to run a very basic verification you must configure a couple of items as follows:
1. Launch your nevisMETA GUI application at `https://your_domain_goes_here/nevismeta` - replace “your_domain_goes_here” with your real domain name!
2. Login using bootstrap.
3. Choose the pre-configured Default setup.
4. Add & configure META resource server (using the + icon in the upper right corner).
   * Add custom name.
   * For `scope` ADD `openid` & `offline_access` with all flow consent set to NO CONSENT REQUIRED (by default this is set to CONSENT REQUIRED).

 <img className="boxed" src={require('../../assets/Resource-server.png').default} alt="Resource server"/>

5. Add & configure META client (using the + icon in the upper right corner).
   * Add custom name.
   * Redirect URLs: `<put your Azure domain name here>`
   * Registered Scopes: Put both openid & offline_access (start typing the name, then select from the popup list, this way the server and client are associated).
   * Token Endpoint Auth Method: in this example since POSTMAN calls are going to be performed, set this to `CLIENT_SECRET_POST`
   * PKCE Mode: `S_256_REQUIRED`

 <img className="boxed" src={require('../../assets/Meta-client.png').default} alt="Meta Client"/>

6. Prepare the POSTMAN calls (get authorization code, get access token, get refresh token).

 There is a need to generate 2 codes for PKCE:
   * `code_verifier` - must be a random `String` and at least 43 characters long.
   * `code_challenge` - URL-safe base64 encoded SHA256 hash of the `code_verifier`. The codes ensure message integrity. Even if an attacker intercepts the *Authorization Code*, they won't be able to obtain an *Access Token* as they also need the `code_verifier` and the `code_challenge`.

 Example Angular code to generate `code_challenge` from `code_verifier`:

 ```
 import * as CryptoJS from 'crypto-js';
 
 private generateCodeChallenge(code_verifier: string): string {
   return this.base64URL(CryptoJS.SHA256(code_verifier));
 }
 
 private base64URL(value) {
   return value.toString(CryptoJS.enc.Base64)
     .replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
 }
 ```

 Alternatively you can visit [PKCE Tools](https://example-app.com/pkce) and quickly get the codes needed.
 
 On behalf of the client we need to simulate an HTTP GET request to the Identity Suite Authorization endpoint. Example URL (HTTP GET), using POSTMAN GET call:

 ```
 https://<yourserver>.westeurope.cloudapp.azure.com/oauth/authorize
  ?response_type=code
  &code_challenge=U2ZQIMYt1dJ-Vft83__UiJihGh40zoXX5GoOnsDo4BE
  &code_challenge_method=S256
  &client_id=dbd00f622a1f005f
  &redirect_uri=https://<yourserver>.westeurope.cloudapp.azure.com
  &scope=openid,offline_access
 ```

 Besides setting the parameters defined above you’d also need to provide user credentials explicitly in POSTMAN since we do not have a real client running, just simulating it using POSTMAN. Go to the Authorization tab and provide bootstrap user credentials (see example below).

 <img className="boxed" src={require('../../assets/Get-authorization-code1.png').default} alt="Get authorization code"/>

 <img className="boxed" src={require('../../assets/Get-authorization-code2.png').default} alt="Get authorization code"/>

 Upon successful authentication, the authorization endpoint stores the code challenge, generates an Authorization Code, and redirects the user to the return_uri (in case of the example there is no service developed therefore → Page not found)  The code is however added as a query parameter. Example URL (HTTP GET):

 ```
 https://<yourserver>.westeurope.cloudapp.azure.com?code=WyZIgDiGQ0DIvbZM7vmBW2ADw6hzwekZac0oe_ucfYo
 ```

 On behalf of the client we now need to simulate an HTTP POST request to the *Identity Suite* Token endpoint (together with the `code_verifier`). Example URL (HTTP POST), using POSTMAN GET call:

 ```
 https://<yourserver>.westeurope.cloudapp.azure.com/oauth/token
 grant_type=authorization_code
 &client_id=dbd00f622a1f005f
 &client_secret=
 &code_verifier=DP0DueG8PR9rj6ITsWg7YHEUEg5QPttl84wq6xA7NNo9z0vLmCWNTYPKYrjCC9hh
 &code=WyZIgDiGQ0DIvbZM7vmBW2ADw6hzwekZac0oe_ucfYo
 &redirect_uri=https://<yourserver>.westeurope.cloudapp.azure.com
 ```

 <img className="boxed" src={require('../../assets/Get-access-token.png').default} alt="Get access token"/>

 The token endpoint verifies the code_challenge and the code_verifier. The token endpoint returns an Access Token. Depending on the scopes requested, additional tokens will be returned:
   * ID Token: scope `openid`
   * Refresh Token: scope `offline_access`

 ```script title="Example JSON response"
 {
   "access_token":"...",
   "refresh_token":"...",
   "id_token":"...",
   "token_type":"Bearer",
   "expires_in":3600
 }
 ```

7. Now it is time to configure your own resource server(s) & client and enjoy the Nevis security experience!

## User-facing flows

1. [Authorization code flow with PKCE](OIDC-Token-Authorization-Code-Flow.md)
2. [Refresh token flow](Refresh-Token-Flow.md)
--------------------------------------------------------------------------------
Section: ### nevisauth-fido-authstates.md
---
sidebar_position: 10
---

# FIDO AuthStates

nevisFIDO provides its own AuthStates, which you can configure and use in nevisAuth.

## Installation

The nevisFIDO AuthStates are installed using the [client RPM](../../nevisfido-component/installation.md#client-rpm-installation). After installing the RPM, the AuthStates and the required dependencies are located under `/opt/nevisfidocl/nevisauth/lib`.

## Configuration

We provide the following AuthStates:
* `FidoUafAuthState`: configure this AuthState, if mobile authentication is executed by an AccessApp, where a browser is not involved. 
  * Example use-case: the user initiates a removal of a credential through their AccessApp, and the process is to be authenticated with mobile authentication.
* `OutOfBandFidoUafAuthState`: configure this AuthState, if mobile authentication is executed by an AccessApp, but the authentication is initiated from a browser from a different device. 
  * Example use-case: the user tries to transfer money via a web application in the browser, and the process is to be authenticated by a push notification sent to the AccessApp, followed by mobile authentication.
* `Fido2AuthState`: configure this AuthState if authentication is executed by the browser and native capabilities of the device. 
  * Example use-case: the user logs into a web application through the browser using the fingerprint scanner of the mobile device.

When you configure a nevisFIDO AuthState, pay attention to the following:

* If the `classPath` attribute is specified in the `AuthEngine` configuration, it has to contain the directory with the nevisFIDO AuthStates directory (as in the following sample code):

  ```xml
  <AuthEngine name="AuthEngine"
              classPath="/var/opt/nevisauth/default/plugin:/opt/nevisauth/plugin:/opt/nevisfidocl/nevisauth/lib"
              classLoadStrategy="PARENT_FIRST"
              useLiteralDictionary="true"
              addAutheLevelToSecRoles="true"
              compatLevel="none"
              inputLanguageCookie="LANG">
  ```

* If you employ a JSON based client, use a `DirectResponseState` AuthState as the `AuthDone` AuthState to make integration easier. For example, the `AuthDone` AuthState in the sample below will return a successful HTTP response with `{ "message" : "successful authentication" }` as body:

  ```xml
  <AuthState name="AuthDone"
             class="ch.nevis.esauth.auth.states.directResponse.DirectResponseState"
             final="true"
             resumeState="false">
      <Response value="AUTH_DONE"/>
      <property name="contentType" value="application/json"/>
      <property name="content" value="{&quot;message&quot;:&quot;successful authentication&quot;}"/>
      <property name="statusCode" value="200"/>
  </AuthState>
  ```

* Restart the nevisAuth instance.
--------------------------------------------------------------------------------
Section: ### outofbandfidouafauthstate.md
---
sidebar_position: 30
---

import REUSE02 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/query-dispatch-target/http-response.md'
import REUSE03 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/out-of-band-authstate-dispatch-token-response.md'
import REUSE04 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/succeeded-status/response-body.md'
import REUSE05 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/dispatch-png-qr-code-with-encryption/response-body.md'
import REUSE06 from '/docs/reusable-md/_new-auth-http-client-information.md'

# OutOfBandFidoUafAuthState

<REUSE06/>

## Introduction and overview

The `OutOfBandFidoUafAuthState` AuthState manages the UAF authentication in a nevisFIDO server by invoking the [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service). The typical use case is that a client wants to access an application using a desktop, whereas the authentication is done with a mobile device. In this case, a token is dispatched to the mobile device, where the user authenticates.

The UAF authentication process including nevisAuth and the `OutOfBandFidoUafAuthState` is as follows:

1. The `OutOfBandFidoUafAuthState` sends a [dispatch target query](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/dispatch-target-service#query-dispatch-target) to retrieve the dispatch targets defined for the user. The `fidoUafUsername` attribute is used to generate this request. The value of this attribute (that is, the username) can be retrieved in different ways:

    * By authenticating the user through an AuthState that is configured before the `OutOfBandFidoUafAuthState`. The  username value can be a variable expression using `notes`.

    * The HTTP client provides the FIDO UAF username directly in the incoming request as JSON or FORM parameters. The username value can be a variable expression using `inargs`.

2. The nevisFIDO server returns the [list of dispatch targets](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/dispatch-target-service#response-body-3) to nevisAuth, which forwards the dispatch targets to the client. If no dispatch targets are found, nevisAuth returns an empty list.
3. The client selects one of the dispatch targets, if required in interaction with the user. Subsequently, the client sends a request with the dispatch target ID and the username to nevisAuth.
4. The `OutOfBandFidoUafAuthState` sends a dispatch token request to the nevisFIDO server with the provided dispatch target ID. nevisFIDO uses the [Dispatch Token Service](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service) for this. In the context of transaction confirmation, the `OutOfBandFidoUafAuthState` can be configured with a list of FIDO UAF `transaction`. This list of `transaction` will be sent to the nevisFIDO server as part of the `GetUAFRequest`
5. The nevisFIDO server returns a dispatch token response to nevisAuth, which forwards the response to the client. The dispatch token response contains a FIDO UAF session ID. See [Example Response Using FCM Dispatcher](/nevisfido/reference-guide/uaf-http-api/out-of-band-services/token-services/dispatch-token-service#example-response-using-fcm-dispatcher) for a response example.
6. The client queries nevisAuth. It depends on the configuration of the `fidoUafSessionId` property in the `OutOfBandFidoUafAuthState` whether the client must provide this property. By default, the client is required to send the `fidoUafSessionId` property in a POST with a payload like this:

   ```json
   { "fidoUafSessionId" : "asdetwdIDsdfsewSAdsds09823423sdfsd9ds" }
   ```

7. The `OutOfBandFidoUafAuthState` processes the authentication status query, by asking the nevisFIDO server whether the  user was actually authenticated. If so, the `OutOfBandFidoUafAuthState` has a transition `ok`. nevisAuth sends a response to the client, including a payload like this:

   ```json
   {
     "status" : "succeeded",
     "timestamp" : "2018-12-14T20:37:48.556Z",
     "tokenInformation" : {
       "tokenResult" : "tokenRedeemed",
       "dispatcherInformation" : {
         "name" : "firebase-cloud-messaging",
         "response" : "successful dispatch"
       }
     },
     "uafStatusCode" : 1200,
     "userId" : "123122233",
     "authenticators" : [ {
       "aaid" : "ABBA#0001"
     } ]
   }
   ```

8. The client must send another request to nevisAuth to continue with the authentication process.

```plantuml title="OutOfBandFidoUafAuthState example flow"
@startuml

skinparam shadowing false

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white
 
    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}


title Authentication Flow with DispatchTokenAuthState

actor "Client (Web Application)" as client
actor "FIDO Mobile client" as mobileclient
participant nevisProxy as proxy

box "nevisAuth"
    participant DispatchTokenAuthState as uaf
    participant OkAuthState as ok
    participant FailedAuthState as failed
end box

participant nevisFIDO as fido

== Dispatch Target Query ==

client -> proxy : ""username""
note right
authenticate
end note
proxy -> uaf : ""inargs:username""
activate uaf
uaf -> fido : Dispatch Target Query
activate fido
fido -> uaf : Dispatch Targets
deactivate fido
uaf -> uaf : isDirectResponse = true
uaf -> proxy : DispatchTargets
deactivate uaf
proxy -> client : DispatchTargets

== Dispatch Token Request ==

client -> proxy : ""dispatch target ID + username""
note right
authenticate
end note
proxy -> uaf : ""dispatch target ID + username""
activate uaf
uaf -> fido : Dispatch Token Request
activate fido
fido -> uaf : Dispatch Token Response
deactivate fido
uaf -> uaf : store ""fidoUafSessionId"" in ""session""
uaf -> uaf : isDirectResponse = true
uaf -> proxy : Dispatch Token Response
deactivate uaf
proxy -> client : Dispatch Token Response
client -> client : store ""fidoUafSessionId""

== Token Dispatch ==

fido -> mobileclient : ""token""
deactivate fido
mobileclient -> proxy : ""token""
note left
redeem token
end note
activate fido
proxy -> fido : ""token""
fido -> proxy : ReturnUafRequest(""AuthenticationRequest"")
deactivate fido
proxy -> mobileclient : ReturnUafRequest(""AuthenticationRequest"")

== Authentication Response ==

deactivate fido
mobileclient -> proxy : SendUafResponse(""RegistrationResponse"")
activate fido
proxy -> fido : SendUafResponse(""RegistrationResponse"")
activate fido
fido -> fido : session status = ""succeeded"" / ""failed""
fido -> proxy : ""ServerResponse""
deactivate fido
proxy -> mobileclient : ""ServerResponse""


== Status ==

client -> proxy : ""fidoUafSessionId""
proxy -> uaf : ""o.fidoUafSessionId.v""
activate uaf
uaf -> fido : operation status for ""fidoUafSessionId""
activate fido
fido -> uaf : ""clientAuthenticating"" / ""succeeded"" / ""failed""
deactivate fido
uaf -> uaf : set transition result ""OK"" / ""FAILED"" /""ERROR"" in session
uaf -> uaf : isDirectResponse = true
uaf -> proxy : status
deactivate uaf
proxy -> client : status

== Auth State Transition ==

client -> proxy : ""fidoUafSessionId""
proxy -> uaf : ""o.fidoUafSessionId.v""
activate uaf

uaf -> uaf : get transition result from session

alt transition result ""OK""

uaf -> ok : ResultCond="ok"

activate ok
ok --> proxy
deactivate ok

else transition result ""FAILED"" / ""ERROR""

uaf -> failed
deactivate uaf
activate failed

failed --> proxy
deactivate failed

end

@enduml
```

:::info

To allow chained UAF AuthStates, nevisAuth will remove the stored FIDO UAF session ID every time an AuthState transition occurs in the `OutOfBandFidoUafAuthState`.

As a consequence, the HTTP client will receive the `authenticated` status only once for a given session ID. The next queries with the same session ID will return an `unknown` status.
This is to prevent the following undesired situation:

Suppose a given configuration consists of the two chained UAF AuthStates *AuthState1* and *AuthState2*. If the user authenticates in *AuthState1*, the AuthEngine will make *AuthState2* the current AuthState. If the client sends an authentication status request with the session ID used in *AuthState1*, and the session has not been cleaned up, then the user will be considered authenticated in *AuthState2*.
:::
--------------------------------------------------------------------------------
Section: ### device-service.md
---
sidebar_position: 55
---

import REUSE01 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/request-headers.md'
import REUSE02 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/response-headers.md'
import REUSE03 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/http-request.md'
import REUSE04 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/curl-request.md'
import REUSE05 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device-header-device-signature-as-json.md'
import REUSE06 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device/http-response.md'
import REUSE07 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device-decrypted-response.md'

import REUSE11 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/request-headers.md'
import REUSE12 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/request-body.md'
import REUSE13 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/http-request.md'
import REUSE14 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/curl-request.md'
import REUSE15 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets-as-json.md'
import REUSE16 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-delete-credentials-and-dispatch-targets-as-json.md'
import REUSE17 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/modify-device-update-dispatch-targets/http-response.md'

import REUSE21 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device/request-headers.md'
import REUSE22 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device/http-request.md'
import REUSE23 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device/curl-request.md'
import REUSE24 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device-header-device-signature-as-json.md'
import REUSE25 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/delete-device/http-response.md'

import REUSE31 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/request-headers.md'
import REUSE32 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/response-headers.md'
import REUSE33 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/http-request.md'
import REUSE34 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/curl-request.md'
import REUSE35 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device-oob-operations-header-device-signature-as-json.md'
import REUSE36 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-oob-operations/http-response.md'
import REUSE37 from '/docs/reusable-md/nevisfido/generated-snippets/2.0.0/get-device-oob-operations-decrypted-response.md'

# Device Service

This chapter describes the Device Service. The Device Service is **not a standard FIDO service**, but a proprietary nevisFIDO functionality.

:::info
The Device Service is an HTTP API to be used by the [Nevis Mobile Authentication SDK](/mobilesdk), so it is aimed for mobile applications. Other applications, such as administration web applications, should not try to use it. It is presented here for reference.

This service is in **experimental** state and can be modified or dropped in future releases without notice.
:::

:::caution Android SDK 3.6.1 / 3.6.2 device identifier issue

Registrations created with Android SDK [3.6.1](/mobilesdk/release_notes/android-release-notes#android-sdk-361---24012024) and [3.6.2](/mobilesdk/release_notes/android-release-notes#android-sdk-362---19032024) resulted in a non-unique [device identifier](https://docs.nevis.net/mobilesdk/concept/concept-description/device-management#device-identifier).

Due to this, Android SDK 3.7.0 will not query these endpoints for affected users.

Refer to the [issue description](/mobilesdk/appendixes/known-issues#non-unique-device-identifier-android-sdk) for details.

:::

A device represents a mobile device. A mobile device has FIDO UAF credentials and dispatch targets. The Authentication Mobile SDK allows the definition of multiple accounts in a device and thus the FIDO UAF credentials and dispatch targets of a device can be associated with multiple identities.

The Device Service consists of three parts or endpoints: the Get, Modify and Delete Device.

## Get Device Credentials

This section describes the Get Device Credentials part of the Device Service.
--------------------------------------------------------------------------------
Section: ### HTTP Status Codes
The following HTTP status codes are returned by the Create Dispatch Target part/endpoint of the Dispatch Target Service:

| HTTP Code | Description                                                                                                                                                                                                                                  |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 201       | Created   The server successfully created the dispatch target.                                                                                                                                                                            |
| 400       | Bad Request   The provided payload is not properly formatted.                                                                                                                                                                             |
| 401       | Unauthorized   The request was not authorized. There is an invalid SecToken or unresolved username.                                                                                                                                       |
| 403       | Forbidden   The user is not found in the credential repository based on the provided username.        |
| 405       | Method Not Allowed   The method of the received request was not `POST`.                                                                                                                                                                   |
| 406       | Not Acceptable   The `Accept` header is not properly set to `application/json`.                                                                                                                                                           |
| 415       | Unsupported Media Type   The `Content-Type` header is not properly set to `application/json;charset=UTF-8`.                                                                                                                               |
| 422       | Unprocessable Entity   The request could not be processed. For example, because the name of the provided dispatch target is already in use by another dispatch target of the user, or because the specified dispatcher is not configured. |
| 500       | Internal Server Error   The server could not process the request because of an unexpected error.                                                                                                                                          |

## Modify Dispatch Target

This section describes the Modify part of the Dispatch Target Service.

The modify dispatch target HTTP API is particular regarding the approach used to guarantee that the HTTP client is authorized to perform the operation (i.e. to modify the dispatch target). Instead of using authorization headers (containing for instance a `SecToken`) to do the authorization check, the client must send the payload with a signature. This signature is generated with the private signature key of the dispatch target to be modified. nevisFIDO will only process request that are properly signed. This guarantees that only clients possessing the private signature key of the dispatch target are allowed to modify it. This is the reason why the private signature key is assumed to be safely stored by the HTTP client.

:::info
The modify dispatch target HTTP API is intended to be used by the [Nevis Mobile Authentication SDK](/mobilesdk) only, so it is aimed for mobile applications. Other applications, such as administration web applications, should not use it. It is presented here for reference.
:::
--------------------------------------------------------------------------------
Section: ### Server Configuration
The server configuration defines the configuration of the main web server.

* `server.port`

  Web application port. If not specified, the default value is 8080.
* `server.host`

  Network address to which the server must bind. By default, it binds to all available interfaces (that is, "0.0.0.0").

* `server.protocol`

  Either `http` or `https`. It is advisable to always run nevisFIDO in `https` mode. Refer to the `server.tls`
  settings for configuring TLS if set to `https`.

* `sever.connection-timeout`

  The time after which idle connections will be terminated. The default value is 30 seconds. If no time unit is
  provided, seconds will be used.

* `sever.tls.keystore`

  Path to the keystore that holds the TLS certificate of nevisFIDO.

* `sever.tls.keystore-passphrase`

  Password used to access the keystore and the key. Use the mechanisms described
  in [Application Configuration](#application-configuration) to avoid providing a plaintext password.

* `sever.tls.keystore-type`

  Defines the type of keystore. It is recommended using a "pkcs12" type of keystore. If not specified, the system will
  use the default keystore type of the Java Virtual Machine that runs nevisFIDO.

* `sever.tls.key-alias`

  Alias that identifies the key in the keystore.

* `sever.tls.require-client-auth`

  `true` if client authentication (2-way TLS) is required for the TLS connection, `false` if no client authentication is
  required.

* `sever.tls.truststore`

  Path to the truststore that holds the TLS certificates (typically a PKCS12 file) that nevisFIDO trusts. These are the
  certificates presented by the client when doing client authentication.

* `sever.tls.truststore-passphrase`

  Password used to access the truststore contents. Use the mechanisms described
  in [Application Configuration](#application-configuration) to avoid providing a plaintext password.

* `sever.tls.truststore-type`

  Defines the type of truststore. It is recommended using a "pkcs12" type of keystore. If not specified, the system will
  use the default keystore type of the Java Virtual Machine that runs nevisFIDO.

* `sever.tls.supported-protocols`

  Provides a list of protocols that are accepted by the client when trying to initiate a connection with TLS. This
  attribute must be provided as an array. By default only `TLSv1.2` is supported.

* `sever.tls.cipher-suites`

  Provides a list of ciphers that are accepted by the client when trying to initiate a connection with TLS. This
  attribute must be provided as an array. The default cipher suites are:
  * `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
  * `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`
  * `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`
  * `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`
  * `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`
  * `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`

```yaml title="Server configuration example"
server:
  port: 9443
  host: localhost
  protocol: https
  connection-timeout: 30s
  tls:
    keystore: conf/nevisfido-server-keystore.p12
    keystore-passphrase: password
    keystore-type: pkcs12
    key-alias: nevisfido
    supported-protocols:
      - TLSv1.2
    cipher-suites:
      - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
      - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
      - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
      - TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
      - TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
      - TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
```
--------------------------------------------------------------------------------
Section: ### WsEventSource.md
---
sidebar_position: 41
---

# WsEventSource

The `WsEventSource` provides a SOAP web-service API to the event system. The SOAP service is published at a configured endpoint. The service offers the following operations which are used to signal an event:

* void signal(EventData event)
* JobResult synchronousSignal(EventData event) throws JobResult

The WSDL and XML schema needed to invoke the service can be found in the JAR `nevisdp- wsclient.jar`. It also contains Java client stubs to invoke the service.

Optional authentication is handled by means of two-way SSL.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: URL of the endpoint | The URL which is used to publish the service. |
| threads | optional: paraVal<br/>default: 10<br/>type: integer | The number of threads the HTTP server uses to handle client requests. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this HTTP server. It uses the Java system property names to set up the key and trust stores. No SSL is used by default. Two-way SSL is the only way to configure authentication. |
| raiseFault | optional: paraVal<br/>default: none<br/>type: boolean | Instead of returning JobResult on the synchronousSignal call, raise a SOAP fault if an error occurs. |

## Example

Register a SOAP web-service at the URL `http://localhost:1234/nevisdp/ws`.

```
<eventSource name="wsEvents" type="WsEventSource">
    <dp:paraVal name="endpoint" value="http://localhost:1234/nevisdp/ws" />
</eventSource>

```
--------------------------------------------------------------------------------
Section: ### RsEventSource.md
---
sidebar_position: 39
---

# RsEventSource

The `RsEventSource` provides a RESTful web-service API to the event system. The REST service is published at a configured endpoint and offers several service interfaces for event generation:

* `/data`: The data interface consumes XML-based events when invoked with a POST operation.

```
POST /nevisdp/event/data HTTP/1.0
Content-Type: application/xml

<eventData>
    <data>
        <name>key1</name>
        <value>value1</value>Y
    </data>
    <data>
        <name>key1</name>
        <value>value1</value>Y
    </data>
</eventData>
```

* `/query`: The query interface uses the URL's query parameter to create an event when invoked with the POST operation.

```
POST /nevisdp/event/query?key1=value1&key2=value2 HTTP/1.0
```

Authentication is handled by means of two-way SSL.

If the result of the triggered jobs is of interest, the WS can be invoked in a synchronous mode by including the matrix parameter „sync" in the URL:

```
POST /nevisdp/event/data;sync=true HTTP/1.0
POST /nevisdp/event/query;sync=true?key1=value1&key2=value2 HTTP/1.0
```

* `/xml`: The xml interface consumes arbitrary XML documents. For every call an event is generated. Data is extracted using X-path expressions.

```
POST /nevisdp/event/xml HTTP/1.0
Content-Type: application/xml

<user>
 <name>Mustermann</name>
 <firstName>Hans</firstName>
</user>
```

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: URL of the endpoint | The URL which is used to create the service. |
| threads | optional: paraVal<br/>default: 10<br/>type: integer | The number of threads the HTTP server uses to handle client requests. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this HTTP  server. It uses the Java system property names to set up the key and trust stores. |
| data | optional: paraMap<br/>default: none<br/>type: string/xpath | Only required when using the XML endpoint. Defines the event's data fields using XPath queries. The current node in the XPath queries is the document root received through the xml endpoint. |
| xpathNamespaces | optional: paraMap<br/>default: none<br/>type: string/string (uri) | Register namespace prefixes to the specified URIs. Those prefixes are used to parse the XPath expressions. The URIs specified have to match the URIs in the XML document. |

## Example

Register a RESTful web-service at URLs:

* `http://localhost:1234/nevisdp/rs/data`
* `http://localhost:1234/nevisdp/rs/query`

```
<eventSource name="rsEvents" type="RsEventSource">
 <dp:paraVal name="endpoint" value="http://localhost:1234/nevisdp/rs" />
</eventSource>
```
--------------------------------------------------------------------------------
Section: ### SoapEventSource.md
---
sidebar_position: 40
---

# SoapEventSource

The `SoapEventSource` provides a SOAP web service API for the event system. The SOAP service provider is published at a configured endpoint and listens for SOAP messages. XPath queries are used to map the incoming message data to the generated event data.

Authentication is handled by means of two-way SSL.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: URL of the endpoint | The URL which is used to create the service. |
| threads | optional: paraVal<br/>default: 10<br/>type: integer | The number of threads the HTTP server uses to handle client requests. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this HTTP server. It uses the Java system property names to set up the key and trust stores. |
| data | required: paraMap<br/>default: none<br/>type: string/xpath | Defines the event's data fields using XPath queries. The current node in the XPath queries is the SOAP message's body. |
| synchronous | optional: paraVal<br/>default: false<br/>type: boolean | Defines whether the SoapEventSource runs in synchronous mode, i.e. returns the result of the triggered jobs. |
| xpathNamespaces | optional: paraMap<br/>default: none<br/>type: string/string (uri) | Register namespace prefixes to the specified URIs. Those prefixes are used to parse the XPath expressions. The URIs specified have to match the URIs in the XML document. |

## Example

Register a SOAP web service at URL

* `http://localhost:1234/nevisdp/soap`

Process message bodies of type:

```
<person id="someId">
    <name>First Last</name>
    <email>mail@domain.com</email>
</person>

<eventSource name="soapEvents" type="SoapEventSource">
    <dp:paraVal name="endpoint" value="http://localhost:1234/nevisdp/soap" />
    <dp:paraMap name="data">
        <value name="id" value="./person/@id" /> (mailto:@id)
        <value name="name" value="./person/name/text()" />
        <value name="email" value="./person/email/text()" />
    </dp:paraMap>
</eventSource>
```
--------------------------------------------------------------------------------
Section: ### NevisIDMConnectionPool.md
---
sidebar_position: 80
---

# NevisIDMConnectionPool

The `NevisIDMConnectionPool` provides access to the NevisIDM administration web service and is used by `NevisIDMSource` and `NevisIDMSink`. It supports three modes of authentication:

* Basic authentication uses basic HTTP authentication with a username and password.
* Client certificate authentication uses a client certification to authenticate for nevisIDM using nevisProxy.
* Ninja authentication uses the Nevis sectoken as credential to access the nevisIDM web services.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: connection url | The connection URL pointing to the administration web service of nevisIDM. |
| wstrustEndpoint | optional: paraVal<br/>default: none<br/>type: connection url | The connection URL pointing to the `wstrust` web services of nevisAuth. |
| loginMode | required: paraVal<br/>default: none<br/>type: login-mode string | The login-mode determines the kind of authentication the pool uses:<br/>`basic`: Use basic HTTP authentication.<br/>`proxyCert`: Use a client certificate and nevisProxy.<br/>`ninja`: Use a Nevis sectoken.  |
| username | optional: paraVal<br/>default: none<br/>type: string | The username used for basic authentication. |
| password | optional: paraVal<br/>default: none<br/>type: string<br/>sensitive: true | The password used for basic authentication. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key- and truststores. |
| wstrustSslSettings | optional: paraMap<br/>default: none<br/>type: connection url | The SSL configuration settings used to perform two-way SSL authentication with the `wstrust` endpoint.  It uses the Java system property names to set up the key and trust stores. |

## Examples
--------------------------------------------------------------------------------
Section: ### SmtpConnectionPool.md
---
sidebar_position: 81
---

# SmtpConnectionPool

The `SmtpConnectionPool` is used to define and configure an SMTP mail server. It is used by the `EmailDataSink` to send e-mail messages.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| connectionUrl | required: paraVal<br/>default: none<br/>type: smtp(s) URL | The URL defining the server's hostname and port. For example: `<smtp://hostname:25>` or `<smtps://hostname:465>`. |
| username | optional: paraVal<br/>default: none<br/>type: string | The username used to authenticate with the SMTP server. |
| password | optional: paraVal<br/>default: none<br/>type: string<br/>sensitive: true | The password used to authenticate with the SMTP server. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key and trust stores. |

## Example

Example using an unencrypted connection:

```
<object type="SmtpConnectionPool" name="mailService">
    <dp:paraVal name="connectionUrl" value="smtp://myhost.ch:25"/>
</object>
```

Example using an SSL connection:

```
<object type="SmtpConnectionPool" name="mailService">
    <dp:paraVal name="connectionUrl" value="smtps://localhost:465"/>
    <dp:paraVal name="username" value="mail-user"/>
    <dp:paraVal name="password" value="secret"/>
    <dp:paraMap name="sslSettings">
        <value name="javax.net.ssl.trustStore" value="truststore.jks"/>
        <value name="javax.net.ssl.trustStorePassword" value="secret"/>
        <value name="javax.net.ssl.trustStoreType" value="jks"/>
    </dp:paraMap>
</object

```
--------------------------------------------------------------------------------
Section: ### HttpConnectionPool.md
---
sidebar_position: 83
---

# HttpConnectionPool

The `HttpConnectionPool` is an HTTP/1.1 compliant HTTP agent implementation based on the Apache HTTP Client. It is, for example, used to connect to the `NevisAgent`. It implements the `org.apache.http.client.HttpClient` interface.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| poolSize | optional: paraVal<br/>default: 8<br/>type: integer | The size of the connection pool. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key and trust stores. |
| proxySettings | optional: paraMap<br/>default: none<br/>type: string/string | The proxy settings used for the HTTP connection. The following values have to be provided: `http.proxyHost`: The hostname of the proxy server; `http.proxyPort`: The port number of the proxy server.  |

## Example

Example configuring an SSL connection:

```
<object type="HttpConnectionPool" name="httpConnection">
    <dp:paraMap name="sslSettings">
        <value name="javax.net.ssl.trustStore" value="truststore.jks"/>
        <value name="javax.net.ssl.trustStorePassword" value="secret"/>
        <value name="javax.net.ssl.trustStoreType" value="jks"/>
        <value name="javax.net.ssl.keyStore" value="keystore.jks"/>
        <value name="javax.net.ssl.keyStorePassword" value="secret"/>
        <value name="javax.net.ssl.keyStoreType" value="jks"/>
    </dp:paraMap>
    <dp:paraVal name="poolSize" value="10"/>
</object>
```

Example configuring of an HTTP proxy:

```
<object type="HttpConnectionPool" name="httpConnection">
    <dp:paraMap name="proxySettings">
        <value name="http.proxyHost" value="proxy.domain.com"/>
        <value name="http.proxyPort" value="3128"/>
    </dp:paraMap>
</object>
```
--------------------------------------------------------------------------------
Section: ### LDAPConnectionPool.md
---
sidebar_position: 79
---

# LDAPConnectionPool

The `LDAPConnectionPool` provides LDAP connections for `DataSource` and/or `DataSink` implementations that need access to databases. It implements the `LdapContextProvider` interface which is used to access an `javax.naming.ldap.LdapContext`. The latter is responsible for connection pooling. Connection pooling of the JDK is used. See [here](http://java.sun.com/products/jndi/tutorial/ldap/connect/pool.html).

Currently, the default connection pooling configuration from the JDK is used. There is no other way than using system properties to configure the sizing of the connection pooling.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| connectionUrl | required: paraVal<br/>default: none<br/>type: connection url starting with`ldaps?://` | The connection URL to be passed to establish a connection. |
| username | optional: paraVal<br/>default: none<br/>type: string | The username DN to be passed to establish a bind. |
| password | optional: paraVal<br/>default: none<br/>type: string<br/>sensitive: true | The binding password to be passed to establish a connection. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key and trust stores. |
| connectionProperties | optional: paraMap<br/>default: none<br/>type: name value pairs | Adds a custom property to the environment of the `InitialLdapContext`. This feature can be used to set, for example, timeout properties. |
| retry | optional: paraVal<br/>default: 5<br/>type: integer | The number of retry attempts the connection pool carried out when a connection cannot be established. |
| retryInterval | optional: paraVal<br/>default: 5<br/>type: integer | The number of seconds between connection trials. |

## Example

Example using an unencrypted connection:

```
<object type="LDAPConnectionPool" name="ldapConnection">
    <dp:paraVal name="connectionUrl" value="ldap://localhost:10389"/>
    <dp:paraVal name="username" value="uid=admin,ou=system"/>
    <dp:paraVal name="password" value="secret"/>
</object>
```

Example using an SSL connection:

```
<object type="LDAPConnectionPool" name="ldapConnection">
    <dp:paraVal name="connectionUrl" value="ldap://localhost:10389"/>
    <dp:paraVal name="username" value="uid=admin,ou=system"/>
    <dp:paraVal name="password" value="secret"/>
    <dp:paraMap name="sslSettings">
        <value name="javax.net.ssl.trustStore" value="truststore.jks"/>
        <value name="javax.net.ssl.trustStorePassword" value="secret"/>
        <value name="javax.net.ssl.trustStoreType" value="jks"/>
    </dp:paraMap>
</object>
```
--------------------------------------------------------------------------------
Section: ### SoapConnectionPool.md
---
sidebar_position: 82
---

# SoapConnectionPool

The `SoapConnectionPool` is used to define a SOAP web service endpoint. It creates a SOAP dispatcher using an endpoint URL, a web service qualified name and a port qualified name.

## Configuration

| Name | Type, usage constraints, defaults | Description |
| --- | --- | --- |
| endpoint | required: paraVal<br/>default: none<br/>type: http URL | The endpoint URL of the web service. |
| serviceName | required: paraVal<br/>default: none<br/>type: QName | The qualified name of the web service. |
| portName | required: paraVal<br/>default: none<br/>type: QName | The qualified name of the web service's port. |
| sslSettings | optional: paraMap<br/>default: none<br/>type: string/string | The SSL configuration settings used for this connection pool. It uses the Java system property names to set up the key and trust stores. |
| soapVersion | optional: paraVal<br/>default: none<br/>type: QName | The version of the SOAP binding that shall be used. Supported are 1.1 and 1.2. |
| username | optional: paraVal<br/>default: none<br/>type: QName | The username used in the HTTP basic authentication scheme. |
| password | optional: paraVal<br/>default: none<br/>type: string<br/>sensitive: true | The password used in the HTTP basic authentication scheme. If omitted, the username is used as a password instead. |
| sessionMaintain | optional: paraVal<br/>default: true<br/>type: boolean | A Boolean value indicating whether the SOAP connection shall maintain a session and store session cookies. |

## Example
--------------------------------------------------------------------------------
Section: ### Repositories.md
---
sidebar_position: 15
---

# Repositories

All runtime data in the nevisDataPorter is stored in *repositories*. A repository is reminiscent of a scope, e.g., page, request or session known in web applications. Each repository has a unique *name*. The name of the repository and the name of the data item can be used to access any data from within the XML-configuration using the unified expression language specified as part of the JSP 2.1 standard (JSR-245).

The following table gives a short overview of the existing repositories in use.

| Repository | Name | Description |
| --- | --- | --- |
| Configuration | cfg | Contains all variables defined in the configuration section and all configuration values passed programmatically during the intialization. |
| Runtime configuration | rtCfg | Contains all variables passed programmatically or through the event system during the export of a module. |
| Implementation (plug-in factories) | impl | Internal data repository which is generally not used in configurations. Contains factories which are used to create instances of concrete DataObjects, DataSources, DataFilters and DataSinks. |
| Instance (plug-in instances) | inst | Contains all objects instantiated in any initialization section and all instances which are registered programmatically. |
| Input (data) | in | Contains objects returned from a DataSource. The name is derived from the name of the embedding entity. |
| Output (result objects) | out | Contains objects which have to be exported by a DataSink. The name is derived from the name of the embedding entity. |
| Control (control objects) | ctl | Contains objects which contain control information which can be consumed be any DataFilter in the chain or the DataSink. The name is derived from the name of the embedding entity. |
| Constants | const | Contains constants defined by nevisDataPorter. E.g., the NULL object which is used to have an explicit representation of null. |

In the following chapters some of the repositories are explained in more detail.

## Configuration repository

All variables defined in the configuration section (see Configuration Overview) are put into the configuration repository. Plug-ins can reference these configuration variables. You can also pass configuration variables programmatically from within your application when calling the initial method of the DataPorter object. This allows to parameterize your configuration file. All values passed at the intialization phase are additionally stored in the configuration repository ("cfg"). Values received in the export phase, e.g., from the event system, are stored in the runtime-configuration repository ("rtCfg").

## Implementation repository

All implementations of DataObject, DataSource, DataFilter, DataSink and EventSource are registered programmatically at the implementation repository under a unique name. In the configuration file these names are used to refer to the respective factory. nevisDataPorter uses the configured name to retrieve the corresponding factory from the implementation. This factory is used to create new instances of a given plug-in.

The following configuration fragment shows how the name "LDAPDataSink" is used to create the built-in DataSink to access an LDAP directory.

```
<dataSink type="LDAPDataSink">
    <dp:paraVal name="ldapContext"   value="${inst.initalContext}"/>
    <dp:paraVal name="operation"     value="createOrUpdate"/>
    <dp:paraVal name="basedn"        value="ou=${cfg.appl_ou},${cfg.basedn}"/>
    <dp:paraVal name="rdn"           value="cn=#{in.appl.RESOURCENAME}"/>
</dataSink>
```

Plug-ins can be registered in the configuration file in the setup section.

```
<setup>
    <factory class="ch.nevis.idm.dataporter.factory.NevisIDMConnectionPoolFactory"/>
    <factory class="ch.nevis.idm.dataporter.factory.NevisIDMSourceFactory"/>
    <factory class="ch.nevis.idm.dataporter.factory.NevisIDMSinkFactory"/>
    <dataFunction class="ch.nevis.idm.dataporter.NevisIDMDataFunctions"/>
</setup>
```

Here, the specified class has to implement a Factory interface and has to provide a public parameter- less constructor.

In addition, plug-ins can be registered programmatically with nevisDataPorter by registering a factory using the `registerInstanceFactory(Factoryfactory)` method. The interface Factory defines two methods. The first method returns a description of the plug-in, the second creates a new instance using the passed configuration. The description returned by the first method contains the previously mentioned implementation name, the plug-in type and all its possible and mandatory configuration parameters including their types and possible values.

## Instance repository

Next to the implementation repository there is an instance repository. All the DataObjects that are defined in the global or local initialization sections are automatically registered at the instance repository under the configured names.

The following configuration fragment shows the definition of a JDBC connection pool and can be placed in any initialization section.

```
<object type="JDBCConnectionPool" name="dataSource">
    <dp:paraVal name="connectionUrl"     value="jdbc:oracle:thin:@hispano:49185:ESAU"/>
    <dp:paraVal name="username"          value="system"/>
    <dp:paraVal name="password"          value="managed"/>
    <dp:paraVal name="driver"            value="oracle.jdbc.OracleDriver"/>
</object>
```

Now we can reference the instance dataSource from the example above. The following configuration fragment shows how the previously instantiated JDBCDataSource can be accessed from an the instance repository.

```
<dataSource type="JDBCDataSource">
    <dp:paraVal name="query"         value="select name from application where name in (#?)"/>
    <dp:paraVal name="datasource"    value="${inst.dataSource}"/>
    <dp:paraVal name="parameter"     value="${cfg.appl_list}" separator=","/>
</dataSource>
```

A nevisDataPorter client can programmatically register concrete plug-in instances by using the registerInstance method. E.g., if you run within an application server you may have a javax.sql.DataSource in your JNDI tree which you want to register at the nevisDataPorter so you can use it for all your JDBCDataSource objects.

## Input-, output- and control repository

Each entity in a module has its unique name. The input-, output- and control repositories contain records with names identical to the entity currently in process. Thus the input-, output- and control repositories are related to each other.

Each record returned from the DataSource is stored by nevisDataPorter in the input repository under the name of the embedding entity. The input repository is cleared from all data before the new data is written into it. In the output and control repositories, corresponding identically named empty records are created. Then the DataFilter chain is processed.

A DataFilter may access source records from the input repository or variables from the configuration repository to create attributes on the destination objects or values on the control object.

```
<dataFilter type="ELMappingFilter">
<dp:attrVal name="objectClass"   value="top group" separator=" "/>
<dp:attrVal name="cn"            value="#{in.appl.name}"/>
<dp:attrVal name="description"   value="#{cfg.description}"/>
</dataFilter>
```

In the example shown above, three attributes are created on the target object: The attribute *objectClass* is set to a list containing the values "top" and "group". This is configured in a static way, i.e. the two values are read directly from the configuration file. The second attribute is the most common case. The attribute *cn* is written to the value of the attribute *name* in the input data object. As the current entity is named "appl" in the example (data not shown), the entity is selected in the input repository through the sub-expression "in.appl". The third attribute *description* is set to the value of the attribute *description* stored in the configuration repository ("cfg").

At the end the DataSink exports the destination object to the target system. The records in the control repository are used to pass control messages along the execution path while the records in the output repository hold destination objects to be exported.
--------------------------------------------------------------------------------
Section: ### authentication.md
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import AccountSelector from './account-selector.md'
import AuthenticatorSelector from './authenticator-selector.md'
import PinUserVerifier from './pin-user-verifier.md'
import PasswordUserVerifier from './password-user-verifier.md'
import BiometricUserVerifier from './biometric-user-verifier.md'
import DevicePasscodeUserVerifier from './device-passcode-user-verifier.md'
import FingerprintUserVerifier from './fingerprint-user-verifier.md'

# Authentication

Using the [authentication operation](../../concept/operations/authentication.md), you can verify the identity of the user using an already [registered](registration.md) authenticator.

:::tip
To do an authentication operation, [configure](../configuration.md) and [initialize](../initialization.md) the SDK to obtain a `MobileAuthenticationClient` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/MobileAuthenticationClient.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/mobileauthenticationclient), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmamobileauthenticationclient), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/MobileAuthenticationClient-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/interfaces/MobileAuthenticationClient.html)</sub>.
:::

Depending on the use case, there are two types of authentication: [in-app authentication](#in-app-authentication) and [out-of-band authentication](#out-of-band-authentication).

For more information, see [Authentication](../../concept/operations/authentication.md).

## In-app authentication

For the application to trigger the authentication, provide the name of the user to authenticate to an `Authentication` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/Authentication.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/authentication), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaauthentication), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/Authentication-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/Authentication.html)</sub>, and trigger an in-app authentication.

:::info
In Authentication Cloud, the name is the technical username, that is, the `userId` attribute of the [Authentication Cloud API](/authcloud/api-doc/api-reference/approval-ref).

The `LocalData.accounts` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/localdata/LocalData.html#accounts()), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/localdata/accounts), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmalocaldata/accounts), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/LocalData/accounts.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/LocalData.html#accounts)</sub> method can be used to get the registered accounts, and the `Account.username()` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/localdata/Account.html#username()), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/account/username), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaaccount/username), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/Account/username.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/Account.html#username)</sub> method to get the user name of each account.

:::

Provide an [authenticator selector](#authenticator-selector), which returns the authenticator to be used.

Depending on the authenticator used to authenticate, provide any of the corresponding user verifiers: [PIN user verifier](#pin-user-verifier), [password user verifier](#password-user-verifier), [biometric user verifier](#biometric-user-verifier), [device passcode user verifier](#device-passcode-user-verifier), or [fingerprint user verifier](#fingerprint-user-verifier).

<Tabs groupId="code-snippets">

  <TabItem value="kotlin" label="Android/Kotlin" default>

  ```kotlin title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/DefaultAuthenticationTest.kt
  ```

  </TabItem>

  <TabItem value="java" label="Android/Java">

  ```java title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/DefaultAuthenticationTest.java
  ```

  </TabItem>

  <TabItem value="swift" label="iOS/Swift">

  ```swift title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/AuthenticationTests.swift
  ```

  </TabItem>

  <TabItem value="objective-c" label="iOS/Objective-C">

  ```objectivec title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/NMAAuthenticationTests.m
  ```

  </TabItem>

  <TabItem value="dart" label="Flutter/Dart">

  ```dart title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/authentication_test.dart
  ```

  </TabItem>

  <TabItem value="typescript" label="React Native/TypeScript">

  ```typescript title="Authentication" tag=authentication path=/mobilesdk/3.8.0/code-snippets/Authentication.test.tsx
  ```

  </TabItem>

</Tabs>

## Out-of-band authentication

When the authentication is initiated in another device or application, the information required to process the operation is transmitted through a QR code or a link. An example of out-of-band authentication is the case where the user wants to do a bank transfer using a web application in a laptop, and the server sends a push notification to the application asking for authentication.

The out-of-band authentication is done in three phases:

1. The payload obtained from the QR code or the link is provided to an `OutOfBandPayloadDecode` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/outofband/OutOfBandPayloadDecode.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/outofbandpayloaddecode), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaoutofbandpayloaddecode), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/OutOfBandPayloadDecode-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/OutOfBandPayloadDecode.html)</sub> to obtain an `OutOfBandPayload` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/outofband/OutOfBandPayload.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/outofbandpayload), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaoutofbandpayload), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/OutOfBandPayload-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/OutOfBandPayload.html)</sub> object. The payload to be provided is of type:

```json
{
    "nma_data" : {
        "token" : "b4b07559-f934-4597-a1c5-44d89f691e8f",
        "redeem_url" : "https://fido.siven.ch/nevisfido/token/redeem/authentication"
    },
    "nma_data_content_type" : "application/json",
    "nma_data_version" : "1"
}
```

For more information on how to obtain the `OutOfBandPayload`, see [Obtain an out-of-band payload](other-operations.md#obtain-an-out-of-band-payload).

2. Provide the `OutOfBandPayload` to an `OutOfBandOperation` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/outofband/OutOfBandOperation.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/outofbandoperation), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaoutofbandoperation), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/OutOfBandOperation-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/OutOfBandOperation.html)</sub>. When building the `OutOfBandOperation`, invoke the `OutOfBandOperation.onAuthentication` method with an object taking an `OutOfBandAuthentication`.

3. Invoke `OutOfBandOperation.execute`. If the provided payload is successfully redeemed in the server, and it corresponds to an authentication, the object provided in `OutOfBandOperation.onAuthentication` is invoked with an `OutOfBandAuthentication` <sub>[java](pathname:///mobilesdk/3.8.0/api-references/javadoc/ch/nevis/mobile/sdk/api/operation/outofband/OutOfBandAuthentication.html), [swift](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/outofbandauthentication), [objc](pathname:///mobilesdk/3.8.0/api-references/swift/documentation/nevismobileauthentication/nmaoutofbandauthentication), [flutter](pathname:///mobilesdk/3.8.0/api-references/flutter/nevis_mobile_authentication_sdk/OutOfBandAuthentication-class.html), [react native](pathname:///mobilesdk/3.8.0/api-references/react_native/classes/OutOfBandAuthentication.html)</sub>.

4. Provide an [authenticator selector](#authenticator-selector), and the required user verifiers to the `OutOfBandAuthentication`.

5. Invoke `OutOfBandAuthentication.execute` to continue with the operation.

<Tabs groupId="code-snippets">

  <TabItem value="kotlin" label="Android/Kotlin" default>

  ```kotlin title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/DefaultOutOfBandAuthenticationTest.kt
  ```

  </TabItem>

  <TabItem value="java" label="Android/Java">

  ```java title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/DefaultOutOfBandAuthenticationTest.java
  ```

  </TabItem>

  <TabItem value="swift" label="iOS/Swift">

  ```swift title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/OutOfBandOperationTests.swift
  ```

  </TabItem>

  <TabItem value="objective-c" label="iOS/Objective-C">

  ```objectivec title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/NMAOutOfBandOperationTests.m
  ```

  </TabItem>

  <TabItem value="dart" label="Flutter/Dart">

  ```dart title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/out_of_band_operation_test.dart
  ```

  </TabItem>

  <TabItem value="typescript" label="React Native/TypeScript">

  ```typescript title="Out-of-Band Authentication" tag=outofbandauthentication path=/mobilesdk/3.8.0/code-snippets/OutOfBandOperation.test.tsx
  ```

  </TabItem>

</Tabs>
--------------------------------------------------------------------------------
Section: ### Breaking Changes
The API is backwards compatible with the previous 3.x versions, but there are some breaking changes that affect how to use the SDK to build your application using the `release` flavor:

* You must copy a binary in the machine building the application and set the `FINALIZE_ANDROID_ROOT` to point to the directory where the binary is copied.
* The name of the finalization JAR file has changed.

See the [Android installation](../guide/installation/android-installation.md) for details.

## Android SDK 3.5.1 - 17.11.2023

* FIXED: We fixed an issue which caused improper authorization cookies being returned by the SDK in case the Accounts were registered against multiple backends (NEVISACCESSAPP-5386).

## Android SDK 3.5.0 - 09.10.2023

* FIXED: The SDK relies on the system CA certificates to validate the server certificate and is strict doing hostname validation. (NEVISACCESSAPP-5210)
* FIXED: The user interaction timeout is not triggered during PIN authentication if the authenticator is in cool down mode. (NEVISACCESSAPP-5225)
--------------------------------------------------------------------------------
Section: ### In-app authentication
After registration, the user is able to authenticate in-app using FIDO UAF-based authentication. First, the mobile application initiates the authentication flow by contacting the backend. This is usually done through a custom backend, such as a custom application or API gateway.

```plantuml

skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  borderColor #CDD2D4
  backgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

title Authentication Cloud In-App Authentication

legend right

<color:BF3666><size:24><&arrow-right></size>Custom Implementation</color>
<color:168CA9><size:24><&arrow-right></size>Nevis APIs</color>

end legend

actor User as user

box "Mobile Device"
    participant "Mobile Application" as mobile  #499985
    participant "Nevis SDK" as sdk
end box

participant "Custom Backend" as backend  #499985
participant "Nevis Authentication Cloud" as api


user -[#BF3666]> mobile++: authenticate
group <color:168CA9>&#8505;</color> See Developer Guide <b>Operations - Authentication</b>
autonumber
mobile -> sdk++: ""client.operations().authentication()""
autonumber stop
sdk -> api++: ""uaf/1.1/request/authentication""
api --> sdk--: UafRequest
sdk -> api++: ""/_app/uaf/1.1/facets""
api --> sdk--: trusted facets
sdk -> mobile: request authentication information
mobile -> user: request authentication information
user -> mobile: provide authentication information
mobile -> sdk: provide authentication information
sdk -> api++: ""/_app/uaf/1.1/authentication""
hnote over api
  Process FIDO UAF authentication
end note
api --> sdk--: ok (JWT token)
sdk -> mobile--: ""onSuccess(JWT token)""
end group
mobile -[#BF3666]> backend++: verify authentication (JWT token)
autonumber resume
backend -[#BF3666]> api++: ""/api/v1/introspect (JWT token)""
autonumber stop
api -> backend--: status ""active=true""
hnote over backend
  verify and complete authentication 
  on your backend
end hnote
backend -[#BF3666]> mobile--: user authenticated <color:#499985><&check></color>
mobile -[#BF3666]> user: user authenticated <color:#499985><&check></color>
mobile -[#BF3666]> backend--: perform authenticated operations
```

1. You use the SDKs [authentication operation](guide/operation/authentication#in-app-authentication) to start the authentication process. The process will involve asking the user to provide biometric, PIN or device passcode authentication information.
2. After a successful authentication, the SDK will return a `JWT`. To validate the token, call the [`api/v1/introspect` endpoint](/authcloud/api-doc/api-reference/introspect-ref).

:::tip

* Concept

  For more information regarding the registration concept, see the [SDK Concept Guide](concept/operations/authentication#in-band-authentication) chapter.

* Mobile SDK Developers

  For hands-on information on how to use the SDK to achieve in-app authentication, see the [Developer Guides Operations](../guide/operation/authentication.md#in-app-authentication) chapter.

* Authentication Cloud API

  For more information regarding the Authentication Cloud API, visit [Authenticate transactions with QR code or deep link](/authcloud/api-doc/api-use-cases/mobile-app/authenticate-QR-code) or [Authenticate transactions with push notification](/authcloud/api-doc/api-use-cases/mobile-app/authenticate-push)

* Authentication Cloud Concept

  For more information about available authentication methods, visit the [Authentication methods comparison](/authcloud/authentication-methods) chapter.

:::

## Out-of-band registration

```plantuml
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  borderColor #CDD2D4
  backgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

title Authentication Cloud Out-Of-Band Registration

legend right

<color:BF3666><size:24><&arrow-right></size>Custom Implementation</color>
<color:168CA9><size:24><&arrow-right></size>Nevis APIs</color>

end legend

actor User as user

participant  "PC/Laptop" as pc #499985

box "Mobile Device"
    participant "Mobile Application" as mobile #499985
    participant "Nevis SDK" as sdk
end box

participant "Custom Backend" as backend  #499985
participant "Nevis Authentication Cloud" as api

user -[#BF3666]> pc++: authenticate
pc -[#BF3666]> backend++: authenticate
user -[#BF3666]> pc: register device
pc -[#BF3666]> backend: register

autonumber
backend -[#BF3666]> api++: ""/api/v1/users/enroll""
hnote over api
  Initiate out-of-band registration
  to obtain the token required for
  processing the FIDO UAF registration
end hnote

api --> backend--: enroll response (""enrollment.appLinkUri"", ""enrollment.statusToken"")
backend --[#BF3666]> pc--: render QR code / link
autonumber stop

loop
  pc -[#BF3666]> backend++: poll  
  autonumber resume
  backend -[#BF3666]> api++: ""/api/v1/status (statusToken)""  
  api --> backend--: status ""pending""
  autonumber stop
  backend --[#BF3666]> pc--: waiting  
end loop

user -[#BF3666]> mobile++: open app
user -[#BF3666]> mobile: scan QR Code

group <color:168CA9>&#8505;</color> See Developer Guide <b>Operations - Registration</b>

autonumber resume
mobile -> sdk++: ""operations().outOfBandOperation().onRegistration()""
autonumber stop
sdk -> api++: ""_app/token/redeem/registration""
hnote over api
  Initiate device registration based
  on the obtained token
end hnote
api --> sdk--: UafRequest

sdk -> api++: ""/_app/uaf/1.1/facets""
api --> sdk--: trusted facets

sdk -> mobile: request registration information
mobile -> user: request registration information
user -> mobile: provide registration information
mobile -> sdk: provide registration information
sdk -> api++: ""/_app/uaf/1.1/registration""
hnote over api
  Complete device registration
end hnote
api --> sdk--: ok
sdk -> mobile--: onSuccess()
end group
mobile -[#BF3666]> user--: user registered <color:#499985><&check></color>

loop
  pc -[#BF3666]> backend++: poll  
  backend -[#BF3666]> api++: ""/api/v1/status""
  autonumber resume    
  api --> backend--: status ""succeeded""
  autonumber stop
  backend --[#BF3666]> pc: device registered <color:#499985><&check></color>  
end loop

```

1. The first HTTP API call to the cloud backend is done against the [`api/v1/users/enroll` endpoint](/authcloud/api-doc/api-reference/registration-ref). This endpoint is usually called by another backend application, for example a custom backend to start a user enrollment. The user enrolment is necessary to create the user in the backend before an actual mobile authentication registration can be performed.
2. The Nevis Authentication cloud returns the enroll response to your backend. The `enrollment.appLinkUri` contains the link required for the registration process. The `enrollment.statusToken` can be used to check the enrollment progress.
3. The `appLinkUri` link can be displayed to the user as clickable link in cases the user operates on a mobile device or rendered in a QR code to allow the user to scan the code using the mobile application or the mobile phones' camera app.
4. The `statusToken` obtained in step 2 is used to poll the Nevis Authentication cloud backend using the [`/api/v1/status` endpoint](/authcloud/api-doc/api-reference/status-ref). By polling the status, your custom backend and web application will be able to determine when the registration was completed successfully and proceed afterwards with your scenario, like showing the user a success message or redirecting them.
5. During an ongoing registration, the status API will return `pending`, indicating that the registration has not been completed yet and has not failed so far.
6. You use the SDKs [out of band registration operation](../guide/operation/registration.md#out-of-band-registration) to start the actual registration process. The process will involve asking the user to provide biometric, PIN or device passcode authentication information. The SDK requires the `appLinkUri` for this, which the app needs to pass after the link has been clicked or the QR code scanned.
7. After the user completed the out-of-band registration in the mobile application, the [`/api/v1/status` endpoint](/authcloud/api-doc/api-reference/status-ref) will return `succeeded` allowing your custom backend and the web application to detect the successful enrollment.

:::tip

* Concept

  For more information regarding the registration concept, see the [SDK Concept Guide](concept/operations/registration#out-of-band-registration) chapter.

* Mobile SDK Developers

  For hands-on information on how to use the SDK to achieve out-of-band registration, see the [Developer Guides Operations](../guide/operation/registration.md#out-of-band-registration) chapter.

* Authentication Cloud API

  For more information regarding the Authentication Cloud API, visit [Register your mobile app](/authcloud/api-doc/api-use-cases/mobile-app/register-mobile-app).

:::

## Out-of-band authentication

```plantuml
skinparam sequence {
    ArrowColor #168CA9
    LifeLineBorderColor #168CA9

    ParticipantBorderColor #12677C
    ParticipantBackgroundColor #168CA9

    ParticipantFontColor white

    DividerBackgroundColor #168CA9
    DividerBorderColor #12677C
    DividerBorderThickness 1
    DividerFontColor white

    BoxBorderColor #CDD2D4
    BoxBackgroundColor #F5F5F5
}

skinparam note {
  borderColor #CDD2D4
  backgroundColor #F5F5F5
}

skinparam legend {
  backgroundColor #F5F5F5
}

title Authentication Cloud Out-Of-Band Authentication

legend right

<color:BF3666><size:24><&arrow-right></size>Custom Implementation</color>
<color:168CA9><size:24><&arrow-right></size>Nevis APIs</color>

end legend

actor User as user

participant  "PC/Laptop" as pc #499985

box "Mobile Device"
    participant "Mobile Application" as mobile #499985
    participant "Nevis SDK" as sdk
end box

participant "Custom Backend" as backend  #499985
participant "Nevis Authentication Cloud" as api


user -[#BF3666]> pc++: authenticate
pc -[#BF3666]> backend++: authenticate
autonumber
backend -[#BF3666]> api++: ""/api/v1/approval"" (channel=app)
hnote over api
  Initiate out-of-band authentication
  to obtain the token required for
  processing the FIDO UAF registration
end note

api --> backend--: approval response (""qrCode"", ""appLinkUri"")
backend --[#BF3666]> pc--: render ""qrCode"" or ""appLinkUri""
autonumber stop

loop
  pc -[#BF3666]> backend++: poll
  autonumber resume
  backend -[#BF3666]> api++: ""/api/v1/status""    
  api --> backend--: status ""pending""  
  autonumber stop
  backend --[#BF3666]> pc--: waiting  
end loop

user -[#BF3666]> mobile++: open app
user -[#BF3666]> mobile: scan QR Code
group <color:168CA9>&#8505;</color> See Developer Guide <b>Operations - Authentication</b>
autonumber resume
mobile -> sdk++: ""operations().outOfBandOperation().onAuthentication()""
autonumber stop
sdk -> api++: ""_app/token/redeem/authentication""
hnote over api
  Initiate device authentication based
  on the obtained token
end hnote
api --> sdk--: UafRequest
sdk -> api++: ""/_app/uaf/1.1/facets""
api --> sdk--: trusted facets
sdk -> mobile: request authentication information
mobile -> user: request authentication information
user -> mobile: provide authentication information
mobile -> sdk: provide authentication information
sdk -> api++: ""/_app/uaf/1.1/authentication""
hnote over api
  Complete device authentication
end hnote
api --> sdk--: ok
sdk -> mobile--: onSuccess()
end group
mobile -[#BF3666]> user--: user authenticated <&check>

autonumber resume
backend -[#BF3666]> api++: ""/api/v1/introspect (statusToken)""
autonumber stop
api -> backend--: ""active=true""
backend --[#BF3666]> pc: authentication successful  <color:#499985><&check></color>
backend--

```

1. The first HTTP API call to the cloud backend is done against the [`api/v1/users/approval` endpoint](/authcloud/api-doc/api-reference/approval-ref). This endpoint is usually called by another backend application, for example a custom backend to start a user authentication. The `channel` defines how the message should be transmitted.
2. The Nevis Authentication cloud returns the approval response to your backend. The `appLinkUri` contains the link required for the authentication process. THe `qrCode` contains a base64 encoded image which can be rendered. The `statusToken` can be used to check the enrollment progress.
3. The `appLinkUri` link can be displayed to the user as clickable link in cases the user operates on a mobile device, otherwise the `qrCode` can be rendered to allow the user to scan the code using the mobile application or the mobile phones' camera app.
4. The `statusToken` obtained in step 2 is used to poll the Nevis Authentication cloud backend using the [`/api/v1/status` endpoint](/authcloud/api-doc/api-reference/status-ref). By polling the status, your custom backend and web application will be able to determine when the authentication was completed successfully and proceed afterwards with your scenario, like showing the user a success message or redirecting them. The response also contains the `token` which can be used with the [introspect endpoint](/authcloud/api-doc/api-reference/introspect-ref).
5. During an ongoing authentication, the status API will return `pending`, indicating that the authentication has not been completed yet and has not failed so far.
6. You use the SDKs [out-of-band authentication operation](guide/operation/authentication#out-of-band-authentication) to start the actual authentication process. The process will involve asking the user to provide biometric, PIN or device passcode authentication information. The SDK requires the `outOfBandPayload` for this which the app needs to pass either after the link has been clicked or the QR code scanned.
7. After the user completed the out-of-band authentication in the mobile application, call the [`api/v1/introspect` endpoint](/authcloud/api-doc/api-reference/introspect-ref) using the `statusToken` received in step 2. The introspect endpoint will reply with `active` indicating the successful authentication.

:::info Status vs introspect endpoint

* The [status endpoint](/authcloud/api-doc/api-reference/status-ref) provides information of an ongoing operation. In addition, it returns the `token` which can be used to query the introspect endpoint.
* The [introspect endpoint](/authcloud/api-doc/api-reference/introspect-ref) is used to check whether a token is valid, and whether the token was actually issued by your Authentication Cloud instance.

The custom backend should call _either_ the status _or_ the introspect endpoint depending on the scenario progress.

:::

:::tip

* Concept

  For more information regarding the out-of-band authentication concept, see the [SDK Concept Guide](concept/operations/authentication#out-of-band-authentication) chapter.
  Be aware that link, QR code or push messages are available for out-of-band authentication.

* Mobile SDK Developers

  For hands-on information on how to use the SDK to achieve out-of-band authentication, see the [Developer Guides Operations](guide/operation/authentication#out-of-band-authentication) chapter.

* Authentication Cloud API

  For more information regarding the Authentication Cloud API, visit [Mobile App](/authcloud/api-doc/api-use-cases/mobile-app/).

* Authentication Cloud Concept

  For more information about available authentication methods, visit the [Authentication methods comparison](/authcloud/authentication-methods) chapter.

:::

:::info Transaction confirmation

The FIDO transaction confirmation is technically the same as a FIDO authentication, but additional information is present in the authentication information request, which gives the user details of the transaction.

For this reason, this chapter does not separately list the transaction confirmation flows. See the [Concept Operations](../concept/operations/transaction-confirmation.md) chapter for additional details.
:::
--------------------------------------------------------------------------------
Section: ### glossary.md
# Glossary

## Client SDK

| Term           | Description                                                                                                                                                                                                                                                                                                                                  | Example                                                                         |
|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| Secure Enclave | The Secure Enclave is a coprocessor fabricated within the system on chip (SoC). It uses encrypted memory and includes a hardware random number generator. The Secure Enclave provides all the cryptographic operations for Data Protection key management and maintains the integrity of Data Protection, even if the kernel is compromised. | All iPhones using the A7 processor or newer contain the Secure Enclave          |
| TPM            | The Trusted Platform Module is an international standard for a secure cryptoprocessor, a dedicated microcontroller designed to secure hardware through integrated cryptographic keys.                                                                                                                                                        | Most newer generation Android devices contain TPM chips to securely store data. |

## General Nevis Mobile Authentication

| Term                             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Example                                                                                                                                                                                                                                                                                                                                                                                                       |
|----------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| In-band communication            | Using the current channel.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | A message is delivered through an already established and currently used HTTP communication channel.                                                                                                                                                                                                                                                                                                          |
| Out-of-band (OOB) communication  | Using a channel other than the main communication channel.                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | A message is delivered through push notification, instead of a currently used HTTP communication channel.                                                                                                                                                                                                                                                                                                     |
| Out-of-band (OOB) authentication | Authentication done in an application separated from the application that requires the authentication, with no direct communication between the two.                                                                                                                                                                                                                                                                                                                                                                                    | A web application for banking is accessed from a browser on a laptop. The web application handles the banking-related business logic, but requires authentication by a distinguished Access App, which is installed on a mobile device.                                                                                                                                                                       |
| In-band authentication           | Authentication done within the same application that requires it.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | A mobile banking application, which does not require the installation of another application to handle the authentication. All required functionality is built into one application.                                                                                                                                                                                                                          |
| Transaction confirmation         | An operation in the FIDO protocol that allows a relying party to request that a FIDO Client displays some information to the user, and requires the user to authenticate locally to their FIDO Authenticator to confirm the information. This provides proof-of-possession of previously registered key material and an attestation of the confirmation back to the relying party.                                                                                                                                                      | A mobile banking application has among its capabilities bank transfers. If the amount of the transfer exceeds a threshold, the user must confirm the transaction after authenticating. In the confirmation message presented to the user, the amount of the transaction is included. When the user confirms the transaction, the contents of the message (and thus the amount) are proven by the FIDO server. |
| Access App                       | Dedicated native mobile app built to implement the FIDO UAF authentication, registration and deregistration capabilities. Optionally also implements transaction confirmation capabilities.                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Business App                     | A business application, that users interact with, to conduct business with Nevis customers.                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Relying Party                    | "A web site or other entity that uses a FIDO protocol to directly authenticate users (that is, performs peer-entity authentication)." → see [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO                             | Fast Identity Online                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Client                  | "A FIDO UAF Client implements the client side of the FIDO UAF protocols." → see [FIDO UAF Architectural Overview](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-overview-v1.1-id-20170202.html#fido-uaf-client) and [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Server                  | "A FIDO UAF server implements the server side of the FIDO UAF protocols." → see [FIDO UAF Architectural Overview](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-overview-v1.1-id-20170202.html#fido-uaf-client) and [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Protocol                | "The FIDO UAF protocols carry FIDO UAF messages between user devices and Relying Parties." → see [FIDO UAF Architectural Overview](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-overview-v1.1-id-20170202.html#fido-uaf-client) and [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO Authenticator               | "A FIDO Authenticator is responsible for user verification, and maintaining the cryptographic material required for the relying party authentication." → see  [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                               |
| FIDO UAF Authenticator           | "A FIDO UAF Authenticator is a secure entity, connected to or housed within FIDO user devices, that can create key material associated to a Relying Party. The key can then be used to participate in FIDO UAF strong authentication protocols." → see [FIDO UAF Architectural Overview](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-uaf-overview-v1.1-id-20170202.html#fido-uaf-client) and [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html). |                                                                                                                                                                                                                                                                                                                                                                                                               |
| UAF                              | "The FIDO Protocol and family of authenticators which enable a service to offer its users flexible and interoperable authentication. This protocol allows triggering the authentication before the server knows the user" → see [FIDO Technical Glossary](https://fidoalliance.org/specs/fido-uaf-v1.1-id-20170202/fido-glossary-v1.1-id-20170202.html).                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Client TLS                       | A two way TLS connection where the client also needs a valid certificate. Also known as two way SSL.                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                               |
| Dispatch Target                  | Client identifier used in out-of-band message. transmission.                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | A unique id identifying a physical mobile device of a user                                                                                                                                                                                                                                                                                                                                                    |
| Dispatch Channel                 | A means, by which the message is transmitted to the client.                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Push (message), Link, E-Mail, ...                                                                                                                                                                                                                                                                                                                                                                             |
| Dispatcher                       | The actual implemented component tasked with sending an out-of-band message.                                                                                                                                                                                                                                                                                                                                                                                                                                                            | The Firebase Cloud Messaging Dispatcher (bound to the 3rd party Firebase Cloud Messaging Service).                                                                                                                                                                                                                                                                                                            |
| Channel Linking                  | Channel linking describes the concept, where a user is requested to visually confirm an out-of-band authentication. The user does so by comparing information shown in a web browser and in the authentication client application. The purpose of channel linking is to verify the current channel or operation, to prevent login attempts by a malicious second party, for example, another user.                                                                                                                                      | During authentication, the browser shows the characters "6A". The same characters are shown in the mobile application, allowing the user to "link" these two channels.                                                                                                                                                                                                                                        |
--------------------------------------------------------------------------------
Section: ### Using push notifications
Using push notifications for mobile authentication is possible on a single device or on multiple devices. However, for same-device authentication, the mobile-only solution provides a better user experience. Additionally, it is able to serve as a fallback in case the push notification was not received by the mobile device.

<img className="boxed" src={require('../../assets/use-cases/authentication/uc-oob-authentication-push.drawio.png').default} alt="Context overview of out-of-band authentication with push notification"/>

:::info Prerequisites

The user must register for [push notifications](../concept-description/push-notifications-in-out-of-band-scenarios.md) before being able to carry out an out-of-band authentication using push.

:::

Out-of-band authentication is initiated by the backend. A possible scenario is where a user wants to access a protected endpoint from outside of the app, for example to log into a web application using a desktop browser. The user must be authenticated first, before the protected endpoint can be accessed. For this to happen, the mobile application integrates the SDK, which provides out-of-band authentication by push notification.

1. The user starts a login.
2. The Nevis Mobile Authentication Backend initiates an authentication, and sends a push message payload to a push provider.
3. An encrypted push notification is sent to the mobile device, which must be handled by the mobile application.
4. The mobile application triggers the out-of-band authentication process with the SDK, by providing the encrypted push notification.
5. Once the mobile application completes the out-of-band authentication process, the user is granted access to the protected endpoint, such as a web application in a desktop browser.
--------------------------------------------------------------------------------
Section: ### Using links (mobile-only solution)
By using links for authentication, the user is able to simply click a link in a browser-based application to initiate the authentication process. This scenario is of course only valid, if the user wants to perform an authentication on the same device, where the app integrating the SDK is present.

<img className="boxed" src={require('../../assets/use-cases/authentication/uc-oob-authentication-link.drawio.png').default} alt="Context overview of out-of-band authentication with mobile-only solution"/>

1. Out-of-band authentication is initiated by the backend. A possible scenario is where a user wants to access a protected endpoint from outside the app, for example, to log in to a web application using a browser on the same device. The user must be authenticated first before the protected endpoint can be accessed. For this to happen, the mobile application integrates the SDK, which provides out-of-band authentication through links.
2. When the user clicks the link provided in the web application, encrypted payload information contained in the link is forwarded to the mobile application.
3. The mobile application triggers the out-of-band authentication process with the SDK, by providing the encrypted payload.
4. Once the mobile application completes the out-of-band authentication process, the user is granted access to the protected endpoint, for example, a web application in a desktop browser. For further information, see the [Access App Guide](/nevisaccessapp/features/channels).
--------------------------------------------------------------------------------
Section: ### ninwin.md
---
sidebar_position: 1
toc_max_heading_level: 6
title: Ninwin
slug: /
---

# ![Ninwin](../../static/img/64/Ninwin.png) Ninwin

Ninwin implements authorization based on Nevis SecTokens as a .NET HttpModule. It provides a convenient interface to ASP.NET-based IIS web applications to authorize access and consume claims contained in Nevis SecTokens. The Ninwin technical documentation provides all the information required for the installation, configuration, administration and operation of Ninwin.

:::info
The official component name is "NINWIN – Nevis Integration with Windows" (short "Ninwin"). Sometimes, the component is also referred to by its technical name "NinNetHttpModule", short "NinNet". NINWIN and NinNetHttpModule are identical.
:::

## Concept Description and Technical Architecture

Ninwin implements authorization based on Nevis SecTokens as a .NET HttpModule. It provides a convenient interface to ASP.NET-based IIS web applications to authorize access and consume claims contained in Nevis SecTokens. Ninwin is sometimes referred to by its technical module name "NinNet".

This chapter provides a technical view on the NinNet HttpModule. The usage context, implemented features and restrictions as well as the chosen implementation will be explained.
--------------------------------------------------------------------------------
Section: ### Features
The NinNet HttpModule provides the following features:

* **Secure token verification:** Only requests containing a correct token are accepted and passed to the web application. A token is considered correct if it has been issued by a trusted authenticator and if the contained data has not been tampered with, i.e. the token is authentic. Often, the token is verified on the first request only. For subsequent requests, the application server identifies the original caller with the aid of a tracking mechanism (like a HTTP cookie).
* **Secure token lifetime check:** The lifetime of the token must regularly be checked by comparing the actual clock time with the signature time and the token lifetime. The clocks of the token-issuer machine and the verifying machine may vary: The maximum tolerated clock variance should be configurable.
* **.NET authentication:** The authentication providers plug into the application servers authentication framework to support declarative and programmatic security according to .NET specification. The authentication typically results in an object implementing IPrincipal that represents the users identity and roles. All further security checks are based on this object. The container propagates this object by adding it to the HttpContext.
* **Identity propagation to the application:** The identity and roles contained in the secure token must be made available to the application. This may be achieved by the means of the .NET authentication and authorization framework.
--------------------------------------------------------------------------------
Section: ### Integration of the NinNet HttpModule in a .NET Application
The installed DLL has to be included in the .NET web application. Basically the HttpModule has to be configured in the web.config file of the .NET web application. To which section of the configuration this goes depends on the application and the kind of application pool that is used. For the default (integrated pipeline) application pool, the module has to be registered in the system.webServer section as shown below:

```
<configuration>
  <system.webServer>
    <modules>
      <add type="Nevis.NinNet.Auth.SecTokenAuthenticationModule, Nevis.NinNet"
           name="Nevis.NinNet"/>
    </modules>
  </system.webServer>
</configuration>
```

For classic application pools, the module has to be registered in the system.web section as shown below:

```
<configuration>
  <system.web>
    <httpModules>
      <add type="Nevis.NinNet.Auth.SecTokenAuthenticationModule, Nevis.NinNet"
           name="Nevis.NinNet"/>
    </httpModules>
</system.web>
</configuration>
```

Also the default authentication module of ASP.NET has to be disabled (only one authentication module is loaded):

```
<authentication mode="None"/>
```

For a secure environment, only authenticated users should be allowed (e.g. no anonymous access):

```
<authorization>
 <deny users="?"/>
</authorization>
```

A detailed example config can be found as an appendix to this document.
--------------------------------------------------------------------------------
Section: ### Development Mode
NinNet also supports the development mode feature. When enabled it will allow developers to use basic authentication to access the web application. The developer has to provide a username and the developer password. If no token is configured for this user NinNet will create a default properties file for that user in the specified location. This file can be modified to incorporate additional claims into the security token.

Example:

```
<add key="devMode" value="true" /><add key="devPassword" value="test" /><add key="devTokenSignerCert" value="csp://CurrentUser/My?friendlyName=signer" />
```

In the example above, development mode was enabled. We use the password "test" to login. As soon a protected resource is accessed basic authentication is triggered. We can then log in using an arbitrary username and the password "test". NinNet will create a properties file in the temporary directory (%TEMP%).

```
devmode_user.properties
```

The file can be modified. NinNet then creates a sectoken with the claims specified in the properties file.

## Configuration of the NinNet HttpModule

The NinNet HttpModule is configured using the Web.config file of the .NET application. The configuration uses its own section, therefore, it is necessary that the following is defined in the `<sectionGroups>` tag:

```
<sectionGroup name="system.web">
   <section name="nevis.ninnet"
      type="System.Configuration.NameValueSectionHandler,System,
      Version=1.0.5000.0,Culture=neutral,PublicKeyToken=b77a5c561934e089"/>
</sectionGroup>

```

This defines a handler for the NinNet HttpModule section. As seen from the configuration tag above, the NinNet HttpModule configuration tag is called `<nevis.ninnet>` and is a sub-section of the `<system.web>` tag.

The following section shows the configurable parameters for the NinNet HttpModule (the parameters are kept similar to the ones of the J2EE Ninja login module).
--------------------------------------------------------------------------------
Section: #### `verifierCert`
* Type: string array
* A comma (or semi-colon) delimited list of verifier certificates used for SecToken verification. The list of certificates are URIs pointing to certificate stores from where certificates should be read. Currently there are three "types" of stores supported:
   * `file://<path-to-ceritificate>`
   * `base64://<base64-encoded-certificate>`
   * `csp://<storeLocation>/<storeName>[?query]`

 For the `file://` store, the path can be either absolute or relative to the web application. This attribute defines the certificates used to verify the SecToken. The certificates can either be in DER or PEM format.

 For the `csp://` store, the Microsoft Windows Certificate Store is used and can be managed through the management console. The URI is defined by a store location and a name. The values for location, the name and the optional query parameters are described below.
--------------------------------------------------------------------------------
Section: #### `enforcedTokenPaths`
* Type: string array
* A semi-colon (or comma) delimited list of protected locations. SecToken verification will only occur if the incoming URL starts with one of the defined protected locations. Conversely, if an incoming request matches one of the paths configured here, then a SecToken must be present as part of the request, otherwise the authentication module will block the request. If no protected locations are configured, then SecToken verification will always occur. This keeps the behavior backward-compatible.

 The configured paths are relative to the web application location (e.g. /bar if the web application is deployed under /foo and we want to protect /foo/bar) and are matched case insensitively.

 :::note
 This value was previously configured with the key „protectedPaths”, which is still supported but considered deprecated. Newer applications should configure „enforcedTokenPaths”.
 :::
--------------------------------------------------------------------------------
Section: #### `relaxedTokenPaths`
* Type: string array
* A semi-colon (or comma) delimited list of optionally protected paths where SecToken verification will occur if the incoming URL matches one of the defined paths and a SecToken is available.

 The „relaxed” in the name refers to the relaxation of SecToken verification and validation on the configured path. If a request arrives on a relaxed protected path and no SecToken is available (not sent by client), then SecToken verification is skipped and the call is passed through unauthenticatedly.

 The configured paths are relative to the web application location (e.g. /bar if the web application is deployed under /foo and we want to protect /foo/bar) and are matched case insensitively.

 :::note
 If a path is configured in both „enforcedTokenPaths” and „relaxedTokenPaths”, then the semantics of „enforcedTokenPaths” take precedence. In other words, a SecToken must be present in this case, otherwise the request will be blocked by the authentication module.
 :::
--------------------------------------------------------------------------------
Section: #### `devDir`
* Type: string
* Optional path to the directory that the NinNet developer mode uses to store temporary files. It defaults to the Windows default temporary files directory which depends on the user running the web application.
--------------------------------------------------------------------------------
Section: ### Tracing
Tracing in the NinNet HttpModule is carried out using the log4net framework. Tracing is configured in the web.config configuration file.

In the sample directory, which is installed as part of the NinNet package, there is a sample log4netsection in the web.config file which can be used by an application. The default template uses a RollingAppender, rolling the log files based on their size.

:::caution
It is important that the user under which the IIS server process is running has write privileges on the specified logfile location.
:::

## Appendix - NinNet Example Configuration Files

```script title="web.config"
<?xml version="1.0"?>

<configuration>
  <configSections>
    <sectionGroup name="system.web">
      <section name="nevis.ninnet"

type="System.Configuration.NameValueSectionHandler,System,Version=1.0.5000.0,Culture=neutral,PublicKeyToken=b77a5c561934e089" />
    </sectionGroup>
    <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" />
  </configSections>

  <system.web>
    <compilation targetFramework="4.0" />
    <globalization requestEncoding="UTF-8" responseEncoding="UTF-8" />

    <nevis.ninnet>
      <!-- =========================== MANDATORY OPTIONS =========================== -->
      <!--
        A comma (or semi-colon) delimited list of verifier certificates.
        The list of certificates are URIs pointing to certificate stores from where
        certificates should be read. Currently there are two types of stores supported:

          o file://<path-to-ceritificate>
          o base64://<base64-encoded-certificate>
          o csp://<storeLocation>/<storeName><?query>

        For the file:// store, the path can be either absolute or relative to the
        Web application base directory. Supported formats are PEM and DER.

        The Windows Certificate Store can be accessed through csp:// URIs.
      -->
      <add key="verifierCert" value="csp://LocalMachine/My;csp://LocalMachine/Root"/>

      <!-- Redirect page to use when no SecToken is found in the configured header -->
      <add key="noSecTokenRedirectURL" value="/missing.html" />

      <!-- Redirect page to use when an error occurs verifying or validating the
      SecToken
      -->
      <add key="tokenValidationErrorRedirectURL" value="/invalid.html" />

      <!-- ============================ OPTIONAL OPTIONS =========================== -->

      <!-- Name of the HTTP header containing the SecToken. Defaults to "isiwebsectoken"
      -->
      <!-- <add key="secTokenHeaderName" value="isiwebsectoken"/> -->
      <!--
        Use the HTTP basic authentication password from the Authorization header as the
        SecToken. Defaults to "false" -->
      <!-- <add key="basicAuth" value="true"/> -->

      <!--
        A semi-colon (or comma) delimited list of roles which every authenticated user
        gets automatically
      -->
      <add key="staticRoles" value="engineer;tester" />

      <!--
        Class which is used to retrieve the Role values based on a SecToken. By default,
        the TokeRoleGetter class is used if nothing is defined. This class retrieves the
        roles directly from the SecToken. Users, however, can override this
        functionality by directly specifying their own implementation here. All
        subclasses must implement the Nevis.NinNet.Role.IRoleGetter interface.

        To specify the type, the name plus the additional Assembly must be specified.
      -->
      <!-- <add key="roleGetter" value="MyNameSpace.MyRoleGetter, MyAssembly"/> -->

      <!--
        Defines the TokenTolerance (in seconds) used when validating a SecToken.
        Defaults to 600s (10min)
      -->
      <!-- <add key="tokenTolerance" value="600"/> -->

      <!--
        A semi-colon (or comma) delimited list of protected paths where SecToken
        verification is enforced if the incoming URL matches one of the defined
        protected paths. If no paths are configured, then SecToken verification
        will always occur (default: '/'). This keeps the behavior backward-compatible.

        The list of paths is taken relative to the Web application path. That is,
        if your Web application is located at /portalapp, then all configured path
        values are taken relative to this path.

        NOTE: This value was previously configured with the key 'protectedPaths' which
        is still supported but considered deprecated. Newer applications should
        configure 'enforcedTokenPaths'.
      -->
      <add key="enforcedTokenPaths" value="/secured" />

      <!--
        A semi-colon (or comma) delimited list of optionally protected paths where
        SecToken verification will occur if the incoming URL matches one of the defined
        paths and a SecToken is available. The "relaxed" in the name refers to the
        relaxation of SecToken verification and validation on the configured path. If no
        paths are configured or no SecToken is available (not set by client), then
        SecToken verification is skipped and the call is passed through unauthenticated.

        The list of paths is taken relative to the Web application path. That is, if
        your Web application is located at /portalapp, then all configured path values
        are taken relative to this path.
      -->
      <add key="relaxedTokenPaths" value="/"/>
    </nevis.ninnet>

    <!--
      Configures the Nevis SecTokenAuthenticationModule for Token-based authentication
      Uncomment for classic application pool.

    <httpModules>
      <add type="Nevis.NinNet.Auth.SecTokenAuthenticationModule, Nevis.NinNet" name="Nevis.NinNet" />
    </httpModules>
    -->

    <!-- Disable default authentication: Authentication done by Nevis.NinNet -->
    <authentication mode="None" />

    <!-- Only allow authenticated users -->
    <authorization>
      <deny users="?" />
    </authorization>

    <!-- APPLICATION-LEVEL TRACE LOGGING
      Application-level tracing enables trace log output for every page within an
      application. Set trace enabled="true" to enable application trace logging.
      If pageOutput="true", the trace information will be displayed at the bottom
      of each page. Otherwise, you can view the application trace log by browsing
      the "trace.axd" page from your web application root.
    -->
    <trace enabled="false" requestLimit="10" pageOutput="false" traceMode="SortByTime" localOnly="true" />
  </system.web>
  <system.webServer>
  <modules>
    <!--
    Configures the Nevis SecTokenAuthenticationModule for Token-based authentication
    -->
    <add type="Nevis.NinNet.Auth.SecTokenAuthenticationModule, Nevis.NinNet" name="Nevis.NinNet" />
  </modules>
</system.webServer>
<log4net>

  <!-- ================================= -->
  <!-- Preserve messages in a local file -->
  <!-- ================================= -->

  <!-- Nevis.NinNet logging -->
  <appender name="FILE" type="log4net.Appender.RollingFileAppender">
  
    <param name="File" value="C:\inetpub\logs\ninnet.log"/>
    <param name="Append" value="false"/>
    <param name="MaximumFileSize" value="500KB"/>
    <param name="MaxSizeRollBackups" value="1"/>
    <param name="RollingStyle" value="Size"/>

    <layout type="log4net.Layout.PatternLayout">
      <param name="ConversionPattern" value="%d{ISO8601} %-15.15t %-28.28c %-5.5p %x%m%n"/>
    </layout>
  </appender>

  <appender name="ASP_TRACE" type="log4net.Appender.AspNetTraceAppender" >
    <layout type="log4net.Layout.PatternLayout">
      <param name="ConversionPattern" value="%d{ISO8601} %-15.15t %-28.28c %-5.5p %x%m%n"/>
    </layout>
  </appender>

  <!-- ============================ -->
  <!-- Limit application categories -->
  <!-- ============================ -->

  <logger name="Nevis">
    <level value="DEBUG"/>
  </logger>

  <!-- ======================= -->
  <!-- Setup the Root category -->
  <!-- ======================= -->

  <root>
    <level value="INFO"/>
    <appender-ref ref="FILE"/>
  
    <!-- appender-ref ref="ASP_TRACE"/ -->
  </root>
 </log4net>
</configuration>
```
--------------------------------------------------------------------------------
Section: ### 2024-Q4_RR_Upgrade_November_2024.md
---
sidebar_position: 840
---

# 2024-Q4: RR Upgrade (November 2024)

## Major version

Version: `8.2411`

## Lifecycle dates

| Minor Version | General Availability | End of Full Support | End of Fade-Out Support |
|:-------------:|:--------------------:|:-------------------:|:-----------------------:|
| **8.2411.0.0** |     November 20, 2024     |   May 20, 2025     |      Jun 19, 2025       |
| 8.2405.2.1178 |     September 27, 2024     |   Nov 19, 2024      |      Jun 19, 2025       |
| 8.2405.1.1173 |     August 30, 2024     |   Nov 19, 2024      |      Jun 19, 2025       |
| 8.2405.1.1165 |     July 25, 2024     |   Nov 19, 2024      |      Jun 19, 2025       |
| 8.2405.1.1148 |     July 11, 2024     |   Nov 19, 2024      |      Jun 19, 2025       |
| 8.2405.0.1143 |     June 26, 2024     |   Nov 19, 2024      |      Jun 19, 2025       |
| 8.2405.0.1130 |     May 15, 2024     |   Nov 19, 2024      |      Jun 19, 2025       |

## Breaking changes and required actions

The following components have breaking changes compared to the previous release, or require specific actions. For more information, see the Release Notes of each listed component.

* nevisProxy: The Apache config generation is changed when multiple hosts are defined in navajo.xml. Now the default hosts' virtual hosts are moved to the beginning. In the old config generation, the virtual hosts order was defined by the connectors' order.
* nevisProxy: The XmlFilter now checks the content against the configured XSD schema (if any). If the content doesn't match the schema, or a schema is missing, the request will be blocked. In order to switch back to the old behaviour you need to set the parameter `ValidateSchema` to `false`.
* nevisProxy: Due to the apache httpd upgrade you have to add the following `SSLCryptoDevice` in the `Service` section of navajo.xml if a Securosys HSM (or any pkcs#11 based HSM) is configured:
```
SSLCryptoDevice="pkcs11"
```
 * nevisProxy: The DeflateFilter's CompressionWindowSize parameter no longer accepts positive values.
 * nevisProxy: For nevisproxy to run correctly, you need at least SP6 if running on SLES15. You can check the installed SP version on your SLES15 host by executing `cat /etc/os-release`. The version has to be 15.6 or more:

```
# cat /etc/os-release 
NAME="openSUSE Leap"
VERSION="15.6"
```
 * nevisProxy: If neither OpenTelemetry nor sampling is enabled op tracing in some nevis components may not work any more. To solve that you can set the java property `otel.traces.sampler` in the concerned nevis component to `always_on`.
 * nevisAuth: jcan-saml and jcan-saml-xmlbeans libs are removed from the nevisAuth RPM. These are transitive dependencies of jcan-sectoken to support the SAML Assertion as a token. These libraries are only used in Ninja for verification purposes, therefore they are not required in nevisAuth.
 * nevisAuth: Several properties in configuration have breaking changes.
 * nevisAuth: The LegacySecurityTokenService is removed.
 * nevisFIDO: New column dispatch_target_ext_id in database table token_sessions.
 * nevisIDM: Now default policy values are applied to `PASSWORD`, `CONTEXT_PASSWORD` and `DEVICE_PASSWORD` credentials when validating passwords. This behaviour can be turned off with configuration property `application.policy.loadDefaultValues`.
 * nevis...: ...

Every RR (minor and major) may contain breaking changes. See the release notes of the component you are upgrading. You should always stay up to date on the RR branch. If there are multiple releases between your current version and the version you are upgrading to, consult the release notes of each version.

## Components Changelog
--------------------------------------------------------------------------------
Section: #### Application Protection
- ⚠️ PAT-750 / PAT-754: Refactored the `nevisProxy Observability Settings` pattern:
  - Renamed the `Trace Resource Service Name` parameter and moved it to the `Basic Settings` tab. 
    - This setting now controls the `service.name` key-value pair resource attribute for both `Metrics Mode` and `Trace Mode`.
  - Removed the experimental label from the pattern. 
  - New settings: `Sampler`, `Deployment Environment`, `Capture Request Headers`, `Capture Response Headers`
- ⚠️ PAT-751: Added CRS version 4.7.0 to the `OWASP ModSecurity CRS Version` setting in the `Virtual Host` pattern.
  - The oldest, unsupported CRS version 3.0.2 was removed.
- PAT-734: Added `Default File` setting to the `Hosting Service` pattern.
- PAT-678: Added a default template for `Proxy Login Renderer`.
- ⚠️ PAT-650: Added the setting `SOAP Schema Validation Mode` to the `SOAP Service` pattern.
  - The default mode is `content-type`, where the SOAP service only analyses requests with Content-Type `application/soap+xml`.
  - Select `enabled` to analyse all requests with a body.
  - Select `strict` to analyse all requests, which was the previous behaviour.
- PAT-688: We fixed an unexpected error when using a variable for the `Public Key` of the `JWT Access Restriction` pattern.
- ⚠️ PAT-755: We improved the `Maintenance Page` pattern:
  - The `Update Interval` is now configurable.
  - The pattern now includes its sanitized name in the names of the generated `MaintenanceFilter` and `DefaultServlet`.
    - This prevents naming collisions, and allow linking multiple Maintenance Page patterns to a single `Virtual Host` or `Application`.
    - Check your configuration if you use `Generic Application Settings` or `Generic Virtual Host Settings` to customize your `MaintenanceFilter` or the related `DefaultServlet`.
- PAT-759: The `SOAP Service` pattern can now be attached to several `Virtual Host` patterns even when `SOAP Schema Validation` files are configured.
- NEVISPROXY-7253: The `HTTP Error Handling` pattern now also replaces placeholders in JSON error pages. 
  - This also applies to the default `ErrorFilter` that is generated by the `Virtual Host`.
--------------------------------------------------------------------------------
Section: #### Backward compatibility issues
* The Apache config generation is changed when multiple hosts are defined in navajo.xml. Now the default hosts' virtual hosts are moved to the beginning. In the old config generation, the virtual hosts order was defined by the connectors' order.
 * The XmlFilter checks now the content against the configured XSD schema (if any). If the content doesn't match the schema, or a schema is missing, the request will be blocked. In order to switch back to the old behaviour you need to set the parameter `ValidateSchema` to `false`.
 * Due to the apache httpd upgrade you have to add the following `SSLCryptoDevice` in the `Service` section of navajo.xml if a Securosys HSM (or any pkcs#11 based HSM) is configured:
```
SSLCryptoDevice="pkcs11"
```
 * The DeflateFilter's CompressionWindowSize parameter no longer accepts positive values.
 * For nevisproxy to run correctly, you need at least SP6 if running on SLES15. You can check the installed SP version on your SLES15 host by executing `cat /etc/os-release`. The version has to be 15.6 or more:

```
# cat /etc/os-release 
NAME="openSUSE Leap"
VERSION="15.6"
```
 * If neither OpenTelemetry nor sampling is enabled op tracing in some nevis components may not work any more. To solve that you can set the java property `otel.traces.sampler` in the concerned nevis component to `always_on`.
--------------------------------------------------------------------------------
Section: ##### General
- ⚠️ The image version encoded in the patterns has been raised to `8.2405.0` for all components. If you are deploying to Kubernetes you have to push all required images to your container registry before deployment.
- PAT-639: Added `Deployment Environment` drop-down to `Java Observability Settings` pattern.
- PAT-657: Ensure errors caused by uploaded XML files are shown in the pattern where the file is uploaded.
- PAT-675: Fixed duplicate Java agent configuration in `env.conf` when using `Java Observability Settings` pattern.
- PAT-667: Support generation of `otel` configuration based on inventory variables.
- ⚠️ PAT-660: Support 2-way TLS with PostgreSQL for Java components.
  - The value `enabled` does not exist anymore, and you have to select a different value. We recommend to use `verify-ca` or `verify-full` in combination with a `Trust Store` instead.
- ⚠️ PAT-631: Kubernetes deployments will now use startup probes to allow for longer startup times. 
  - Additionally, the used liveness and readiness probe timings were tightened and the liveness and readiness delay configuration options were removed. 
  - Make sure to upgrade to the latest version of the nevisOperator and its corresponding CRDs before deploying with the new plugin version.
--------------------------------------------------------------------------------
Section: ##### Application Protection
- PAT-547: The generated dynamic `SecurityRoleFilter` won’t store the intercepted requests by default anymore.
- PAT-651: The `StateKey` parameter is no longer generated for `SecurityRoleFilter`.
- PAT-651: Added option to configure custom parameters for the `SecurityRoleFilter` in realms.
- ⚠️ PAT-659: Support 2-way TLS with PostgreSQL for nevisProxy.
  - The value `enabled` does not exist anymore, and you have to select a different value. We recommend to use `verify-ca` or `verify-full` in combination with a `Trust Store` instead.
- PAT-658: Updated `navajo.xml` generation to match the latest navajo DTD version.
- PAT-674: Fix error during background generation when using a nevisAdmin `${var` expression and using only a variable as `param-value` in a `servlet` or `filter` in `Generic Virtual Host Settings` or `Generic Application Settings`.
--------------------------------------------------------------------------------
Section: ##### Application Protection
- PAT-674: Fix error during background generation when using a nevisAdmin `${var` expression and using only a variable as `param-value` in a `servlet` or `filter` in `Generic Virtual Host Settings` or `Generic Application Settings`.
--------------------------------------------------------------------------------
Section: ### Components-Removed-from-the-Rolling-Releases-as-of-November-2021.md
---
sidebar_position: 4
---

# Components Removed from the Rolling Releases as of November 2021

As of November 2021, the following components and component-features are no longer available in the rolling releases (RR). However, they will be available in the LTS-21 releases.

nevisAdmin 3 & nevisAgent

Starting 2020, *nevisAdmin 3* is in maintenance-only mode. This means the following ([as we have announced previously](:

* nevisAdmin 3 RR receives Full Support until the November 2021 release.
* After November 2021, nevisAdmin 3 will be supported only by the LTS-2021 releases.

The package *nevisAgent* (bundled with nevisAdmin 3) is also in maintenance-only mode. As of LTS-2021, it will be available in LTS only.

## Affected features

* IP Failover Cluster

* SNMP

nevisProxy

In nevisProxy RR 5.x, all features that have been marked as deprecated in the lifetime of the LTS 3.14.3.x and the RR 4.x releases will be removed. You can no longer use them. There is a comprehensive list of parameters that will not work in RR 5.x. All deprecated features have been replaced by better alternatives, are no longer technically possible or have become irrelevant.

Here are some of the most notable removals:

* Legacy Session Store (and everything related to it). This includes parameters such as:

* The QoS configuration in the *navajo.xml* file. QoS will now only be configured with an *ApacheConfigFilter*.
* *MaxClientsPerIpAddr*. This feature has been replaced with QoS directives and will be removed.
* *InputValidationFilter* profiles. These profiles can be fully replaced by the *ModSecurityFilter*.
* *SessionResourceFilter*
* *Auditfilter*. This filter has been replaced by the *LoggerFilter*.

Authentication Components

## LTS-only features

* The nevisAuth *compatLevel* flag. Note that the LTS default is “none” (instead of “full”).
* RPM and CLI changes for RR
* nevisAuth AuthStates and plug-ins:

## Monitoring solution

* Components of the ELK stack and associated patterns are not part of the Rolling Releases anymore.
--------------------------------------------------------------------------------
Section: ### nevisWorkflow.md
---
sidebar_position: 29
---

# nevisWorkflow

**As of February 2020, nevisWorkflow will no longer be part of the Nevis Rolling Releases (RR).** Support for nevisWorkflow in the Nevis Rolling Releases (RR) ended as of 19 Feb 2020.

As part of the Nevis Long-Term-Support . However, nevisWorkflow will **not** be part of future major LTS releases.

In case you are looking for alternatives to nevisWorkflow, consider the following:

* Use any enterprise or open source BPMN (<http://www.bpmn.org/>) engine, such as e.g. Activiti (`<http://www.activiti.org/>) to implement your business workflows. Activiti can be setup together with web application frameworks like Spring Boot to replace nevisWorkflow.
* To administer users and further entities in nevisIDM, use nevisIDM's REST or SOAP API. Refer to the [nevisIDM Client Developer Guide] for additional information on how nevisIDM client applications may be implemented.
This page contains additional information regarding the compatibility of this component.
See Quarterly Releases for general Nevis compatibility information.

## End of Life Dates

See Quarterly Releases.

## Component and Java Container

| nevisWorkflow | adnwildfly | adnglassfish | embedded jetty (standalone) |
| --- | --- | --- | --- |
| 1.13.x | ✅ 10.1.x | ✅ 3.1.8.1 | ✅ 9.4.14 |

* Fully support with MariaDB / Preview with Oracle

## Component and Database

| nevisWorkflow | MySQL* | MariaDB* | Oracle |
| --- | --- | --- | --- |
| 1.13.x | ⚠️ 5.6, 5.7 Deprecated | ✅ 10.3 | ✅ 12c, 18c, 19c |

* Only*InnoDB*is supported, no support for*NDB,**MySQL Cluster*or*Galera Cluster* technologies.

## Component and Nevis / Activiti Engine

| nevisWorkflow | nevisIDM* | Activiti Engine |
| --- | --- | --- |
| 1.13.x | 2.75.x | 5.22.0 |

* Requires*nevisidmcl* package to be installed on the nevisAuth server with the same version as nevisIDM.

See nevisWorkflow for compatibility between nevisIDM and the component.
--------------------------------------------------------------------------------
Section: ### Message-Bus.md
---
sidebar_position: 40
---

# Message Bus

For a proper functioning of nevisDetect, either install/configure an own message bus or use the built-in `nevisdetect-mq`component. This section shows you how to configure the message bus using the `nevisdetect-mq` component.

## `nevisdetect-mq` component

The `nevisdetect-mq` component is part of the `nevisdetect` RPM. After the handover, you will find the configuration files of the `nevisdetect-mq` component here: `/var/opt/nevisdetect/mq/`.

The `nevisdetect-mq` component provides the following command line interface for administration:

```
[root@nevisdetect-dev]# nevisdetect-mq

usage:
nevisdetect-mq start # starts the mq component
nevisdetect-mq stop # stops the mq component
nevisdetect-mq restart # restarts the mq component
nevisdetect-mq status # displays the status of the mq component
nevisdetect-mq handover # creates the default configuration of the mq component
```

## Configuring the message broker

To configure the message broker, you can edit the `activemq.xml` file located at `/var/opt/nevisdetect/mq/conf/activemq.xml`, as shown in the following code snippet:

```
<broker xmlns="http://activemq.apache.org/schema/core" brokerName="nevisDetect" persistent="false">
        <sslContext>
                 <sslContext
                         keyStore="<your key store>"
                         keyStorePassword="<your key store password>"
                         trustStore="<your trust store>"
                         trustStorePassword="<your trust store password>"/>
        </sslContext>

        <transportConnectors>
            <transportConnector name="openwire" uri="ssl://<host>:><port>?needClientAuth=true&transport.daemon=true"/>
        </transportConnectors>

       <plugins>
          <statisticsBrokerPlugin/>
         <timeStampingBrokerPlugin ttlCeiling="300000" zeroExpirationOverride="300000"/>
       </plugins>
</broker>
```

* The `statisticsBrokerPlugin` is required for monitoring the queues and topics of nevisDetect in the `Application monitoring` view of the nevisDetect web application.
* The `timeStampingBrokerPlugin` is recommended for limiting the time-to-live of a message.
--------------------------------------------------------------------------------
Section: ### Web-Application.md
---
sidebar_position: 29
---

# Web Application

The nevisDetect web application is described in the nevisDetect User Guide.

* For information about the *navigation concept*, see the chapter User Interface in the nevisDetect User Guide.
* For information about the *personas and permission concept*, see the chapter Security in this reference guide, as well as to the nevisDetect User Guide, chapter Use Cases and Personas.
* For information about the *functionality*, see the chapter User Interface in the nevisDetect User Guide.
--------------------------------------------------------------------------------
Section: ### System-Configuration.md
---
sidebar_position: 30
---

# System Configuration

We distinguish between the application configuration and the system configuration. The application configuration is related to the functionality of nevisDetect from a business point of view. The application configuration is managed with the nevisDetect Web App, see Web Application. The system configuration deals with such topics as configuring the X509 certificates or the database connectivity. This chapter deals with the system configuration.

The system configuration is based on property files. The table below lists the property files per nevisDetect component.

| Component | Property file path |
| --- | --- |
| nevisDetect Feature Correlator | `/var/opt/nevisdetect/entrypoint/conf/entrypoint.properties` |
| nevisDetect Core | `/var/opt/nevisdetect/core/conf/core.properties` |
| nevisDetect Persistency | `/var/opt/nevisdetect/persistency/conf/persistency.properties` |
| nevisDetect Controller | `/var/opt/nevisdetect/admin/conf/admin.properties` |
| nevisDetect Message Bus | `/var/opt/nevisdetect/mq/conf/mq.properties` |

The property files are created, with default settings, during the installation of the software packages. Use these default property files as a starting point for your custom configuration.

For a proper functioning of the nevisDetect components, you need to specify some attributes specific for the component. The following chapters describe these attributes per nevisDetect component.

* For an overview of the important attributes for the Persistency component, see nevisDetect Persistency
* For an overview of the important attributes for the Controller component, see nevisDetect Controller
* For an overview of the important attributes for the Feature Correlator component, see nevisDetect Feature Correlator
* For an overview of the important attributes for the Core component, see nevisDetect Core

Some configuration attributes are identical for all components. The chapter Common attributes describes these general configuration attributes in more detail.
--------------------------------------------------------------------------------
Section: ### nevisDetect-plug-ins.md
---
sidebar_position: 36
---

# nevisDetect plug-ins

The nevisDetect plug-ins are dynamically loaded by the nevisDetect Core component. Upon loading, and for each plug-in, the system automatically reads several attributes from the file `/var/opt/nevisdetect/core/conf/plugins.properties`. The table below lists these attributes. Since there are multiple plug-ins, each attribute name is made unique by a counter. The value of the counter itself has no meaning. In the table, we use `<n>` to denote that:

| Attribute | Description |
| --- | --- |
| `plugin.<n>.class` | The full qualified Java class name of the plug-in. |
| `plugin.<n>.jar` | The path of the jar file containing the plug-in class. |
| `plugin.<n>.configuration` | The path of the configuration of the plug-in class. |

See also the following example:

```
# test plugin 1
plugin.1.class=ch.nevis.nevisDetect.core.test.TestPlugin
plugin.1.jar=/var/opt/nevisdetect/core/plugins/nevisdetect-core-tests.jar
plugin.1.configuration=/var/opt/nevisdetect/core/plugins/test-plugin-1.properties

# behaviosec plugin
plugin.2.class=ch.nevisDetect.plugin.behaviosec.BehavioSecPlugin
plugin.2.jar=/var/opt/nevisdetect/core/plugins/behaviosec-plugin.jar
plugin.2.configuration=/var/opt/nevisdetect/core/plugins/behaviosec-plugin.properties
```

## BehavioSec plug-in

The table below lists the plug-in specific attributes of the BehavioSec plug-in. You specify these attributes in the file `behaviosec-plugin.properties`.

| Name | Type/unit | Example | Default | Description |
| --- | --- | --- | --- | --- |
| colorCodes | list of string tuples | BehavioSecTransaction:#FF8000,<br/>BehavioSecSession:#FFFF00,<br/>BehavioSecRisk:#FF4D00 | BehavioSecTransaction:#FF8000,<br/>BehavioSecSession:#FFFF00,<br/>BehavioSecRisk:#FF4D00 | Defines the HTML color codes of the BehavioSec risk scores. The risk scores will be shown in these colors in the nevisDetect web application. |
| riskScores | list of strings | BehavioSecTransaction, BehavioSecSession, BehavioSecRisk | BehavioSecTransaction, BehavioSecSession, BehavioSecRisk | Defines the plug-in risk scores that will be extracted/converted from the response of the BehavioSense service. |
| proxy | DNS name/port | adnprox01.zh.adnovum.ch:3128 | | Specifies the outbound proxy. This attribute is optional. |
| dashboard | URL | | | Specifies the URL of the BehavioSense dashboard. |
| url | URL | | | Specifies the URL of the BehavioSense service. |
| http.client.connectTimeout | int/msec | | 500 | The timeout for establishing a TCP connection. |
| http.client.keyStore | file | file:/var/opt/neviskeybox/<br/>default/nevisdetect/<br/>behaviosec_keystore.jks | | The Java keystore file used for establishing the TLS connection. |
| http.client.keyStorePassword | string | | | The passphrase for the keystore. |
| http.client.trustStore | file | file:/var/opt/neviskeybox/<br/>default/nevisdetect/<br/>behaviosec_truststore.jks | | The Java truststore file used for establishing the TLS connection. |
| http.client.trustStorePassword | string | | | The passphrase for the truststore. |
| finalizeSession | boolean | | true | Defines whether to call `finalizeSession` if the session is terminated. The default is "true". |
| training.operatorFlags | integer | | 0 | Sets the operator flags for the call to the BehavioSense service in the training mode. For details, see <http://developer.behaviosec.com/docapi/5.2/#operator-flags>. |
| detection.operatorFlags | integer | | 0 | Sets the operator flags for the call to the BehavioSense service in the detection mode. For more details, see <http://developer.behaviosec.com/docapi/5.2/#operator-flags>. |
| reportFlags | integer | | 0 | Sets the report flag for the call to the BehavioSense service. For more details, see <http://developer.behaviosec.com/docapi/5.2/#report-flags>. |
| riskScoreIgnoreFlags | boolean | | true | Defines if the following BehavioSec flags in the response are influencing the risk score:  `coached`, `diError`, `drFlag`, `otjsError`, `pnFlag`, `ohFlag`, `pdError`, `isBot`, `tabAnomaly`, `pocAnomaly`, `numpadAnomaly`, `ipChanged`, `deviceChanged`, `isDataCorrupted`, `isSessionCorrupted`, `isReplay`. If the attribute is set to "true", the above flags are ignored (that is, the flags will not influence the risk score). |
| uniqueLoginId | boolean | | false | Defines whether to send the `loginId` (instead of the `uniqueId`) to the BehavioSec plug-in. Set to "true" only if the `loginId` is unique. |
| tenantId | string | default_tenant | | Specifies the optional tenant ID of BehavioSense. |
| supportedMimeTypes | list of strings | | application/behaviosec | The MIME type(s) of the part of a multi-part HTTP request that contains BehavioSec data. |
| fraudulentFlags | list of strings | isBot, isDataCorrupted, isSessionCorrupted, isReplay | diError, pdError, isBot, isRemoteAccess, uiScoreFlag, uiConfidenceFlag, tabAnomaly, pocAnomaly, numpadAnomaly, ipChanged, deviceChanged, isDataCorrupted, isSessionCorrupted, isReplay, coached, drFlag, ohFlag, otjsError, pnFlag advancedUser, deviceIdShared, deviceIntegrity, ipShared, newCountry, locationMismatch, travelTooFast | Optional. Take the flag names from the BehavioSec documentation. List all items in a single line separated by comma, or further separate them (with \ + newline) to improve readability. The included report flags mark the request as fraudulent and block it. |
| flagDescMapping | list of strings | flagName1=valueName1, flagName2=valueName2, flagName3=valueName3 | advancedUser=advancedUserScore, deviceChanged=deviceDesc, deviceIntegrity=deviceIntegrityDesc, diError=diDesc, finalized=finalizeTimestamp, isBot=botDesc, isDuplicate=duplicateDesc, isRemoteAccess=raDesc, isReplay=replayDesc, isSessionCorrupted=isSessionCorruptedDesc, locationMismatch=locationMismatchDesc, newCountry=ipCountry, numpadUsed=numpadRatio, otjsError=otjsDesc, pdError=pdDesc, pocUsed=pocRatio, tabUsed=tabRatio, travelTooFast=travelTooFastDesc, uiConfidenceFlag=uiConfidence, uiScoreFlag=uiScore | Optional. Take the flag and description / score names from the BehavioSec documentation. Add key=value pairs seperated by commas to customize logging, the default values will be extended. List all items in a single line separated by comma, or further separate them (with \ + newline) to improve readability. If a given flag is found, the associated value will also be logged along with it. Warning: assigning a new value to an already existing flag (such as those in the default configuration) will overwrite it! |

## nevisAdapt plug-in

See chapter nevisAdapt plug-in for details on the configuration.

## Proxy plug-in

The table below lists the plug-in specific attributes of the Proxy plug-in. You specify these attributes in the file `proxy-plugin.properties`.

| Name | Type/unit | Example | Description |
| --- | --- | --- | --- |
| colorCodes | list of string tuples | colorCodes=CyberDetectionTCP:#DF01D7, CyberDetectionTLS:#AF01D8 | Defines the HTML color codes of plug-in's risk scores. The risk scores will be shown in these colors in the nevisDetect web application. |
| description.1description.2... | string | **description.1=** Adapter for passing request to the cyber detection service © Company<br/>**description.2=** support by cyberdetection@company.com | Use this attribute to add a description of the plug-in. The attribute is optional. |
| name | string | CyberDetection | Specifies the name of the plug-in. |
| riskScores | list of strings | riskScores=CyberDetectionTCP, CyberDetectionTLS | Specifies a list of the risk scores delivered by the plug-in. |
| serviceMapping | list of string tuples | requestData: /service/processRequestData,<br/>terminateSession: /service/processSessionTermination,<br/>getVersion: /getVersion | Defines a list of supported methods and their mapping. The following methods are allowed: `requestData`, `terminateSession`, `getVersion`. The syntax of this attribute is: `<method-name>:<path>` |
| url | URL | | Defines the URL of the service. |
| http.client.connectTimeout | int/msec | 500 | The timeout for establishing a TCP connection. |
| http.client.retryTimeout | int/msec | 5000 | The retry timeout in case of a connection error or an HTTP error code. |
| http.client.keyStore | file | file: /var/opt/neviskeybox/default/<br/>nevisdetect/thirdparty_keystore.jks | The Java keystore file used for establishing the TLS connection. |
| http.client.keyStorePassword | string | | The passphrase for the keystore. |
| http.client.trustStore | file | file: /var/opt/neviskeybox/default/<br/>nevisdetect/thirdparty_truststore.jks | The Java truststore file used for establishing the TLS connection. |
| http.client.trustStorePassword | string | | The passphrase for the truststore. |
--------------------------------------------------------------------------------
Section: ### nevisProxy.md
---
sidebar_position: 38
---

# nevisProxy

As shown in Technical architecture, it is the `ICAPFilter` that sends the HTTP request of the user to nevisDetect. For a detailed description of the `ICAPFilter`, see the nevisProxy Reference Guide. The following text discusses different configuration options of the `ICAPFilter` and its consequences for nevisDetect.

## ICAP protocol

ICAP is a lightweight HTTP-like protocol and stands for Internet Content Adaption Protocol (ICAP). The ICAP protocol is generally used to modify an HTTP request or an HTTP response (see the [RFC3507](https://tools.ietf.org/html/rfc3507) for more details). The following aspects of the ICAP protocol are relevant for the modification of an HTTP request.

* The ICAP client sends an ICAP request containing the encapsulated HTTP request.
* The ICAP server has different options:
  * The server modifies the HTTP request. In this case, the server sends back an ICAP response containing the modified HTTP request. The ICAP client uses this modified HTTP request for its further processing. This situation is called ICAP request modification.
  * The server returns an HTTP response as reaction to the HTTP request. In this case, the server sends an ICAP response containing the HTTP response.
    The ICAP client stops processing the HTTP request and sends back the HTTP response. This situation is called ICAP response modification.
  * The server does neither modify the HTTP request nor return an HTTP response. In this case, the server sends back an ICAP response with an appropriate status code.
    This situation is called ICAP no modification.

In the context of nevisDetect, the `ICAPFilter` of nevisProxy acts as the ICAP client and the `FeatureCorrelator` component of nevisDetect acts as the ICAP server.

The following sequence diagram shows the propagation of the risk scores from an ICAP point of view:

<img className="boxed" src={require('../../../attachments/6645026/6645558.png').default} alt="Risk score propagation"/>

The diagram below shows the blocking of the HTTP request from a certain user due to a matching policy, again from an ICAP point of view:

<img className="boxed" src={require('../../../attachments/6645026/6646116.png').default} alt="Blocking a HTTP request"/>

The next table lists the possible scenarios:

| nevisDetect scenario | ICAP response |
| --- | --- |
| Risk score propagation | `ICAP request modification` |
| Matching policy with the `NevisProxyActionPlugin` and the action PASSTHROUGH | `ICAP request modification` |
| Matching policy with the `NevisProxyActionPlugin` and the action AUTHENTICATE or BLOCK | `ICAP response modification` |
| An error in nevisDetect during processing; failopen is "false" | `ICAP response modification` |

## ICAPFilter

In the following table we discuss the configurations attributes of the `ICAPFilter` and its required values in the context of nevisDetect:

| Configuration attribute | Value | Description |
| --- | --- | --- |
| ScanRequest | true | Only the HTTP request must be passed to nevisDetect. |
| ScanResponse | false | |
| BodyRequired | false | Ensures that also HTTP requests without a body are passed to nevisDetect. |
| BufferRequest | true | Required for the `ICAP response modification` scenario. |
| RequestBufferSize | | Defines the buffer size aligned with the maximum allowed request size of your nevisProxy configuration. |
| AllowRequestModification | true | See discussion below |
| AllowResponseModification | true | See discussion below |
| PreviewSize | 0 | See discussion below |
| RequestTimeout | | Defines how long nevisProxy will wait for an ICAP response from the `FeatureCorrelator`. The configured value should be greater then the value set in the nevisDetect configuration attribute `jms.receiveTimeout`, see Common attributes. |
| PropagateFromEnv | | nevisDetect needs information that is not part of the pure HTTP request. A LUA script will collect this information and stores it in the environment of nevisProxy.The configuration below will add the information to the HTTP request headers, which in turn will pass it to the `FeatureCorrelator`, see example below. |
| TargetURI | /nevisDetect?<br/>AllowResponseModification=<br/>true&AllowRequest<br/>Modification=true | That values for the query attributes *AllowResponseModification* and *AllowRequestModification* must be consistent with the configuration attributes *AllowResponseModification* and *AllowRequestModification*. |
| SplittMultipartBody | false | Disables the splitting of multi-part bodies. |
| VerificationMode | optional | Depending on your security requirements, set to "optional" to ensure the transparency of nevisDefect also in case of a disaster. |
| InetAddress | | The TCP listener address of the `FeatureCorrelator` component of nevisDetect, see also: nevisDetect Feature Correlator. |

```
<init-param>
 <param-name>PropagateFromEnv</param-name>
 <param-value>
 REMOTE_ADDR:X-Client-IP
 REMOTE_PORT:X-Client-Port
 SERVER_ADDR:X-Server-IP
 SERVER_PORT:X-Server-Port
 ENTRYPOINTID:X-EntryPointId
 RDF_KILL_SESSION:X-KillSession
 RDF_REQUESTCOUNT:X-RequestCount
 RDF_SESSION_ID:X-HttpSessionId
 RDF_SESSION_LASTACCESS_TIME:X-SessionLastAccess
 RDF_SESSION_MAX_INACTIVE_INTERVAL:X-SessionMaxInactiveInterval
 SSL_SESSION_ID:X-SSLId
 bcx.servlet.connection.SSLCiphersUsed:X-SSLCiphersUsed
 bcx.servlet.request.TransferID:X-TransferId
 REMOTE_USER:X-LoginId
 LOGIN_REALM:X-LoginRealm
 </param-value>
</init-param>
```

If the values for the query attributes `AllowResponseModification` and `AllowRequestModification` of the `TargetURI` configuration attribute are not consistent with the configuration attributes `AllowResponseModification` and `AllowRequestModification` it can happen that the `ICAPFilter` unintentionally blocks the HTTP request of a user (for example in case of risk score propagation).

If one of the `PropagateFromEnv` attributes is missing, the `FeatureCorrelator` component of nevisDetect stops processing the ICAP request. Depending on the setting for `Failopen` the HTTP request will be blocked. See also the Status section of the GUI.

## Optimizing the ICAPFilter configuration

The configuration of an ICAP filter supports all possible scenarios of nevisDetect. You can either configure a single ICAP and map it to the desired URL name space. In a more advanced setup, several ICAPFilters can be configured and mapped to different URL name subspaces.

In the following we illustrate three typical situations by an example:

Lets consider the following name space of an hypothetical web application:

* /app/images/
  * static content like style sheets, images etc.
  * no need to mitigate fraudulent HTTP requests
* /app/readonly/
  * part of the web application where no transactions can be executed
  * no need to mitigate fraudulent HTTP requests
* /app/read-write/
  * part of the web application where no transactions can be executed
  * need to block fraudulent HTTP requests

We cover that situation by two `ICAPFilters`, lets call them  `LowSecurityICAPFilter` and `HighSecurityICAPFilter`:

For the `LowSecurityICAPFilter` we set the configuration attributes `AllowRequestModification` and `AllowResponseModification` to "false". Accordingly, for the configuration attribute `TargetURI` we set the value `/nevisDetect?AllowResponseModification=false&AllowRequestModification=false`. Thus, nevisDetect knows that it should act in a read-only mode and can optimize its processing. Additionally, we use the value `0` for the configuration attribute `PreviewSize` with the effect that only the HTTP headers are passed to nevisDetect. Additional we use a low value like 50 milliseconds for the configuration attribute `RequestTimeout.`

For the `HighSecurityICAPFilter` we use a different configuration. We set `AllowResponseModification` to "true" and `AllowRequestModification` again to "false" (since we want to block HTTP requests but we do not want to  propagate any risk scores). As in the previous example, the `TargetURI` must be consistent. So we use the value `/nevisDetect?AllowResponseModification=true&AllowRequestModification=false`. The value of `PreviewSize` is `0` since the complete HTTP request should be captured. For the `RequestTimeout` we may use a higher value like 150 milliseconds.

In case of several ICAP filters it must be ensured that only one `ICAPFilter` is sending an ICAP request to the `FeatureCorrelator` component of nevisDetect. Otherwise, the same HTTP request of the user will be processed several times, which causes an error within nevisDetect.
--------------------------------------------------------------------------------
Section: ### nevisAuth.md
---
sidebar_position: 39
---

# nevisAuth

The nevisDetect AuthState sends authentication data to nevisDetect during the login process, as shown in Technical architecture. The following figures illustrates this.

The next figure shows the typical workflow of a login process:

<img className="boxed" src={require('../../../attachments/6645030/8004039.png').default} alt="Typical login workflow"/>

It is possible to influence the above login workflow with nevisDetect. The integration of nevisDetect in such a login workflow takes place by invoking a nevisDetect AuthState before the `LoginDoneState` AuthState. This ensures that only data of an authenticated user is passed on to nevisDetect. The next figure shows the above workflow enhanced by the nevisDetect AuthState `ch.nevis.detect.authstate.CollectAndSendAuthState` or, shorter, `CollectAndSendAuthState`.

<img className="boxed" src={require('../../../attachments/6645030/8004054.png').default} alt="Typical login workflow enriched by nevisDetect"/>

The `CollectAndSendAuthState` AuthState returns a result condition (`ResultCondition`) based on the response from nevisDetect.
The result condition influences how the login workflow will proceed.  The next table shows the various possible result conditions:

| ResultCondition | Response received | Policy matched | Description |
| --- | --- | --- | --- |
| timeoutReadingResponse | no | NA | The AuthState has stopped waiting for a response from nevisDetect. |
| error | no/yes | | An error has happened either during the request processing within nevisDetect or within the nevisDetect AuthState. |
| noDataFound | yes | no | nevisDetect could not determine any risk score, due to an untrained user or missing data. |
| ok | yes | no | No policy has matched. |
| additionalAuthRequired | yes | yes (see Action plug-ins for details) | A policy with the action STEPUP has matched. |
| block | yes | yes (see Action plug-ins for details) | A policy with the action DENY has matched. |

If you set the configuration property `validateResponse` of the `CollectAndSendAuthState` AuthState to "false", the AuthState does not wait for any response from nevisDetect but immediately returns the result condition "ok".

This behavior is similar to the `asynchronous` communication mode for HTTP requests. Section Communication mode explains this communication mode and its counterpart, the `synchronous` communication mode.

The following table lists all configuration properties of the `CollectAndSendAuthState` AuthState:

| Name | Type/unit | Default | Example | Description |
| --- | --- | --- | --- | --- |
| validateResponse | boolean | false | true | If set to "false", the AuthState does not wait for any response from nevisDetect but immediately returns the result condition "ok". "false" is the default setting. |
| brokerUri | string | | failover: ssl://nevisrdf1.zh.<br/>adnovum.ch:8282 | The JMS broker URL.Configuring the prefix `failover` is recommended to enable re-connecting to the broker. |
| keyStoreRef | file | | /var/opt/nevisauth/<br/>default/nevisdetect/certs/<br/>nevisdetect_keystore.jks | The Java keystore file used for establishing the TLS connection to the JMS broker. |
| keyStorePassword | string | | | The passphrase for the keystore. |
| trustStoreRef | file | | /var/opt/nevisauth/<br/>default/nevisdetect/certs/<br/>nevisdetect_truststore.jks | The Java truststore file used for establishing the TLS connection to the JMS broker. |
| trustStorePassword | string | | | The passphrase for the truststore. |
--------------------------------------------------------------------------------
Section: ### Training-data.md
---
sidebar_position: 9
---

# Training data

## Storage conditions

In nevisDetect, several detection technologies can be deployed. In general, not all detection technologies can provide a plug-in risk score for every HTTP request. Consider the following example:

BehavioSec and nevisAdapt are deployed for a JSP web application. To be able to compute its plug-in risk scores, BehavioSec needs the keystroke and mouse movement information passed as a HTML form parameter, see chapter [Plug-in BehavioSec](https://docs.nevis.net/nevisdetect/nevisDetect-Reference-Guide/Risk-Plug-Ins/Plug-in-BehavioSec) for details. This means that BehavioSec delivers plug-in risk scores only for HTTP POST requests. nevisAdapt just requires the HTTP headers of the request for the computation of the plug-in risk scores.  So for some HTTP requests, both BehavioSec and nevisAdapt provide plug-in risk scores, whereas for other HTTP requests, the plug-in risk scores come only from nevisAdapt.
Now suppose that you want to train a normalization model based on BehavioSec and nevisAdapt plug-in risk scores. The training data for this normalization model consist of HTTP requests with plug-in risk scores from both BehavioSec and nevisAdapt.  There is no need to store plug-in risk scores of HTTP requests that you cannot use for the training of our normalization model. This can be configured with the so-called *storage condition*.

For every plug-in risk score a storage condition can be defined. A storage condition consists of a numeric *confidence threshold* and a *qualifier* regarding the presence of the plug-in risk score. The following values for the qualifier are defined:

* IGNORE means that the plug-in risk score will never be stored.
* REQUIRED means that the presence of the plug-in risk score is required. If the plug-in risk score is not present, no plug-in risk scores at all will be stored.
* OPTIONAL means that the plug-in risk score is optional. It will be stored if present. Storing any other plug-in risk score is not influenced.

In case of the above example, the value of the qualifier should be REQUIRED; this setting will only store plug-in risk scores of HTTP requests with both BehavioSec and nevisAdapt plug-in risk scores. Another possibility is to use rule-based normalization. For more information, see [Rule-based models](https://docs.nevis.net/nevisdetect/nevisDetect-Reference-Guide/Conceptional-Overview/Normalization/Normalization-models/Rule-based-models).

If it is not clear which plug-in risk scores to use for the normalization models for all plug-in risk scores, configure the qualifier OPTIONAL. But note that the configuration of the storage conditions influences the required storage space.

We will come back to the *confidence threshold* after the explanation of a *training data set*.

## Training data set

You configure a training data set by selecting some plug-in risk scores and by setting a time frame. The number of the selected plug-in risk scores defines the dimension of the training data set, whereas the time frame defines the size.  Due to computational reasons the number of training data must be limited.

The user can configure several training data sets without influencing the storage space. The sets are referenced by the normalization model by their unique name, which is given to them by the user.

## Confidence threshold

The confidence threshold configuration attribute of a storage condition is of relevance in two situations:

* If the confidence of the plug-in risk score is below the threshold, the risk score will not be stored. Thus, the risk score will never be part of any training data set.
* For the computation of the normalized risk score, nevisDetect checks that all plug-in risk scores are above the confidence threshold of the related storage condition. This is to make sure that the plug-in risk scores used for computing the normalized risk score are from the same population as the training data used for training the normalization model.

The confidence threshold is a means to influence the false-positive rate. A false-positive HTTP request is a legitimate request detected as fraudulent, whereas a false-negative request is a fraudulent request falsely considered as legitimate by the system. The higher the confidence threshold, the more false-negative requests might slip through the detection process. See the figure below:

<img className="boxed" src={require('../../../attachments/6645071/6645296.png').default} alt="Confidence threshold"/>

The chosen value of the confidence threshold always represents a trade-off between security and user convenience. A low confidence threshold increases the security but lowers the user convenience, whereas a high confidence threshold increases the user convenience but decreases security.
--------------------------------------------------------------------------------
Section: ### Verification-of-the-installation.md
---
sidebar_position: 47
---

# Verification of the installation

To verify that every nevisDetect component is up and running after the installation, check the *Application monitoring* view in the *Status* section of the nevisDetect web application.

For more information, see the chapter Status section in the nevisDetect User Guide.

To be able to access the *Application monitoring* view, log in as a user with the required role ("Operator") and permission. In the default mapping, this is the role *DETECT_OPERATOR*, which must be mapped to the permission *APP_MONITORING_READ*.
See also Appendix: Role to Permission Mapping in this reference guide.
--------------------------------------------------------------------------------
Section: ### Monitoring.md
---
sidebar_position: 51
---

# Monitoring

There are several options to monitor nevisDetect:

* With log messages
* With the Status Service (REST API)

## Monitoring with log messages

It is possible to monitor nevisDetect, its components and plug-ins based on log messages. This chapter describes the relevant log messages per nevisDetect component.

These log messages also appear in the nevisDetect web application, in the *Application monitoring* view of the *Status* section. The *Application monitoring* view provides detailed information on all nevisDetect components and all available plug-ins. For more information, see Status section. Currently only messages of the INFO severity category are described.

## Core component

The next table lists the possible monitoring log messages for the Core component.

| Severity | Message example / Description | ID |
| --- | --- | --- |
| INFO | NevisProxyPolicy: name='demo-2' action-plugin='NevisProxyActionPlugin' risk-score='BehavioSecTransaction' ranges: range: min='0.295' max=1' action='AUTHENTICATE' | CC-I |
| | This message describes configured and activated nevisProxy policies (technical name: *NevisProxyPolicy*). | |
| INFO | NevisAuthPolicy: name='Behaviosec-Login' action-plugin='NevisAuthActionPlugin' risk-score='BehavioSecTransaction' ranges: range: min='0.3' max=1' action='ADDITIONAL_AUTHENTICATION' | CC-I |
| | This message describes configured and activated nevisAuth policies (technical name: *NevisAuthPolicy*). | |
| INFO | ThreadPool: active-count=0 pool-size=5 max-pool-size=200 | CC-I |
| | This message shows thread pool data. The message elements have the following meaning: `active-count`: Number of threads currently in use.`pool-size`: Current thread pool size. `max-pool-size`: Maximum number of threads. | |
| INFO | Messages: minProcessingTime=72 maxProcessingTime=678 averageProcessingTime=301.0 currentProcessingTime=72 (milli seconds) | CC-I |
| | This message gives information on the processing times. | |
| INFO | Messages: request/second=0.004366812227074236 (3/687.0) | CC-I |
| | This message shows the messages rate, that is, the number of JMS messages per total processing time. | |
| INFO | Persistency Batch: enabled='true' current-batch-size='0' max-batch-size='1000' max-batch-age='5000' [msec] (thread-pool-size='5') | CC-I |
| | This message gives information on the persistency batch. The message elements have the following meaning: `current-batch-size`: Number of requests currently in the batch. `max-batch-size`: Maximum batch size. `max-batch-age`: Maximum batch ageIf the maximum batch size or age is exceeded, the batched data will be sent to the Persistency service. | |

## Feature Correlator component

The next table lists the possible monitoring log messages for the Feature Correlator component.

| Severity | Message example / Description | ID |
| --- | --- | --- |
| INFO | Rule: rule-id='VKvGmMTl-RqDpDq59pdrVdQKUL_UO2a9m1HPiUPcyoQx' rule-action='BLOCK' user='LDAP/Thomas Bayes' active='true' | FC-I |
| | This message describes rules. The message elements have the following meaning: `rule-id`: ID of the rule. `rule-action`: The action that is related to the rule. `user`: Realm or login ID of the user addressed by the rule. | |
| INFO | Request filter: name='BehavioSec missing' enabled='true' processing='false' position='0' communication-mode='null' condition-source='BODY' condition-qualifier='NOT_CONTAINS_FIELD' condition-attribute-name='bdata' condition-expression='null' | FC-I |
| | This message describes request filters. The message elements have the following meaning: `enabled`: Flag showing if the request filter is enabled. `position`: Order position. `communication mode`: Indicates the communication mode.For more detailed information, see the configuration of the relevant request filter. | |
| INFO | Requests: minProcessingTime=0 maxProcessingTime=288 averageProcessingTime=22.0 currentProcessingTime=0 (milli seconds) | FC-I |
| | This message gives information on the processing times. | |
| INFO | Requests: request/second=0.01093983092988563 (22/2011.0) | FC-I |
| | This message shows the requests rate, that is, the number of HTTP requests per total processing time. | |
| INFO | Request Batch: current-batch-size='0' max-batch-size='2000' max-batch-age='10000' [msec] (thread-pool-size='4') | FC-I |
| | This message gives information on the request batch. The message elements have the following meaning: `current-batch-size`: Number of requests currently in the batch. `max-batch-size`: Maximum batch size. `max-batch-age`: Maximum batch ageIf the maximum batch size or age is exceeded, the batched data will be sent as JMS message to Core component. | |
| INFO | Sending request-modification (propagated risk-scores) | FC-I |
| | This message gives information on propagated risk scores. | |

## Persistency component

The next table lists the possible monitoring log messages for the Persistency component.

| Severity | Message example / Description | ID |
| --- | --- | --- |
| INFO | Messages: minProcessingTime=31 maxProcessingTime=602 averageProcessingTime=343.0 currentProcessingTime=31 (milli seconds) | PC-I |
| | This message gives information on the processing times. | |
| INFO | Messages: request/second=0.003740648379052369 (3/802.0) | PC-I |
| | This message shows the requests rate, that is, the number of REST calls per total processing time. | |

## Risk plug-ins

The next tables lists the possible monitoring log messages for the Risk plug-ins. There are three categories of messages: generic messages, BehavioSec-specific messages and nevisAdapt-specific messages.
--------------------------------------------------------------------------------
Section: ### Technical-architecture.md
---
sidebar_position: 22
---

# Technical architecture

## Overview

The figure below extends the previous figure Architecture overview by showing the different interfaces within nevisDetect:

<img className="boxed" src={require('../../attachments/6645042/6645642.png').default} alt="Technical architecture"/>

The table below lists the interfaces within nevisDetect:

| Interface name | Description | Type | Provider | Consumer |
| --- | --- | --- | --- | --- |
| ICAP (0) | ICAP interface | ICAP | nevisDetect Feature Correlator | nevisProxy (ICAP filter) |
| Request Data (1) | Interface for forwarding the data of the actual request as well as returning the generated rule in case of synchronous communication. | JMS queue | nevisDetect Core | nevisDetect Feature Correlator |
| Authentication Data (2) | Interface for forwarding the data of the actual authentication as well as returning the generated rule in case of synchronous communication. | JMSqueue | nevisDetect Core | nevisAuth (nevisDetect AuthState) |
| Statistic (3) | Interface for updating the user related statistical data and for persisting generated rules. | REST | nevisDetect Persistency | nevisDetect Core |
| Configuration (4) | Interface for reading the system configuration and the persisted rules. | REST | nevisDetect Persistency | nevisDetect CorenevisDetect Feature Correlator |
| Entities (5) | Interface for read/write access to the persisted entities. | REST | nevisDetect Persistency | nevisDetect Web App |
| Component Control (6) | Interface for getting the runtime status of all nevisDetect components. | REST | nevisDetect Controller | nevisDetect Web App |
| Component Status (7) | Interface for getting the status of a single nevisDetect component. | JMS topic | nevisDetect CorenevisDetect Feature CorrelatornevisDetect Persistency | nevisDetect Controller |

The next table lists the runtime of the nevisDetect components:

| Component | Runtime | Remarks |
| --- | --- | --- |
| nevisDetect Feature Correlator | Standalone JVM | TCP/IP server listening on localhost |
| nevisDetect AuthState | nevisAuth execution environment | AuthState deployed by nevisAuth |
| nevisDetect Core | Standalone JVM | A JMS Messaging Listener |
| nevisDetect Persistency | Servlet container | Web application implementing REST services |
| nevisDetect Controller | Servlet container | Web application implementing REST servicesServes the nevisDetect Web App with static content |
| nevisDetect Web App | Browser | Single Page Application (SPA) based on Angular 2 |

## Runtime

The following figure shows the asynchronous processing of an HTTP request within nevisDetect:

<img className="boxed" src={require('../../attachments/6645042/8004020.png').default} alt="HTTP request processing"/>

The processing of an HTTP request during authentication is shown in the following figure:

<img className="boxed" src={require('../../attachments/6645042/8004007.png').default} alt="Authentication request processing"/>

## Scaling and fail-safeness

Fail-safeness and scaling of nevisDetect is guaranteed by the message bus. The figure below is therefore showing the system from a messaging point of view:

<img className="boxed" src={require('../../attachments/6645042/6645653.png').default} alt="Request data queue"/>

## Monitoring

nevisDetect is a distributed system consisting of several components. The runtime status of all components is monitored by JMS topic:

<img className="boxed" src={require('../../attachments/6645042/6645650.png').default} alt="Monitoring nevisDetect"/>

The monitoring described here is displayed in the nevisDetect web application. For machine-related monitoring services, see chapter Liveness and health services.
--------------------------------------------------------------------------------
Section: ### Security.md
---
sidebar_position: 24
---

# Security

The following actors are important from a security point of view:

* The *user accessing the administration web application*, nevisDetect Web App. The nevisDetect Web App is an Angular 2 based Single Page Application (SPA) running in the browser of the user.
* The *components of nevisDetect* accessing others components.

In most environments a set of (security) roles are assigned to an identity (an identity can be e.g., a user). To  be able to integrate your enterprise environment seamlessly into nevisDetect, nevisDetect maps the security roles onto permissions, as you can see in the figure Role-permission-mapping below:

<img className="boxed" src={require('../../attachments/6645043/6645666.png').default} alt="Role-permission-mapping"/>

From now on, we call this mapping within nevisDetect *role-permission-mapping*. nevisDetect ships with a default *role-permission-mapping*. Use this default mapping as a starting point for your custom mapping configuration.

The default mapping is based on the assumption that for every persona a separate security role exists.  Additionally, there are security roles representing the different components of nevisDetect, see the table Personas and security roles below for an overview of all available personas and security roles. This allows an uniform treatment of all actors (users and components) from a security point of view.

| Persona/component | Security role |
| --- | --- |
| Support desk user (Persona) | DETECT_HELPDESK |
| Security expert | DETECT_SECURITY_OFFICER |
| Operator | DETECT_OPERATOR |
| Forensic expert | DETECT_FORENSIC_EXPERT |
| nevisDetect Core | DETECT_CORE |
| nevisDetect Feature Correlator | DETECT_FEATURE_CORRELATOR |
| nevisDetect Persistency | DETECT_PERSISTENCY |
| nevisDetect Controller | DETECT_CONTROLLER |

See how in the default *role-permission-mapping* a security role is mapped onto permissions:

Security role: `DETECT_FORENSIC_EXPERT`

* `APP_MANAGEMENT_READ`
* `APP_MANAGEMENT_PLUGIN_WRITE`
* `APP_MANAGEMENT_GLOBAL_WRITE`
* `APP_MANAGEMENT_FILTER_WRITE`
* `APP_MONITORING_READ`
* `CASE_OVERVIEW_READ`
* `CASE_WRITE`
* `CID_READ`
* `GENERATED_RULES_READ`
* `GENERATED_RULE_TOGGLE_ACTIVE`
* `GENERATED RULE_WRITE`
* `PLUGIN_OVERVIEW_READ`
* `PLUGIN_RISK_SCORE_WRITE`
* `POLICY_OVERVIEW_READ`
* `POLICY_TOGGLE_ACTIVE`
* `POLICY_WRITE`
* `POLICY_CREATE`
* `REFDATA_READ`
* `RISK_SCORE_NORMALIZATION_CALCULATE`
* `RISK_SCORE_NORMALIZATION_READ`
* `USER_OVERVIEW_READ`

Security role: `DETECT_SECURITY_OFFICER`

* `APP_MANAGEMENT_READ`
* `APP_MANAGEMENT_PLUGIN_WRITE`
* `APP_MANAGEMENT_GLOBAL_WRITE`
* `APP_MANAGEMENT_FILTER_WRITE`
* `APP_MONITORING_READ`
* `CASE_OVERVIEW_READ`
* `CASE_WRITE`
* `GENERATED_RULES_READ`
* `GENERATED_RULE_TOGGLE_ACTIVE`
* `GENERATED_RULE_WRITE`
* `PLUGIN_OVERVIEW_READ`
* `PLUGIN_RISK_SCORE_WRITE`
* `POLICY_OVERVIEW_READ`
* `POLICY_TOGGLE_ACTIVE`
* `POLICY_WRITE`
* `POLICY_CREATE`
* `REFDATA_READ`
* `RISK_SCORE_NORMALIZATION_CALCULATE`
* `RISK_SCORE_NORMALIZATION_READ`
* `USER_OVERVIEW_READ`

Security role: `DETECT_OPERATOR`

* `APP_MANAGEMENT_READ`
* `APP_MANAGEMENT_PLUGIN_WRITE`
* `APP_MONITORING_READ`
* `PLUGIN_OVERVIEW_READ`
* `REFDATA_READ`
* `RISK_SCORE_NORMALIZATION_READ`

Security role: `DETECT_HELPDESK`

* `CASE_OVERVIEW_READ`
* `CASE_WRITE`
* `GENERATED_RULES_READ`
* `GENERATED_RULE_TOGGLE_ACTIVE`
* `PLUGIN_OVERVIEW_READ`
* `POLICY_OVERVIEW_READ`
* `REFDATA_READ`
* `RISK_SCORE_NORMALIZATION_READ`
* `USER_OVERVIEW_READ`
* `CID_READ`

For a complete overview of the existing permissions and the default mapping, see Appendix: Role to Permission Mapping.

:::note
One security role can be mapped onto several permissions.
:::

## Authentication

nevisProxy and nevisAuth take care of the *user authentication* and the assignment of the security roles:

* They include the identity of the user as well as his security roles in the Nevis SecToken and forward the token to nevisDetect.
* nevisDetect authenticates the user by verifying the signature of the SecToken.

The *authentication of a nevisDetect component* happens during the 2-way TLS handshake:

* The calling component sends its X509 certificate during the TLS handshake.
* The called component ensures that the X509 certificate is issued by a known and trusted Certificate Authority.

## Authorization

The authorization process includes three steps:

1. First, the system retrieves the security roles of the caller.

* In the case of a user, the security roles are retrieved from the SecToken.
* In the case of a nevisDetect component, a single security role is derived from the Subject of the X509 certificate. For this, it is possible to configure a regular expression.
 The default regular expression extracts the Common Name (CN) from the Subject of the X509 certificate.

2. As a next step, the system retrieves the permissions of the caller based on its security role.
3. Finally, the system ensures that the caller has the requested permission for the service.
--------------------------------------------------------------------------------
Section: ### Plug-in-nevisAdapt.md
---
sidebar_position: 28
---

# Plug-in nevisAdapt

The nevisAdapt plug-in delivers three different kinds of risk scores:

* The *NevisAdaptDeviceFingerprint*risk score is based on a so-called *device fingerprint*. This device fingerprint is computed by a JavaScript library on the user's device.
* The *NevisAdaptGeolocation*risk score is based on the geolocation of the user. To calculate this risk score, the plug-in uses the user's IP address.
* The *NevisAdaptDeviceRecognition*risk score is based on a persistent cookie.

For more information about the nevisAdapt service, see the nevisAdapt Technical Documentation.

The next table describes the configuration attributes of the nevisAdapt plug-in.

| Name | Type/unit | Example | Description |
| --- | --- | --- | --- |
| name | string | NevisAdapt | Specifies the name of the plug-in. |
| url | URL | `https://localhost:8888` | Defines the URL of the service. |
| colorCodes | list of string tuples | colorCodes=NevisAdaptDeviceFingerprint:#0B6623,NevisAdaptGeolocation:#3BB143,NevisAdaptDeviceRecognition:#C7EA46 | Defines the HTML color codes of plug-in's risk scores. The risk scores will be shown in these colors in the nevisDetect web application. |
| riskScores | list of strings | riskScores=NevisAdaptDeviceFingerprint,NevisAdaptGeolocation,NevisAdaptDeviceRecognition | Specifies a list of the risk scores delivered by the plug-in. |
| nevisadapt.cookie.name | string | device_cookie | Name of the device recognition cookie. This is the name set by nevisAuth in the AuthState *DeviceCookieAuthState*, attribute *cookieName*. See also DeviceCookieAuthState]". |
| nevisadapt.fingerprint.hash.backend | boolean | false | If set  to "true", the fingerprint hash for the nevisAdapt plug-in is calculated on the backend. Note that this feature is not supported for FingerprintJS 3. If set to "false", the system uses the fingerprint hash generated by the FingerprintJS library. |
| nevisadapt.fingerprint.components | list of strings | addBehavior,platform,webgl | Defines a comma-separated list of components that are included in the fingerprint hash calculation, in case the fingerprint hash is calculated on the backend side. For a complete list of available components, see the chapter Fingerprint module in the nevisAdapt reference guide. Only FingerprintJS 2 keys are supported. |
| nevisadapt.cache.disabled | boolean | false | Enables or disables caching in the nevisAdapt plug-in. Caching is enabled by default. Set this attribute to "true" to disable caching.  |
| nevisadapt.cache.eviction.max.size | number | 50000 | Maximum number of cached results and sessions. We recommend that you set this number slightly above the number of maximum parallel sessions in the system. |
| nevisadapt.cache.eviction.expiry.minutes | number | 180 | Maximum lifetime of the cached results. We recommend that you set this lifetime slightly above the maximum session lifetime in the system. |
| nevisadapt.httprequest.ignore | boolean | false | Specifies whether HTTP requests must be ignored. In this case, the plug-in will only process requests coming from nevisAuth. The default is "false". Set this attribute to "true" to ignore HTTP requests. If you turn off the caching we advise also turning off this feature, to not overload the service. |
| nevisadapt.httprequest.ignore.method | string | GET | Use this attribute to ignore requests with a specific HTTP method.For example, if you set this attribute to "GET", the nevisAdapt plug-in will ignore all requests with HTTP method GET. |
| nevisadapt.httprequest.ignore.without | string | bdata | Makes the nevisAdapt plug-in ignore all requests without the data specified in the attribute.  |
| nevisadapt.httprequest.mimetypes | string (comma-separated) | application/behaviosec | Adds custom-supported MIME types. You can set more than one MIME type. Separate the types with a comma. |
| http.client.connectTimeout | int/msec | 500 | The timeout (in milliseconds) for establishing a TCP connection. |
| http.client.retryTimeout | int/msec | 5000 | The retry timeout (in milliseconds) in case of a connection error or an HTTP error code. |
| http.client.keyStore | file | file:/var/opt/neviskeybox/default/rdf/nevisAdapt truststore.jks | The Java keystore file used to establish the TLS connection. |
| http.client.keyStorePassword | string | file:/var/opt/neviskeybox/default/nevisdetect/nevisAdapt_keystore.jks | The passphrase for the keystore. |
| http.client.trustStore | file | | The Java truststore file used to establish the TLS connection. |
| http.client.trustStorePassword | string | | The passphrase for the truststore. |
--------------------------------------------------------------------------------
Section: ### Plug-in-BehavioSec.md
---
sidebar_position: 26
---

# Plug-in BehavioSec

The BehavioSec solution consists of two parts:

* User device
The user device collects behavioral data and passes this on to the BehavioSec service, via nevisDetect. The collection of the data is done by the BehavioSec SDK, which therefore needs to be integrated into the client application. For more information, see the [BehavioSec Developer Portal](https://developer.behaviosec.com/dw/integration_overview).
* BehavioSec service
The BehavioSec service builds a user profile out of the data from the user device. When it has collected enough data, the BehavioSec service assigns various scores to a HTTP request. These scores have values within the range of 0.0 to 1.0. They are "similarity" scores: The higher the score, the more the HTTP request matches the trained user profile. The BehavioSec plug-in converts the BehavioSec similarity scores into nevisDetect risk scores:  *risk-score<sub>nevisDetect</sub> = (1 - similarity-score<sub>BehaviosSec</sub> )*

Which data BehavioSec collects, depends on the type of application:

* In case of a web application, the collected data is related to the mouse movement and the typing of the user.
* In case of a mobile application, BehavioSec collects additional data from the device's gyroscope and accelerometer.

The BehavioSec plug-in delivers three different kinds of risk scores:

* The *BehavioSecTransaction* risk score is based on the behavioral data of the actual HTTP request.
* The *BehavioSecSession* risk score is based on the behavioral data of all HTTP requests in the current session.
* The *BehavioSecRisk* risk score is an aggregation of the *BehavioSecTransaction* and *BehavioSecSession* risk score, taking into account additional, non-behavioral data (available with BehavioSec v4.3 or above).

For more details, visit the BehavioSec [Homepage](https://www.behaviosec.com/).
--------------------------------------------------------------------------------
Section: ### Overview-and-Main-Concepts.md
---
sidebar_position: 55
---

# Overview and Main Concepts

This user guide explains how to work with nevisDetect. The goal of nevisDetect is to detect malicious and untrustworthy user interactions and to mitigate their consequences.
To be able to detect malicious user requests, nevisDetect makes use of multiple anomaly detection technologies. By correlating multiple attributes like behavioral biometrics, geolocation or device information it is possible to create very unique user profiles. If the attributes of a request coming from a certain user differ substantially from his profile, nevisDetect will react.

Additionally, there is a possibility to integrate a custom risk detection technology, through the Proxy plug-in.

This chapter shortly discusses the main concepts of nevisDetect, which you need to know to be able to work with the nevisDetect web application.

For detailed information, see the chapter Conceptional Overview and its subchapters in the nevisDetect reference guide.

## Plug-ins

One of the main concepts of nevisDetect is the use of *plug-ins*. A plug-in connects nevisDetect with a particular anomaly detection technology. A plug-in itself contains no detection functionality. It calls a remote anomaly detection service as well as extracts and converts data.

An example of such a plug-in is the *BehavioSec* plug-in. This plug-in links nevisDetect with the BehavioSec detection service, whose decisions about the trustworthiness of a user interaction are based on how the user moves the computer mouse (biometrical data). The BehavioSec plug-in delivers two risk scores:

* The *BehavioSecTransaction* risk score is based on the behavioral data of the actual HTTP request.
* The *BehavioSecSession* risk score is based on the behavioral data of all HTTP requests in the current session.

Another example of a plug-in is the nevisAdapt plug-in. This plug-in/detection service analyzes HTTP requests based on the physical context of the user login attempt, e.g., the login location and time.

The nevisDetect web application gives an overview of all connected plug-ins. If you do not want to include a certain plug-in in the risk calculation, you can disable this plug-in in the web application.

For more information about how to configure the plug-ins, see the chapter nevisDetect plug-ins in the nevisDetect reference guide.

## Risk scores

The *risk score* of a user interaction/HTTP request is an indication about the trustworthiness of the request. nevisDetect uses risk scores to decide if it is necessary to take action (such as asking the user to re-authenticate or blocking the user).

:::info
 In the context of nevisDetect, the term *risk* always refers to the risk that someone other than the legitimate user has executed the HTTP request.
:::

For every user request, each plug-in determines a *plug-in risk score*, a numerical value between 0.0 and 1.0. For this, the plug-in compares the request data with the relevant user profile. The more the request data matches the profile, the lower the risk (score).

In the nevisDetect web application, you can define how nevisDetect deals with the plug-in risk scores (e.g., ignore a plug-in risk score if it is below a certain threshold, or assign different weights to the risk scores of the different plug-ins, to express their importance in the overall risk calculation).

To determine the overall risk of a specific HTTP request from a specific user, nevisDetect aggregates the risk scores of all plug-ins into a *normalized risk score*, a single numerical value between 0.0 and 1.0. The normalized risk score indicates the overall risk of the HTTP request.

* A normalized risk score of 0.0 signals no risk at all: the legitimate user has executed the request.
* A normalized risk score of 1.0 signals a maximum risk: It is for sure that the request has *not* been executed by the legitimate user.

There are several methods or algorithms to compute the normalized risk score. You define the method to use in the nevisDetect web application.

For more information about risk scores, see the chapter Normalization in the nevisDetect reference guide.

## Policies, actions and rules

nevisDetect uses policies, actions and rules to determine how to react to a specific normalized risk score.

The *policy* connects a specific normalized risk score with an *action*. A *rule* connects the action with the user who has sent the request.

For more information about policies, actions and rules, see the chapters Policy in the nevisDetect reference guide.
--------------------------------------------------------------------------------
Section: ### Policies
A *policy* consists of several ranges and associated actions. The ranges represent the possible values of the normalized risk score.

Usually, there are three ranges. Each range corresponds with a certain risk level and is connected with a certain action (e.g., asking the user to re-authenticate or block the user entirely) - see Figure Policy - normalized risk score and actions.

In the nevisDetect web application, you can create policies according to your needs. For each policy, define the ranges and connect them with suitable actions.
--------------------------------------------------------------------------------
Section: ### Actions
nevisDetect supports the following *actions*:

* PASSTHROUGH: Forwards the request to the application and notifies the application. This happens in the background, the user does not notice anything.
* AUTHENTICATE: Terminates the authenticated session. The user has to log in and authenticate again.
* BLOCK: blocks all requests of this specific user.

In the nevisDetect web application, you can link these actions with (the risk score ranges of) a policy.

<img className="boxed" src={require('../attachments/6645034/6645676.png').default} alt="Sample policy - normalized risk score and actions"/>

## Rules

A *rule* connects an action with the user that has sent the HTTP request.

Suppose user X sends an HTTP request to an application in the backend. nevisDetect assigns a normalized risk score of "0.5" to this request. This score matches with the second risk score range of the valid policy and correlates with the action "AUTHENTICATE".

nevisDetect reacts accordingly, that is, it creates a rule. This rule contains, among others, the user ID of the corresponding user as well as the relevant action. The rule is a sort of instruction for nevisProxy to execute the action (here, to make the user re-authenticate himself).

nevisDetect creates rules automatically, you do not have to do anything. However, you can deactivate a rule. This may be necessary, for example, if the system falsely blocks a user (a so-called "false-negative"), and the user cannot do anything anymore.

:::note
nevisDetect only creates rules if an action is required (that is, in case of AUTHENTICATE or BLOCK).
:::

## Cases

Each time nevisDetect creates a rule, it also creates a *case*.

The rule is necessary to trigger the action (AUTHENTICATE or BLOCK). The corresponding case is a kind of report that shows all the details regarding the rule/case (time of detection, action taken, request ID, risk score),  the request itself (HTTP session ID, request URL) and the user (user ID, actual risk score, status).

## Modes

nevisDetect can operate in several *operation and communication modes*. You set these modes in the nevisDetect web application.
--------------------------------------------------------------------------------
Section: ### Operation mode
Before nevisDetect can start detecting malicious HTTP requests, it must pass a *training phase*. During this phase, nevisDetect is just collecting data, so that the detection technologies can train their models. In the nevisDetect web application, this phase corresponds with the *operation mode* "Training".

A specific plug-in/detection technology has collected enough data of a specific user, if for this user the average plug-in risk score (the *mean*) and the *variance* do no longer change from day to day. From that point on, you can switch the plug-in into the *detection phase.*

In the nevisDetect web application, you can select between two different operation modes for the detection phase: "Detection" or "Mixed". The difference between these two options is how an untrained user is treated: In the "Mixed" mode, the application will not create any rule for untrained users.
--------------------------------------------------------------------------------
Section: ### Communication mode
If nevisDetect detects a fraudulent request, it creates a rule and notifies nevisProxy. The c*ommunication mode* specifies how to propagate the created rule to nevisProxy.

There are two modes available: the *synchronous and asynchronous communication mode*. They differ in when the rule is propagated to nevisProxy. You can set your preferred communication mode in the nevisDetect web application.

*Failopen* feature: Through this feature, you can determine how the application should behave if any of the plug-ins failed to process a request. Enable this feature to ensure that no user will be blocked if any of the plug-ins could not process his request.

## Request filter management

The Request Filter Management functionality allows you to ignore requests in certain cases, for example if the request does not contain specific data fields. This functionality also makes it  possible to override the default communication mode for specific URLs.

## Personas

If you read this user manual, you probably have to work with the nevisDetect web application. This means that you have one of the following roles:

* Forensic expert
* Security expert
* Support desk user
* Operator

In nevisDetect, these roles are called *personas*. Each persona has specific rights that correspond to the tasks he/she has to perform. Also, it depends on the persona what you get to see of and what you can do in the nevisDetect web application.

The four personas "forensic expert", "security expert", "support desk user" and "operator" are part of the standard permission concept of nevisDetect. However, it is possible to create different personas with different permissions, according to the needs of your company. For more information, see the chapter Security in the nevisDetect reference guide.
--------------------------------------------------------------------------------
Section: ### Forensic expert
The *forensic expert* analyzes and verifies the origination of a case.

The *Case overview* view in the nevisDetect web application is therefore an important view for the forensic expert. But to be able to perform his job well, the forensic expert needs access to all views of the nevisDetect web application.

* For more information about the forensic expert and his most important use cases, go to the chapter Forensic expert.
--------------------------------------------------------------------------------
Section: ### Operator
The *operator* operates the nevisDetect overall system. For this, he or she needs to monitor the nevisDetect web application and check that everything works fine. However, he is not allowed to modify nevisDetect's configuration and settings.

The operator has access to all views necessary to perform his tasks*.* These are the *Plug-in overview* and the *Application monitoring* views.

* For more information about the operator and his most important use cases, go to the chapter Operator.
--------------------------------------------------------------------------------
Section: ### Introduction-to-the-User-Guide.md
---
sidebar_position: 53
---

# Introduction to the User Guide

This user guide describes nevisDetect, which is part of the Nevis Security Suite. NevisDetect implements continuous, risk-based user authentication by correlating the output of multiple anomaly detection technologies.

The user guide shortly discusses the concepts of nevisDetect you need to know to be able to work with the product. The guide then describes the nevisDetect web application. It concludes with step-by-step instructions of the common use cases, per role (*personas* in nevisDetect).
--------------------------------------------------------------------------------
Section: ### User-Interface.md
---
sidebar_position: 56
---

# User Interface

This chapter describes the user interface of the nevisDetect web application.

The nevisDetect web application is

* Normalization
* User
* Policy
* Case
* Status
* Audit

Use the top menu of the application to navigate between the sections, see the figure below. The top menu is always visible.

Each section offers one or more views, which you access through the navigation on the left (see the figure below). This left navigation changes according to the selected section in the top menu.

Due to different permissions, the views and menu entries that are visible may differ per user.

<img className="boxed" src={require('../../attachments/6645074/6645562.png').default} alt="Navigation concept"/>

The different sections and their views are described in the next subchapters.

## UI elements

In all views, certain UI elements such as icons and buttons appear repeatedly. For the sake of clarity and understandability, the table below lists these UI elements with their names.

| UI element | Name |
| --- | --- |
| | Expand icon |
| | Settings (also "gear") icon |
| | Eye icon |
| | Pencil icon |
| | Save icon |
| | Drop-down menu icon |
| | **Activate** or **Deactivate** button |
--------------------------------------------------------------------------------
Section: ### Forensic-expert.md
---
sidebar_position: 64
---

# Forensic expert

The *forensic expert* analyzes detected, (potentially) harmful user requests (also called "cases"). This includes all user requests for which the normalized risk score is so high that it requires an action from the system.

Based on his analyses, the forensic expert may make statements about the security risks of the applications protected by nevisDetect, and take decisions regarding the correct security policies.

The most important use cases for the forensic expert are:

* Search for and analyze a detection case
* Further process a detection case
* Search for users with high risk score

## Use case: Search for and analyze a detection case

In nevisDetect, all suspicious user requests are logged as detection cases. In the nevisDetect web application, the *Case overview* view provides an overview of all detection cases. You can search for detected user requests in this view.

Proceed as follows (see the [figure below]:Proceed as follows (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Case overview* view in the nevisDetect web application,
    1. Select *Case* from the top menu.
    2. Then select *Case overview* in the navigation on the left.
2. In the *Filter case list* part, specify your search criteria, such as the login ID of a certain user, (part of the) case name, time range, and so on.
3. Click *Filter* to search for all cases that meet the search criteria.
4. The *Case list* part displays all cases that fulfill the criteria.
    1. Click the *Expand* icon to view and analyze the details of a specific case.
5. The case details appear in the field below the case entry.

For a description of the *Case overview* view, see the chapter Case section.

<img className="boxed" src={require('../../attachments/6645086/6645599.png').default} alt="Forencis expert - Search for cases"/>

## Use case: Further process a detection case

When analyzing a certain detection case, the forensic expert may want to rename a case according to a certain naming convention (nevisDetect gives each detection case an automatic name). It is also possible to tag the case, e.g., to categorize it.  Additionally, the forensic expert may want to add notes to the case, e.g., to remind himself of further steps to take regarding this case.
Finally, he/she may want to delete a detection case, because e.g., it occurred too far back in the past. To perform these tasks, execute the following steps, see the figure below:

1. Open the *Case overview* view and search for the detection cases you want to analyze. For instructions, see the previous use case Search for and analyze a detection case.
2. To change the name of the detection case, click the *Pencil* icon on the right of the *Case name* field.
    1. Enter the new name in the now editable field.
    2. Click the *Save* icon to save the new name.
3. To assign a tag to the detection case,
    1. Enter the tag directly in the *Tags* field.
    2. Click *Enter* to save the tag.
4. To add some remark to the detection case,
    1. Enter the text in the *Notes* text field.
    2. Click *Enter* to save the note.
5. If you want to completely delete the detection case, click the *Delete* icon on the right of the case entry.

<img className="boxed" src={require('../../attachments/6645086/6645594.png').default} alt="Forensic expert - Process a detection case"/>

For a description of the *Case overview* view, see the chapter Case section.

## Use case: Search for users with high risk score

When analyzing a certain detection case, the forensic expert may be interested in the (number of ) users with a high risk score. To search for users with a certain risk score, execute the following steps (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *User overview* view in the nevisDetect web application,
    1. Select *User* from the top menu.
    2. Then select *User overview* in the navigation on the left.
    You can now define the search criteria.
2. To define the risk score range, proceed as follows:
    1. Define the kind of risk score range in the *Risk score range* field. It is possible to show all users with risk scores above or below a certain value, or in between two values.
    2. Set the risk score values.
    3. Select the kind of plug-in risk score, for example the BehavioSecSession risk score.
3. Click *Filter* to search for all users that meet the search criteria.
4. The *User list* part displays all users that fulfill the criteria.

<img className="boxed" src={require('../../attachments/6645086/6646119.png').default} alt="Forensic expert - Search for users with high risk score"/>

For a description of the *User overview* view, see the chapter Users section.
--------------------------------------------------------------------------------
Section: ### Support-desk-user.md
---
sidebar_position: 70
---

# Support desk user

The task of the *support desk user* is to help end users of nevisDetect-protected applications who are stuck, e.g., because nevisDetect (falsely) blocked the user after a specific user interaction and the user cannot do anything anymore. The support desk user will first try to find out which rule is responsible for the situation. If he assesses the situation as risk-free and safe, he can adjust the rule.

So the common use case of the support desk user is to adjust a rule, to help an end user who is impacted by the rule.

## Use case: Adjust a rule to help an end user

The *Generated rules* view of the *Case* section contains all rules generated by any policy. This is also where you search for and adjust a rule.

Proceed as follows (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Generated rules* view in the nevisDetect web application,
    1. Select *Case* from the top menu.
    2. Then select *Generated rules* in the navigation on the left.
2. Search for the rule that impacts the end user. Therefore, specify relevant search criteria in the *Filter generated rules* part. You can e.g, search for all rules with the user's login ID, or that were generated in the last 24 hours, or with action "BLOCK", and so on.
    1. Click *Filter* to search for all rules that fulfill your search criteria.
3. All rules that meet the search criteria are listed in the *Generated rules* part. Click the *Expand* icon to view the rule details and history. Based on the rule details and the information coming from the end user, the support desk user must decide whether it is safe to disable the rule.
   * To get more information about the detection case connected to the rule, the support desk user can view the case's details in the *Case overview* view. For a description of the *Case overview* view, see the chapter Case section.
   * To get more information about the end user in question, the support desk user can have a look at the risk score history of this user. This information is available in the *User overview* view. For more information about the *User overview* view, see the chapter User section.

4. There are three options to disable a rule:
    1. You can change the action triggered by the rule, e.g., from BLOCK to AUTHENTICATE or PASSTHROUGH.
    If you select AUTHENTICATE, the end user is not blocked anymore, but must re-authenticate to be able to continue working.
    If you select  PASSTHROUGH, no action is required from the end user anymore.
    In both cases, the rule remains in the system.
    You change the action of the rule in the *Action* field/drop-down menu.
    2. You can deactivate the rule, by clicking the *Activate/Deactivate* button on the right side of the rule. The rule is not effective anymore, and the end user is unblocked.
    Also in this case, the rule still exists. It is possible to re-enable the rule.
    3. You can completely delete the rule. Therefore, click the *Drop-down menu* icon on the *Activate/Deactivate* button. Select *Delete* from the drop-down menu.
    In this case, the rule is removed and does not exist in the system anymore.

<img className="boxed" src={require('../../attachments/6645085/6645595.png').default} alt="Support desk user - Adjust a rule"/>

For more information on the *Generated rules* view, see the chapter Case section.
--------------------------------------------------------------------------------
Section: ### Operator.md
---
sidebar_position: 71
---

# Operator

The *operator* operates the nevisDetect web application. For this, he or she needs to monitor the nevisDetect web application and check that everything works fine.

The *Application monitoring* screen can be used to verify that an installation was successful and every component is up and running.

The operator has the following use cases:

* Monitor the status of the plug-ins and nevisDetect components
* Monitor the risk score statistics of the plug-ins

## Use case: Monitor the status of the plug-ins and nevisDetect components

The *Application monitoring* view in the *Status* section provides an overview of the current status of all available plug-ins and the nevisDetect components.

Proceed as follows (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Application monitoring* view in the nevisDetect web application,
    1. Select *Status* from the top menu.
    2. Then select *Application monitoring* in the navigation on the left.
2. All nevisDetect components and available plug-ins are listed in the view. Click the *Expand* icon to view the status details.

For a description of the *Application monitoring* view, see Status section.

<img className="boxed" src={require('../../attachments/6645088/6645591.png').default} alt="Operator - Status monitoring"/>

## Use case: Monitor the risk score statistics of the plug-ins

The Plug-in overview view in the User section provides an overview of the available plug-ins, including the statistics and history of the plug-in risk scores. Proceed as follows (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Plug-in overview* view in the nevisDetect web application, select *User* from the top menu, then select *Plug-in overview* in the navigation on the left.
2. All available plug-ins are listed in the view. Click the *Expand* icon to view the plug-in's risk score statistics and history.

For a description of the *Plug-in overview* view, see the chapter User section.

<img className="boxed" src={require('../../attachments/6645088/6645592.png').default} alt="Operator - View plug-in risk score statistics"/>
--------------------------------------------------------------------------------
Section: ### Use-Cases-and-Personas.md
---
sidebar_position: 63
---

# Use Cases and Personas

This part of the user guide contains (step-by-step) descriptions of the most common use cases when working with nevisDetect.

Persons with the following roles use nevisDetect:

* Forensic expert
* Security expert
* Support desk user
* Operator

In nevisDetect, these roles are called *personas*. Each persona has specific rights that correspond to the tasks he/she has to perform. Also, it depends on the persona what you get to see of and what you can do in the nevisDetect web application.

The four personas "forensic expert", "security expert", "support desk user" and "operator" are part of the standard permission concept of nevisDetect. However, it is possible to create different personas with different permissions, according to the needs of your company. For more information, see the chapter Security in the nevisDetect reference guide.

The following chapters describe the most important use cases per persona.
--------------------------------------------------------------------------------
Section: ### Review-system-changes.md
---
sidebar_position: 69
---

# Review system changes

Another task of the security expert is to review the system changes of the nevisDetect application or to find out which change of the system caused a problem. This corresponds with the following use case:

* View Audit log

## Use case: View Audit Log

You can view all the changes made to the nevisDetect system in the Audit log screen. Proceed as follows (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Audit log* view in the nevisDetect web application,
    1. Select *Audit* from the top menu.
2. You can filter the audit log records by login ID, time range or revision type (ADD: creation, MOD: modification, DEL: deletion, ALL: all). Click the *Filter* button to show all log records that fulfill your filter criteria.
3. The filter results are shown in the table below the *Filter* button. Specify the category of log records you would like to see, by selecting the corresponding tab on top of the table.
    1. The *Revision type* column displays the kind of change (deletion, modification, creation), the *Date* column the modification date.
    2. The *User name* column contains the login ID of the user who made the change. In case the change was triggered by the system you will see a technical user here.

<img className="boxed" src={require('../../../attachments/6645087/6645598.png').default} alt="Security expert - Review system changes"/>

For more information on the Audit log view, see the chapter Audit section.
--------------------------------------------------------------------------------
Section: ### Normalized-risk-score-calculation.md
---
sidebar_position: 67
---

# Normalized risk score calculation

Besides the creation and adaptation of policies, the security expert decides how to calculate the normalized risk score out of the plug-in risk scores. The normalized risk score of an HTTP request is one single measurement for the request's risk, based on the various risk scores coming from the different detection technologies or plug-ins.  There are various algorithms available to calculate the normalized risk score.

The task of the security expert is to configure and test normalization models that can be used to calculate normalized risk scores. This task involves the following use cases:

* Specifying how to handle plug-in risk scores
* Creating training data sets
* Configuring and training normalization models
* Testing a normalization model
* Viewing the statistic details of a model

## Use case: Specifying how to handle plug-in risk scores

The normalized risk score of an HTTP request ist based on the various risk scores coming from the different detection plug-ins. So specifying how to handle these plug-in risk scores is the first step in the process of configuring a normalization model.

The handling of risk scores includes the definition of the storage conditions. First specify what to do when an HTTP request does not deliver all plug-in risk scores. You also have to decide how to handle risk scores with a low confidence level. The confidence level of a risk score shows how confident nevisDetect is about the correctness of a risk score value.

You define these settings in the Training data view of the Normalization section. This is how you have to proceed (see the figure below  - the numbers in the figure correspond with the numbered steps below):

1. To open the *Training data* view in the nevisDetect web application,
   1. Select *Normalization* from the top menu.
   2. Then select *Training data*in the navigation on the left.
2. You define the storage condition per plug-in risk score in the *Storage conditions* field. A storage condition consists of a *qualifier*regarding the presence of the plug-in risk score, and a numeric confidence threshold.
   1. You set the qualifier for the presence of the risk score in the *Risk score presence* field.
    Some detection technologies cannot deliver a risk score for every HTTP request. For your training purposes, such HTTP requests might be useless, as they do not deliver the complete set of risk scores. The *Risk score presence* field defines how to deal with such requests, per risk score. The following values for the qualifier are defined:
       * IGNORE means that the respective plug-in risk score will never be stored.
       * REQUIRED means that the presence of this plug-in risk score is required. If the plug-in risk score is not present for the HTTP request, no plug-in risk scores at all will be stored for the corresponding HTTP request.
       * OPTIONAL means that the plug-in risk score is optional. It will be stored if present. This setting has no influence on the storare of the HTTP request's other plug-in risk scores.
          1. Set the qualifier for the presence of the risk score per plug-in risk score. If it is not clear which plug-in risk scores you need, configure the qualifier OPTIONAL.
   2. You define the confidence threshold in the *Confidence threshold* field, by entering a numeric value between 0 an 1. If the confidence of the plug-in risk score is below the threshold, the risk score will not be stored.

<img className="boxed" src={require('../../../attachments/6645084/16124641.png').default} alt="Security expert - Handling plug-in risk scores"/>

For more information on the *Training data* view, see Normalization section.

## Use case: Creating training data sets

Defining training data sets is the second step in the process of configuring a normalization model. You use these data sets later on for training and testing your normalization models (and as such for calculating the normalized risk score). Training data sets are defined in the Training data view of the Normalization section. This is how you have to proceed (see the figure below  - the numbers in the figure correspond with the numbered steps below):

1. To open the *Training data* view in the nevisDetect web application,
    1. Select *Normalization* from the top menu.
    2. Then select *Training data*in the navigation on the left.
2. Click *New dataset*.
3. You configure the training data sets in the *Training data set definition* field. Per training data set,
    1. Click on the Pencil icon to specify a suitable name for the data set. The normalization models refer to training data sets by their names. Therefore, be sure that the name is unique.
    2. Select the plug-in risk scores to include in the training data set, under *Plug-ins*.
    3. Set the time frame to consider, in units ("Day" or "Month"). Additionally, you specify the number of units to consider (field*Time frame value*). For example, if you select the time frame unit "Month" and set the time frame value "12", then all relevant risk scores from the past year (12 months) are included in the training set.
    4. Click *Create* to create the new training data set.

The number of the selected plug-in risk scores defines the dimension of the training data set, whereas the time frame defines the size.  Due to computational reasons, the total amount of training data must be limited.  However, you can configure several training data sets without influencing the storage space. For more information on the *Training data* view, see Normalization section.

<img className="boxed" src={require('../../../attachments/6645084/16124655.png').default} alt="Security expert - Creating a training data set"/>

## Use case: Configuring and training normalization models

In the previous use cases, it was explained how to handle the plug-in risk scores and how to create a training data set. The next step is to configure and train a normalization model. You do this in the Normalization models view of the Normalization section. Proceed as follows (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Normalization models* view in the nevisDetect web application,
    1. Select *Normalization*from the top menu.
    2. Then select *Normalization models* in the navigation on the left.
2. A normalization model is based on a normalization algorithm. Select this algorithm before you can create a new model. You do this in the drop-down menu next to the *New model* button (see no. 2 in the next figure). The following algorithms are available: OLS regression model, SVR regression model, Naive density estimation, Minumum weighted risk scores, Maximum weighted risk scores, Sum weighted risk scoreFor a description of all available normalization models, see Normalization models in the nevisDetect reference guide.

    1. Select a normalization algorithm from the drop-down menu.
    2. Click *New model* to create a new normalization model based on the algorithm you just selected.

3. Now you can configure your new normalization model. You do this in the field that opens when you have clicked *New model*. Perform the following steps:
    1. First specify some general settings, such as whether to enable training or prediction. For this, click the buttons *Training enabled* or *Prediction enabled*, respectively. Additionally, define whether to store the risk scores, by clicking the button *Persist risk scores*.
    2. In the field *Risk score name, s*pecify a name for the normalized risk score calculated by this normalization model. This name is used in all graphical overviews.
    3. In the *Color code* field, choose a color for the normalized risk score. The risk score is shown in this color in graphical overviews.
    4. The *Algorithm* field displays the normalization algorithm on which this normalization model is based.
    5. Select the data set that you want to use for training your model in the field Dataset. The data sets you can choose here are the ones you defined in the Training data view, see Use case: Creating training data sets. You can also set the minimum and maximum required number of HTTP requests for the training of your model, as well as the maximum training time in seconds (the fields Min num training data, Max num training data and Max training time (sec), respectively).
    6. The *Configuration* field allows you to specify settings that are specific for this respective normalization model.
    7. Click the *Train model* button to train your model. The training details appear below the button as soon as the training is finished.

<img className="boxed" src={require('../../../attachments/6645084/16124663.png').default} alt="Security expert - Configuring a normalization model"/>

For more information on the *Normalization models* view, see Normalization section.

## Use case: Testing a normalization model

You can now test your normalization model. You do this in the Normalization models view of the Normalization section, too. Proceed as follows (see the figure below  - the numbers in the figure correspond with the numbered steps below):

1. To open the *Normalization models* view in the nevisDetect web application,
    1. Select *Normalization*from the top menu.
    2. Then select *Normalization models* in the navigation on the left.
2. The *Model test* part of the *Normalization models* view defines the settings for testing your normalization models. This part contains the following elements:
    1. The models are tested for a specific user, which you define in the *Login ID* field (by entering the user's login ID). The *Realm* field allows setting the relevant authentication realm.
    2. All available normalizations models are listed next to the *Login ID* and *Realm* fields (see "b" in the figure). Enable the ones you want to include in the test. You can test several models at once.
    3. Clicking the *Test model* button triggers the testing of the selected normalization model(s).
    4. Click the Settings icon to set the test time frame.
    5. The graphic below the *Test model* button shows the test result. That is, the risk scores for the HTTP requests made by the respective user during the defined time frame.
    6. The graphic shows each risk score as a colored dot. The meaning of the colors is explained next to the graphic. In our example, dots with a bright green color represent the normalized risk score "test-corine". This is the name of the risk score calculated by our sample normalization model "Test-Corine". You define the name of a risk score and the color of the dots when defining the corresponding normalization model.  Note that the graphic not only shows the normalized risk scores, but also the separate risk scores of the various plug-ins. Together, these plug-in risk scores make up the normalized risk score. These plug-in risk scores have another color, as you can see in the figure.  If you want to exclude a specific risk score from the graphic, click on the corresponding color bar.

<img className="boxed" src={require('../../../attachments/6645084/16124673.png').default} alt="Security expert - Testing a normalization model"/>

## Use case: Viewing the statistic details of a model

The Normalized risk scores view of the Normalization section allows you to view the statistic details of a normalization model. Proceed as follows (see the figure below  - the numbers in the figure correspond with the numbered steps below):

1. To open the *Normalized risk scores* view in the nevisDetect web application,
    1. Select *Normalization*from the top menu.
    2. Then select *Normalized risk scores* in the navigation on the left.
2. The *Normalized risk scores* view contains the statistic details per model as well as a graphical representation of the risk score history. For a description of the view, see Normalization section,  Normalized risk scores.

<img className="boxed" src={require('../../../attachments/6645084/16124682.png').default} alt="Security expert - Viewing the statistic details of a model"/>
--------------------------------------------------------------------------------
Section: ### Policy-handling.md
---
sidebar_position: 66
---

# Policy handling

One of the tasks of the security expert is the handling of policies. A policy determines how the system must react to a user request, depending on the request's risk scores.

Each policy consists of an *Action* plug-in, a risk score and several ranges and associated actions. The ranges represent the possible values of the chosen risk score. Each range corresponds with a certain risk level and is connected with a certain action.  In most cases the intention of the policy is to execute a countermeasure to a malicious user request. In that case, the *NevisProxyActionPlugin* has to be selected as *Action* plug-in, and it's actions PASSTHROUGH, AUTHENTICATE and BLOCK must be assigned to certain ranges of the selected risk scores.  You can define as many policies as you like. If more than one policy is matching, the most significant action of the *NevisProxyActionPlugin* is selected.

The policy handling task includes the following use cases:

* Create a new policy
* View the details of a policy
* Activate or deactivate a policy
* Modify an existing policy

## Use case: Create a new policy

You create a new policy in the *Policy creation* view of the *Policy* section. Proceed as follows, see the figure below:

1. To open the *Policy creation* view in the nevisDetect web application,
    1. Select *Policy* from the top menu.
    2. Then select *Policy creation* in the navigation on the left.
2. To set the name of the new policy,
    1. Click the *Pencil* icon on the right of the name field.
    2. Enter the name in the now editable field.
    3. Click the ***X*** icon to save the name.
3. Select the *Action plug-in* in the drop-down menu.
4. Select the *Risk score* in the drop-down menu.
5. The *Risk score range* field shows the risk score range to define. If you create a new policy, this field automatically shows "Range 1". To define the start and end risk score values of the range,
    1. Either enter the start value in the *Range start* field and the end value in the *Range end* field, or
    2. Use the slider on the bottom of the field to set the range.
6. Specify the action to connect to this risk score range in the *Action* field.
7. You can enter a description in the *Notes* field.
8. Click the *Save* button to save this range.
9. To add the next range, click the Drop-down menu icon on the *Save* button, and select *Add new range* from the drop-down menu.
10. Repeat the previous steps, until you have defined all the ranges of your policy.

<img className="boxed" src={require('../../../attachments/6645080/6645586.png').default} alt="Security expert - Create a new policy"/>

## Sample policy

The next figure shows an example of a policy. Here, the first range covers normalized risk scores between 0.0 and 0.2. This is considered as a low risk and associated with the action "PASSTHROUGH" (shown in the chart as a blue block).That is, if for a specific user interaction nevisDetect calculates a normalized risk score in between 0.0 and 0.2, no protective action is required. The user can continue doing what he was doing ("PASSTHROUGH"). However, if nevisDetect estimates the risk of this user interaction somewhere in between 0.2 and 0.5, there is a medium risk that this user request is malicious. In this case, the user needs to re-authenticate (action "AUTHENTICATE" - shown in the chart as a green block). If the calculated risk for this user interaction lies in between 0.5 and 1.0, nevisDetect considers this as a high risk and blocks the user (action "BLOCK" - shown in red in the chart). The user cannot do anything anymore.

This example only pertains to users that are not considered as untrained by the system.

<img className="boxed" src={require('../../../attachments/6645080/6645587.png').default} alt=""/>

For a description of the *Policy creation* view, see the chapter Policy section.

## Use case: View the details of a policy

The *Policy overview* view in the *Policy* section lists all available policies.

To view the details of a policy, proceed as follows (see the [figure below]:

1. To open the *Policy overview* view in the nevisDetect web application,

1. Select *Policy* from the top menu.
2. Then select *Policy overview* in the navigation on the left.
2. The available policies are listed in the view.

3. Click the *Expand* icon to display a policy's details.
3. The policy details appear in the *Policy details* field.

<img className="boxed" src={require('../../../attachments/6645080/6645582.png').default} alt="Security expert - View policy details"/>

For a description of the *Policy overview* view, see the chapter Policy section.

## Use case: Activate or deactivate a policy

The *Policy overview* view in the *Policy* section lists all available policies. In the same view, you can activate or deactivate a policy. There can only be one policy valid (active) at a time.

Proceed as follows, see the figure below - the numbers in the figure correspond with the numbered steps below:

1. To open the *Policy overview* view in the nevisDetect web application,
    1. Select *Policy* from the top menu.
    2. Then select *Policy overview* in the navigation on the left.
2. The *Policy overview* field lists all available policies. To activate or deactivate a certain policy, click the *Activate/Deactivate* button on the right side of the policy's entry.

<img className="boxed" src={require('../../../attachments/6645080/6645588.png').default} alt="Security export - Enable policy"/>

For a description of the *Policy overview* view, see the chapter Policy section.

## Use case: Modify an existing policy

The entry point to modify an existing policy is again the *Policy overview* view. Proceed as follows:

1. To open the *Policy overview* view in the nevisDetect web application,
    1. Select *Policy* from the top menu.
    2. Then select *Policy overview* in the navigation on the left.
2. The *Policy overview* field lists all available policies. To modify a policy,
    1. Click the *Drop-down menu* icon on the *Activate/Deactivate* button on the right side of the policy's entry.
    2. If you want to edit the policy's settings, select *Edit* from the drop-down menu. This opens a view with the settings of the relevant policy. You can modify the policy settings in this view (which is the same screen as the [Policy creation].

     For a description of the *Policy creation* view, see the chapter Policy section.

     3. If you want to delete a policy completely, select *Delete* from the drop-down menu.

<img className="boxed" src={require('../../../attachments/6645080/6645583.png').default} alt="Security expert - Modify policy"/>
--------------------------------------------------------------------------------
Section: ### Application-management.md
---
sidebar_position: 68
---

# Application management

Another task of the security expert is the overall management of the nevisDetect application. This includes specifying which plug-ins to include in the detection process (that is, enabling or disabling a plug-in), as well as setting the modes of operation and communication.

The following use cases are involved:

* Request filter management
* Enable or disable a plug-in
* Cleanup the request history
* Set the operation mode
* Set the communication mode

## Use case: Request filter management

The security expert has the possibility to modify the request filters. The request filters are used to define the way the system deals with requests during request processing.

You add or modify the request filters in the Application management view. Proceed as follows (see the  figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Application management* view in the nevisDetect web application,
    1. Select *Status* from the top menu.
    2. Then select *Application management* in the navigation on the left.
2. You can add/edit the request filters in the *Request filter management* section:
    3. To add a new filter, click the *Add filter* button.
    4. To modify the order of the filters, drag the filter entry up or down. The system will execute the request filters in the order you define here.
    To modify a filter, click on the *Pencil* icons or change the selection in the drop-down menus.
    3. To delete a filter, click on the Tr*a*sh icon.

Each filter has the following setting options (columns):

* You enable or disable the filter by clicking on the *Toggle* button in the *Enabled* column.
* To change the name of the filter, click on the *Pencil* icon in the *Filter name* column.
* With the *Propagate risk scores* button, you can define whether to propagate the risk scores to the application in the backend, in case the request matches the filter. If you enable this function, the system sends the risk scores to the backend application by adding the risk scores to the request header.
* In the *Source* column, you define which part of the request is included in the filter check: the request Body, Uri, Query or Header.
* You set the condition in the *Qualifier* column. If you select "Contain" or "Does not contain", the source must include/not include the attribute entered in the *Attribute* column. In case you select "Regex", the source should match the defined regular expression in the *Expression* column.
* In the *Processing* column, you can override the request processing settings defined for the feature correlator in the *Components* field. A request that matches the filter can either be processed synchronously ("Synchronous") or asynchronously ("Asynchronous"/"Batch") or not processed at all ("Do not process").

<img className="boxed" src={require('../../../attachments/6645083/6645604.png').default} alt="Security expert - Request filter management"/>

## Use case: Enable or disable an action or risk plug-in

Enabling and disabling an Action or Risk plug-in takes place in the Application management view of the Status section. The procedure is the same for Action and Risk plug-ins, we show here it here for an Action plug-in. Proceed as follows (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Application management* view in the nevisDetect web application,
    1. Select *Status* from the top menu.
    2. Then select *Application management* in the navigation on the left.
2. The *Action plug-ins* and *Risk plug-in* parts of the view lists all available plug-ins and nevisDetect components.
    1. To enable or disable a plug-in, click the *On/Off* button on left side of the relevant plug-in entry.

<img className="boxed" src={require('../../../attachments/6645083/6645580.png').default} alt="Security expert - Enabling plug-ins"/>

For more information on the *Application management* view, see the chapter Status section.

## Use case: Clean up the request history

It is possible to clean up the request history, to reduce the amount of data stored in the database. The security expert can either clean up the request history himself, or make the system do this. In the latter case, the security expert must specify when the system should perform the cleanup. Proceed as follows (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Application management* view in the nevisDetect web application,
    1. Select *Status* from the top menu.
    2. Then select *Application management* in the navigation on the left.
2. Go to the *Persistency* component entry (in the *Components* part of the screen.) Click on the arrow icon for a detailed view. You can specify the following cleanup settings:
    1. To trigger an immediate cleanup, click the *Cleanup* button. If you want to keep the most recent requests/risk scores, enter the number of past days to exclude from the cleanup in the *Request history*/*Risk score history* fields just above. Selecting the checkbox *All* means that all history is kept in the database.
    2. You can also let the system do the cleanup, via a cron job in the background. First specify the settings for the cleanup in the *Request history* and *Risk score history* fields (*Settings* section). For the meaning of these fields, see above. Then click the *Save* button to save your settings.

<img className="boxed" src={require('../../../attachments/6645083/6645605.png').default} alt="Security expert - Cleanup the request history"/>

For more information on the *Application management* view, see the chapter Status section.

## Use case: Set the operation mode

An important use case of the security expert is to decide in which mode nevisDetect must operate. Before nevisDetect can start detecting malicious HTTP requests, it must pass a training phase. During this phase, nevisDetect is just collecting data, so that the detection technologies can train their models. A specific plug-in/detection technology has collected enough data of a specific user, if for this user the average plug-in risk score (the mean) and the variance do no longer change from day to day. From that point on, you can switch the plug-in into the detection phase.

It is the security expert's task to specify when the moment has come to switch from the training into the detection phase. You set these operation modes in the Application management view. Proceed as follows (see the figure below - the numbers in the figure correspond with the numbered steps below):

1. To open the *Application management* view in the nevisDetect web application,
    1. Select *Status* from the top menu.
    2. Then select *Application management* in the navigation on the left.
2. You set the operation mode in the *Operation mode* field/drop-down menu. There are three options:
   * In the "Training" operation mode, nevisDetect is just collecting data, so that the detection technologies can train their models.
   * In the "Detection" operation mode, the system blocks the requests of an untrained user by creating a rule with a BLOCK action. This operation mode makes sense if there is a closed user group, and all users have participated in the training phase.
   * In the "Mixed" operation mode, the system processes the requests of an untrained user as if it is in the training phase. This operation mode is useful if not all users have participated in the training phase, or if new users have been onboarded after completion of the training phase.

<img className="boxed" src={require('../../../attachments/6645083/6645581.png').default} alt="Security expert - Setting the operation mode"/>

For more information on the *Application management* view, see the chapter Status section.

## Use case: Set the communication mode

Another important use case of the security expert is to set the communication mode. The communication mode defines how nevisDetect communicates with nevisProxy. If a policy classifies a user request as fraudulent, the *NevisProxyActionPlugin* is invoked. The communication mode specifies how and when the *NevisProxyActionPlugin* propagates the created rule to nevisProxy.

You set the communication mode in the *Application management* view. Proceed as follows, see the figure below:

1. To open the *Application management* view in the nevisDetect web application,
    1. Select *Status* from the top menu.
    2. Then select *Application management* in the navigation on the left.
2. You set the communication mode in the *Communication mode* field of the *Feature correlator*component entry (in the *Components* part of the screen). There are three options:
   * In case of a "Synchronous" communication mode, nevisProxy is notified by the *NevisProxyActionPlugin* *before* the fraudulent request is passed on to the application in the back end. The request will be blocked.
   * In the "Asynchronous" communication mode, the fraudulent request is passed on to the application in the back end. nevisProxy will be notified by the *NevisProxyActionPlugin* in an asynchronous manner. That is, not this request, but the subsequent request of the same user will be blocked by nevisProxy.
   * The  "Batch" communication mode is like the "Asynchronous" mode. The only difference is that due to performance optimization a batch of requests will be processed together.

3. You can also specify which risk score (rules) are propagated to the backend. You do this in the *Risk score propagation* list, by enabling the respective risk score.

<img className="boxed" src={require('../../../attachments/6645083/6645602.png').default} alt="Security expert - Setting the communication mode"/>

For more information on the *Application management* view, see chapter Status section.
--------------------------------------------------------------------------------
Section: ### `LogoutURI`
URI path (relative to server host and application context) on that logout (session termination) should be initiated. Use this option for applications without dedicated logout facilities.

Syntax: `<URL-path>`

Default  none
--------------------------------------------------------------------------------
Section: ### Nevis Context
Ninja is always active within a J2EE container as part of the protected web application.

The figure below shows the role of Ninja in the Nevis context.

<img className="boxed" src={require('./assets/8000663.png').default} alt="Ninja in the Nevis context"/>

To explain the basic principle of Ninja, the interactions between these components may be simplified as follows:

1. The user's browser sends an HTTP request to the reverse proxy. If not yet logged on, the reverse proxy redirects the browser to a login page.
2. The actual authentication is delegated to the authentication service. Although the authentication process may consist of multiple (interactive) steps, it is simplified as one arrow in the drawing. This is because we are only interested in the result of the authentication. The authentication server returns a secure token to the reverse proxy, and this token is stored in the user's single sign-on session.
3. After successful authentication, subsequent requests of the same user are passed directly to the J2EE container, with one important addition: each request contains the secure token as an additional HTTP header. It is now Ninja's task to verify this token and to reject any invalid request.
--------------------------------------------------------------------------------
Section: ### Ninja Features
* **Secure Token Verification:** Only requests containing a correct token are accepted and passed to the web application. A token is considered correct if it has been issued by a trusted authenticator and if the contained data has not been tampered with, i.e., the token is *authentic*.

 Often, the token is verified on the first request only. For subsequent requests, the application server identifies the original caller with the aid of a tracking mechanism (like a HTTP cookie).
* **SAML Assertion Verification:** Ninja can verify and consume SAML assertions instead of Nevis SecTokens. No configuration change is necessary for this, but all the JARs of the *jcan-saml* library (available from Nevis, notably: *jcan-saml*, *jcan-saml-xmlbeans*) must be placed in the same class path as the Ninja JARs. Alternatively this could be also achieved by using the Ninja uber JAR. Note that even though a SAML assertion (or a SAML response) is consumed, the means of communicating this message depends on Ninja and does not conform to the transport mechanisms of the SAML 2.0 protocol specification.
* **Servlet Authentication:** This is the simple authentication method defined in the Java Servlet specification. It uses a *Principal* object to identify users and in turn contains public and private credentials. The central methods for obtaining the principal and doing authorization checks are *HttpServletRequest.getUserPrincipal()* and *HttpServletRequest.isUserInRole(String)*.
* **JAAS Authentication:** The authentication modules plug into the application servers authentication framework to support declarative and programmatic security according to the J2EE standards. The authentication results in a JAAS Subject representing the users identity and roles. All further security checks are based on this *Subject*. The container propagates the *Subject* to other tiers to achieve end-to-end security.
* **Container Session Invalidation:** To save valuable resources, and for security reasons, a user's application server session should be invalidated before the single sign-on session terminates (or as it terminates at the latest). Ninja can terminate the user session with an HTTP request. The kill-request is normally either sent by the authentication server or by the reverse proxy (see nevisProxy RefGuide on "LogoutURI").
* **Multiple Signer Certificates:** Allows the configuration of one or more trusted signer certificates, or even a trusted certificate directory. This is not only useful if the tokens to be verified are issued by more than one authentication service, but also for the transition phase when an issuer certificate expires.
* **Optional Authentication:** This mode of operation allows applications to respond both to authenticated and non-authenticated (anonymous) requests. A session may run for a time without authentication and then require the user to authenticate at a particular point. This may be triggered by the user accessing a protected functionality (on which optional authentication is disabled) or by the application sending a response that triggers the authentication procedure.
* **Development Mode:** Maintaining a Nevis environment for application development may not be feasible or wanted. The development mode (DevMode) of Ninja simulates such an integrated environment without the need for any additional components or complex configuration constructs. In DevMode, Ninja will generate a SecToken for a user request and inject user properties as configured. This is transparent to the application so that it can operate as if in an integrated setup and even use SecTokens to communicate with further servers.
--------------------------------------------------------------------------------
Section: #### Custom Role Getters
To customize the process of finding roles, Ninja allows implementing custom `RoleGetter`s: Implement the interface `ch.nevis.ninja.commons.mapping.RoleGetter`. The constructor must take a single `Map<String,String>` in which the configuration parameters will be passed. Place the JAR file containing the code together with all required dependencies in the class path or module of the container.

To activate a custom `RoleGetter`, specify its full class name in the Ninja configuration in option `RoleGetters`. Any name/value pairs contained in the `RoleGetter` configuration are passed to your constructor in the `Map`.

## Logging

Ninja uses [SLF4J](https://www.slf4j.org/) as a logging facade, which allows seamless integration with any bigger logging framework. To enable Ninja logs next to the web application logs, a binding JAR matching to the logging framework of the web application is to be provided during runtime. Ninja does not provide any concrete logging provider or binding out of the box, this is to be done by the web application integration project itself. See the [related chapter of the SLF4J manual](https://www.slf4j.org/manual.html#swapping).

Ninja uses the `ch.nevis.ninja` logger for its log messages, which we recommend to be added to the configuration file of the logging framework used by the web application. After that, configuring Ninja log appenders and log levels can be done the same way as for the web application itself.

## Development Mode

Ninja can run in an operation mode which does not require a Nevis access management setup. This is useful in development environments, where focus is set on the application, and maintaining a complete SSO system is both unnecessary and prohibitive for testing. The configuration of the development mode (DevMode) introduces only a minimal modification to a productive Ninja setup, requiring only a few settings in the Ninja configuration block.

Enable the DevMode by setting the Ninja parameter `DevMode="true"` and by configuring the following:

* **DevDir:** Filesystem directory where Ninja stores generated SecTokens and their source properties.
* **DevTokenSignerCert:** The signer certificate of SecTokens. This is usually identical to NevisSignerCertificate, but exactly one certificate must be identified. Accepts PEM, DER and JKS (with `<file>?alias=<alias>` notation) files.
* **DevTokenSignerKey:** The signer key to use when generating SecTokens. Accepts JKS (with `<file>?alias=<alias>` notation) and PKCS8 encoded DER key files.
* **DevTokenSignerKeyPassphrase:** The passphrase for the signer key. Use `file://<file>`, `pipe://<passphrase-getter>` or `secret://<obfuscated-passphrase>` to hide the password from the configuration.
* **DevPassword:** The password the users must provide to use DevMode.

Once DevMode is enabled, an incoming request is processed as follows:

1. If no BasicAuth Header is provided, request entry of a password from user with a 401 Basic Auth challenge.
2. If a BasicAuth Header has provided a user name and a password, the password is compared to the configured DevPassword.
3. If the password is correct, Ninja searches for specific files in the configured DevDir. Ninja searches for the following two files in the configured DevDir:
    * `devmode_<userId>.properties`: contains the properties of the user
    * `devmode_<userId>_generated_sectoken.xml`: contains the last generated SecToken
    * The user name provided in the BasicAuth header is used to find the properties file. The same user name is checked against the *userId* in the SecToken generated by DevMode. Use the *UserGetter* mechanism if the user name in the application should be different from the *userId* that is be set by Nevis
4. If no user properties file was found, Ninja generates a default SecToken for the user, creating the above files in the process.
5. If the user properties were found, but no SecToken file or the SecToken file is older than the user properties file, then Ninja regenerates the SecToken according to the user properties, rewriting the SecToken file in the process.
6. If the user properties are older than the SecToken file and the SecToken loaded from the file is still valid, then Ninja (re-)uses that SecToken.
7. Once a SecToken has been loaded or generated, normal processing is resumed. The token is validated and consumed as usual.

The above procedure allows dynamically adding users simply by logging in initially. Then, the new user's property files can be modified to differentiate them. The default user properties are:

```
_signAlg=SHA1withRSA
_format=CSSO-1.0
_age=10000
_ttl=62208000
esauthid=Ninja-DevMode
entryid=Ninja-DevMode
domain=NINJA_DEVMODE
userid=<userid>
loginId=<userid>
roles=user
sessid=<timestamp>
authLevel=auth.weak
```

Properties beginning with an underscore `_` modify the metadata fields of the SecToken. The known fields are:

* `_signAlg`: algorithm of signature
* `_format`: SecToken format
* `_age`: age of SecToken when generated, in milliseconds
* `_ttl`: time-to-live of SecToken, in seconds

All other properties is passed as attributes to the SecToken format builder. Note that depending on the SecToken format, some attributes may be handled as special cases. Removing any of the default attributes is therefore not advised.

## Common Configuration Properties
--------------------------------------------------------------------------------
